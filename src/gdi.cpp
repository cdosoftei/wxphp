/*
 * @author Mário Soares
 * @contributors Jefferson González
 * @contributors René Vögeli / Rangee GmbH
 * 
 * @license 
 * This file is part of wxPHP check the LICENSE file for information.
 * 
 * @note
 * This file was auto-generated by the wxPHP source maker
*/

#include "php_wxwidgets.h"
#include "appmanagement.h"
#include "cfg.h"
#include "bookctrl.h"
#include "dnd.h"
#include "cmndlg.h"
#include "containers.h"
#include "ctrl.h"
#include "data.h"
#include "dc.h"
#include "docview.h"
#include "events.h"
#include "file.h"
#include "gdi.h"
#include "grid.h"
#include "html.h"
#include "help.h"
#include "logging.h"
#include "managedwnd.h"
#include "menus.h"
#include "misc.h"
#include "miscwnd.h"
#include "media.h"
#include "net.h"
#include "pickers.h"
#include "printing.h"
#include "ribbon.h"
#include "richtext.h"
#include "rtti.h"
#include "stc.h"
#include "streams.h"
#include "threading.h"
#include "validator.h"
#include "vfs.h"
#include "aui.h"
#include "winlayout.h"
#include "xml.h"
#include "xrc.h"
#include "dvc.h"
#include "others.h"


BEGIN_EXTERN_C()
void php_wxBitmapBundle_free(void *object)
{
    zo_wxBitmapBundle* custom_object = (zo_wxBitmapBundle*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxBitmapBundle_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxBitmapBundle done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxBitmapBundle_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxBitmapBundle_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundle* custom_object;

    custom_object = (zo_wxBitmapBundle*) ecalloc(
        1,
        sizeof(zo_wxBitmapBundle)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxBitmapBundle_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXBITMAPBUNDLE_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxBitmapBundle::wxBitmapBundle()
   Default constructor constructs an empty bundle. */
PHP_METHOD(php_wxBitmapBundle, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapBundle::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundle* current_object;
    wxBitmapBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    zval* bitmap1;
    wxBitmap* object_pointer1_0 = 0;
    bool overload1_called = false;

    //Parameters for overload 2
    zval* icon2;
    wxIcon* object_pointer2_0 = 0;
    bool overload2_called = false;

    //Parameters for overload 3
    zval* image3;
    wxImage* object_pointer3_0 = 0;
    bool overload3_called = false;

    //Parameters for overload 4
    zval* other4;
    wxBitmapBundle* object_pointer4_0 = 0;
    bool overload4_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&bitmap1, php_wxBitmap_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap1, php_wxBitmap_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap1)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap1)->native_object;
                    object_pointer1_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer1_0 )
                    {
                        goto overload2;
                    }
                }
                else if(Z_TYPE_P(bitmap1) != IS_NULL)
                {
                    goto overload2;
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&icon2, php_wxIcon_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &icon2, php_wxIcon_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(icon2) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxIcon_P(icon2)->object_type;
                    argument_native_object = (void*) Z_wxIcon_P(icon2)->native_object;
                    object_pointer2_0 = (wxIcon*) argument_native_object;
                    if (!object_pointer2_0 )
                    {
                        goto overload3;
                    }
                }
                else if(Z_TYPE_P(icon2) != IS_NULL)
                {
                    goto overload3;
                }
            }

            overload2_called = true;
            already_called = true;
        }
    }

    //Overload 3
    overload3:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&image3, php_wxImage_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &image3, php_wxImage_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(image3) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxImage_P(image3)->object_type;
                    argument_native_object = (void*) Z_wxImage_P(image3)->native_object;
                    object_pointer3_0 = (wxImage*) argument_native_object;
                    if (!object_pointer3_0 )
                    {
                        goto overload4;
                    }
                }
                else if(Z_TYPE_P(image3) != IS_NULL)
                {
                    goto overload4;
                }
            }

            overload3_called = true;
            already_called = true;
        }
    }

    //Overload 4
    overload4:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&other4, php_wxBitmapBundle_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &other4, php_wxBitmapBundle_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(other4) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmapBundle_P(other4)->object_type;
                    argument_native_object = (void*) Z_wxBitmapBundle_P(other4)->native_object;
                    object_pointer4_0 = (wxBitmapBundle*) argument_native_object;
                    if (!object_pointer4_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'other' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(other4) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'other' not null, could not be retreived correctly.");
                }
            }

            overload4_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxBitmapBundle_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxBitmap*) object_pointer1_0)\n");
                #endif

                native_object = new wxBitmapBundle_php(*(wxBitmap*) object_pointer1_0);

                native_object->references.Initialize();
                ((wxBitmapBundle_php*) native_object)->references.AddReference(bitmap1, "wxBitmapBundle::wxBitmapBundle at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxIcon*) object_pointer2_0)\n");
                #endif

                native_object = new wxBitmapBundle_php(*(wxIcon*) object_pointer2_0);

                native_object->references.Initialize();
                ((wxBitmapBundle_php*) native_object)->references.AddReference(icon2, "wxBitmapBundle::wxBitmapBundle at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    if(overload3_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxImage*) object_pointer3_0)\n");
                #endif

                native_object = new wxBitmapBundle_php(*(wxImage*) object_pointer3_0);

                native_object->references.Initialize();
                ((wxBitmapBundle_php*) native_object)->references.AddReference(image3, "wxBitmapBundle::wxBitmapBundle at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    if(overload4_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxBitmapBundle*) object_pointer4_0)\n");
                #endif

                native_object = new wxBitmapBundle_php(*(wxBitmapBundle*) object_pointer4_0);

                native_object->references.Initialize();
                ((wxBitmapBundle_php*) native_object)->references.AddReference(other4, "wxBitmapBundle::wxBitmapBundle at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxBitmapBundle_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxBitmapBundle::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto bool wxBitmapBundle::IsOk()
   Check if bitmap bundle is non-empty. */
PHP_METHOD(php_wxBitmapBundle, IsOk)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapBundle::IsOk\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundle* current_object;
    wxphp_object_type current_object_type;
    wxBitmapBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapBundle::IsOk call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPBUNDLE_TYPE){
                references = &((wxBitmapBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxBitmapBundle::IsOk())\n\n");
                #endif

                RETVAL_BOOL(((wxBitmapBundle_php*)native_object)->IsOk());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapBundle::IsOk\n"
        );
    }
}
/* }}} */

/* {{{ proto wxSize wxBitmapBundle::GetDefaultSize()
   Get the size of the bitmap represented by this bundle in default resolution or, equivalently, at 100% scaling. */
PHP_METHOD(php_wxBitmapBundle, GetDefaultSize)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapBundle::GetDefaultSize\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundle* current_object;
    wxphp_object_type current_object_type;
    wxBitmapBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapBundle::GetDefaultSize call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPBUNDLE_TYPE){
                references = &((wxBitmapBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBitmapBundle::GetDefaultSize() to return new object\n\n");
                #endif

                wxSize value_to_return0;
                value_to_return0 = ((wxBitmapBundle_php*)native_object)->GetDefaultSize();
                void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxSize));
                object_init_ex(return_value, php_wxSize_entry);
                ((wxSize_php*)ptr)->phpObj = *return_value;
                zo_wxSize* zo0 = Z_wxSize_P(return_value);
                zo0->native_object = (wxSize_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapBundle::GetDefaultSize\n"
        );
    }
}
/* }}} */

/* {{{ proto wxSize wxBitmapBundle::GetPreferredBitmapSizeAtScale(float scale)
   Get the size that would be best to use for this bundle at the given DPI scaling factor. */
PHP_METHOD(php_wxBitmapBundle, GetPreferredBitmapSizeAtScale)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapBundle::GetPreferredBitmapSizeAtScale\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundle* current_object;
    wxphp_object_type current_object_type;
    wxBitmapBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapBundle::GetPreferredBitmapSizeAtScale call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPBUNDLE_TYPE){
                references = &((wxBitmapBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    double scale0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'd' (&scale0)\n");
        #endif

        char parse_parameters_string[] = "d";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &scale0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBitmapBundle::GetPreferredBitmapSizeAtScale(scale0) to return new object\n\n");
                #endif

                wxSize value_to_return1;
                value_to_return1 = ((wxBitmapBundle_php*)native_object)->GetPreferredBitmapSizeAtScale(scale0);
                void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxSize));
                object_init_ex(return_value, php_wxSize_entry);
                ((wxSize_php*)ptr)->phpObj = *return_value;
                zo_wxSize* zo1 = Z_wxSize_P(return_value);
                zo1->native_object = (wxSize_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapBundle::GetPreferredBitmapSizeAtScale\n"
        );
    }
}
/* }}} */

/* {{{ proto wxSize wxBitmapBundle::GetPreferredBitmapSizeFor(wxWindow window)
   Get the size that would be best to use for this bundle at the DPI scaling factor used by the given window. */
PHP_METHOD(php_wxBitmapBundle, GetPreferredBitmapSizeFor)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapBundle::GetPreferredBitmapSizeFor\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundle* current_object;
    wxphp_object_type current_object_type;
    wxBitmapBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapBundle::GetPreferredBitmapSizeFor call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPBUNDLE_TYPE){
                references = &((wxBitmapBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* window0;
    wxWindow* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&window0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &window0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(window0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxWindow_P(window0)->object_type;
                    argument_native_object = (void*) Z_wxWindow_P(window0)->native_object;
                    object_pointer0_0 = (wxWindow*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'window' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(window0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'window' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBitmapBundle::GetPreferredBitmapSizeFor((const wxWindow*) object_pointer0_0) to return new object\n\n");
                #endif

                wxSize value_to_return1;
                value_to_return1 = ((wxBitmapBundle_php*)native_object)->GetPreferredBitmapSizeFor((const wxWindow*) object_pointer0_0);
                void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxSize));
                object_init_ex(return_value, php_wxSize_entry);
                ((wxSize_php*)ptr)->phpObj = *return_value;
                zo_wxSize* zo1 = Z_wxSize_P(return_value);
                zo1->native_object = (wxSize_php*) ptr;

                references->AddReference(window0, "wxBitmapBundle::GetPreferredBitmapSizeFor at call 1 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapBundle::GetPreferredBitmapSizeFor\n"
        );
    }
}
/* }}} */

/* {{{ proto wxSize wxBitmapBundle::GetPreferredLogicalSizeFor(wxWindow window)
   Get the size that would be best to use for this bundle at the DPI scaling factor used by the given window in logical size. */
PHP_METHOD(php_wxBitmapBundle, GetPreferredLogicalSizeFor)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapBundle::GetPreferredLogicalSizeFor\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundle* current_object;
    wxphp_object_type current_object_type;
    wxBitmapBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapBundle::GetPreferredLogicalSizeFor call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPBUNDLE_TYPE){
                references = &((wxBitmapBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* window0;
    wxWindow* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&window0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &window0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(window0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxWindow_P(window0)->object_type;
                    argument_native_object = (void*) Z_wxWindow_P(window0)->native_object;
                    object_pointer0_0 = (wxWindow*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'window' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(window0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'window' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBitmapBundle::GetPreferredLogicalSizeFor((const wxWindow*) object_pointer0_0) to return new object\n\n");
                #endif

                wxSize value_to_return1;
                value_to_return1 = ((wxBitmapBundle_php*)native_object)->GetPreferredLogicalSizeFor((const wxWindow*) object_pointer0_0);
                void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxSize));
                object_init_ex(return_value, php_wxSize_entry);
                ((wxSize_php*)ptr)->phpObj = *return_value;
                zo_wxSize* zo1 = Z_wxSize_P(return_value);
                zo1->native_object = (wxSize_php*) ptr;

                references->AddReference(window0, "wxBitmapBundle::GetPreferredLogicalSizeFor at call 1 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapBundle::GetPreferredLogicalSizeFor\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmap wxBitmapBundle::GetBitmap(wxSize size)
   Get bitmap of the specified size, creating a new bitmap from the closest available size by rescaling it if necessary. */
PHP_METHOD(php_wxBitmapBundle, GetBitmap)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapBundle::GetBitmap\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundle* current_object;
    wxphp_object_type current_object_type;
    wxBitmapBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapBundle::GetBitmap call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPBUNDLE_TYPE){
                references = &((wxBitmapBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* size0;
    wxSize* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&size0, php_wxSize_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &size0, php_wxSize_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(size0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(size0)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(size0)->native_object;
                    object_pointer0_0 = (wxSize*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(size0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBitmapBundle::GetBitmap(*(wxSize*) object_pointer0_0) to return new object\n\n");
                #endif

                wxBitmap value_to_return1;
                value_to_return1 = ((wxBitmapBundle_php*)native_object)->GetBitmap(*(wxSize*) object_pointer0_0);
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxBitmap));
                object_init_ex(return_value, php_wxBitmap_entry);
                ((wxBitmap_php*)ptr)->phpObj = *return_value;
                zo_wxBitmap* zo1 = Z_wxBitmap_P(return_value);
                zo1->native_object = (wxBitmap_php*) ptr;

                references->AddReference(size0, "wxBitmapBundle::GetBitmap at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapBundle::GetBitmap\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmap wxBitmapBundle::GetBitmapFor(wxWindow window)
   Get bitmap of the size appropriate for the DPI scaling used by the given window. */
PHP_METHOD(php_wxBitmapBundle, GetBitmapFor)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapBundle::GetBitmapFor\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundle* current_object;
    wxphp_object_type current_object_type;
    wxBitmapBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapBundle::GetBitmapFor call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPBUNDLE_TYPE){
                references = &((wxBitmapBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* window0;
    wxWindow* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&window0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &window0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(window0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxWindow_P(window0)->object_type;
                    argument_native_object = (void*) Z_wxWindow_P(window0)->native_object;
                    object_pointer0_0 = (wxWindow*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'window' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(window0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'window' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBitmapBundle::GetBitmapFor((const wxWindow*) object_pointer0_0) to return new object\n\n");
                #endif

                wxBitmap value_to_return1;
                value_to_return1 = ((wxBitmapBundle_php*)native_object)->GetBitmapFor((const wxWindow*) object_pointer0_0);
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxBitmap));
                object_init_ex(return_value, php_wxBitmap_entry);
                ((wxBitmap_php*)ptr)->phpObj = *return_value;
                zo_wxBitmap* zo1 = Z_wxBitmap_P(return_value);
                zo1->native_object = (wxBitmap_php*) ptr;

                references->AddReference(window0, "wxBitmapBundle::GetBitmapFor at call 1 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapBundle::GetBitmapFor\n"
        );
    }
}
/* }}} */

/* {{{ proto wxIcon wxBitmapBundle::GetIcon(wxSize size)
   Get icon of the specified size. */
PHP_METHOD(php_wxBitmapBundle, GetIcon)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapBundle::GetIcon\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundle* current_object;
    wxphp_object_type current_object_type;
    wxBitmapBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapBundle::GetIcon call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPBUNDLE_TYPE){
                references = &((wxBitmapBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* size0;
    wxSize* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&size0, php_wxSize_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &size0, php_wxSize_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(size0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(size0)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(size0)->native_object;
                    object_pointer0_0 = (wxSize*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(size0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBitmapBundle::GetIcon(*(wxSize*) object_pointer0_0) to return new object\n\n");
                #endif

                wxIcon value_to_return1;
                value_to_return1 = ((wxBitmapBundle_php*)native_object)->GetIcon(*(wxSize*) object_pointer0_0);
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxIcon));
                object_init_ex(return_value, php_wxIcon_entry);
                ((wxIcon_php*)ptr)->phpObj = *return_value;
                zo_wxIcon* zo1 = Z_wxIcon_P(return_value);
                zo1->native_object = (wxIcon_php*) ptr;

                references->AddReference(size0, "wxBitmapBundle::GetIcon at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapBundle::GetIcon\n"
        );
    }
}
/* }}} */

/* {{{ proto wxIcon wxBitmapBundle::GetIconFor(wxWindow window)
   Get icon of the size appropriate for the DPI scaling used by the given window. */
PHP_METHOD(php_wxBitmapBundle, GetIconFor)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapBundle::GetIconFor\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundle* current_object;
    wxphp_object_type current_object_type;
    wxBitmapBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapBundle::GetIconFor call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPBUNDLE_TYPE){
                references = &((wxBitmapBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* window0;
    wxWindow* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&window0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &window0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(window0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxWindow_P(window0)->object_type;
                    argument_native_object = (void*) Z_wxWindow_P(window0)->native_object;
                    object_pointer0_0 = (wxWindow*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'window' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(window0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'window' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBitmapBundle::GetIconFor((const wxWindow*) object_pointer0_0) to return new object\n\n");
                #endif

                wxIcon value_to_return1;
                value_to_return1 = ((wxBitmapBundle_php*)native_object)->GetIconFor((const wxWindow*) object_pointer0_0);
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxIcon));
                object_init_ex(return_value, php_wxIcon_entry);
                ((wxIcon_php*)ptr)->phpObj = *return_value;
                zo_wxIcon* zo1 = Z_wxIcon_P(return_value);
                zo1->native_object = (wxIcon_php*) ptr;

                references->AddReference(window0, "wxBitmapBundle::GetIconFor at call 1 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapBundle::GetIconFor\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxBitmapBundle::IsSameAs(wxBitmapBundle other)
   Check if the two bundles refer to the same object. */
PHP_METHOD(php_wxBitmapBundle, IsSameAs)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapBundle::IsSameAs\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundle* current_object;
    wxphp_object_type current_object_type;
    wxBitmapBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapBundle::IsSameAs call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPBUNDLE_TYPE){
                references = &((wxBitmapBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* other0;
    wxBitmapBundle* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&other0, php_wxBitmapBundle_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &other0, php_wxBitmapBundle_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(other0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmapBundle_P(other0)->object_type;
                    argument_native_object = (void*) Z_wxBitmapBundle_P(other0)->native_object;
                    object_pointer0_0 = (wxBitmapBundle*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'other' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(other0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'other' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxBitmapBundle::IsSameAs(*(wxBitmapBundle*) object_pointer0_0))\n\n");
                #endif

                RETVAL_BOOL(((wxBitmapBundle_php*)native_object)->IsSameAs(*(wxBitmapBundle*) object_pointer0_0));

                references->AddReference(other0, "wxBitmapBundle::IsSameAs at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapBundle::IsSameAs\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmapBundle wxBitmapBundle::FromBitmaps(wxBitmap bitmap1, wxBitmap bitmap2) */
PHP_METHOD(php_wxBitmapBundle, FromBitmaps)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapBundle::FromBitmaps\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundle* current_object;
    wxphp_object_type current_object_type;
    wxBitmapBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapBundle::FromBitmaps call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPBUNDLE_TYPE){
                references = &((wxBitmapBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* bitmap10;
    wxBitmap* object_pointer0_0 = 0;
    zval* bitmap20;
    wxBitmap* object_pointer0_1 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'OO' (&bitmap10, php_wxBitmap_entry, &bitmap20, php_wxBitmap_entry)\n");
        #endif

        char parse_parameters_string[] = "OO";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap10, php_wxBitmap_entry, &bitmap20, php_wxBitmap_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap10) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap10)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap10)->native_object;
                    object_pointer0_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'bitmap1' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(bitmap10) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'bitmap1' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 2){
                if(Z_TYPE_P(bitmap20) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap20)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap20)->native_object;
                    object_pointer0_1 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_1 )
                    {
                        zend_error(E_ERROR, "Parameter 'bitmap2' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(bitmap20) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'bitmap2' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxBitmapBundle::FromBitmaps(*(wxBitmap*) object_pointer0_0, *(wxBitmap*) object_pointer0_1) to return new object\n\n");
                #endif

                wxBitmapBundle value_to_return2;
                value_to_return2 = wxBitmapBundle::FromBitmaps(*(wxBitmap*) object_pointer0_0, *(wxBitmap*) object_pointer0_1);
                void* ptr = safe_emalloc(1, sizeof(wxBitmapBundle_php), 0);
                memcpy(ptr, (void*) &value_to_return2, sizeof(wxBitmapBundle));
                object_init_ex(return_value, php_wxBitmapBundle_entry);
                ((wxBitmapBundle_php*)ptr)->phpObj = *return_value;
                zo_wxBitmapBundle* zo2 = Z_wxBitmapBundle_P(return_value);
                zo2->native_object = (wxBitmapBundle_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapBundle::FromBitmaps\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmapBundle wxBitmapBundle::FromBitmap(wxBitmap bitmap)
   Create a bundle from a single bitmap. */
PHP_METHOD(php_wxBitmapBundle, FromBitmap)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapBundle::FromBitmap\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundle* current_object;
    wxphp_object_type current_object_type;
    wxBitmapBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapBundle::FromBitmap call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPBUNDLE_TYPE){
                references = &((wxBitmapBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* bitmap0;
    wxBitmap* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&bitmap0, php_wxBitmap_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap0)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap0)->native_object;
                    object_pointer0_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(bitmap0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxBitmapBundle::FromBitmap(*(wxBitmap*) object_pointer0_0) to return new object\n\n");
                #endif

                wxBitmapBundle value_to_return1;
                value_to_return1 = wxBitmapBundle::FromBitmap(*(wxBitmap*) object_pointer0_0);
                void* ptr = safe_emalloc(1, sizeof(wxBitmapBundle_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxBitmapBundle));
                object_init_ex(return_value, php_wxBitmapBundle_entry);
                ((wxBitmapBundle_php*)ptr)->phpObj = *return_value;
                zo_wxBitmapBundle* zo1 = Z_wxBitmapBundle_P(return_value);
                zo1->native_object = (wxBitmapBundle_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapBundle::FromBitmap\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmapBundle wxBitmapBundle::FromImage(wxImage image)
   Create a bundle from a single image. */
PHP_METHOD(php_wxBitmapBundle, FromImage)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapBundle::FromImage\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundle* current_object;
    wxphp_object_type current_object_type;
    wxBitmapBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapBundle::FromImage call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPBUNDLE_TYPE){
                references = &((wxBitmapBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* image0;
    wxImage* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&image0, php_wxImage_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &image0, php_wxImage_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(image0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxImage_P(image0)->object_type;
                    argument_native_object = (void*) Z_wxImage_P(image0)->native_object;
                    object_pointer0_0 = (wxImage*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'image' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(image0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'image' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxBitmapBundle::FromImage(*(wxImage*) object_pointer0_0) to return new object\n\n");
                #endif

                wxBitmapBundle value_to_return1;
                value_to_return1 = wxBitmapBundle::FromImage(*(wxImage*) object_pointer0_0);
                void* ptr = safe_emalloc(1, sizeof(wxBitmapBundle_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxBitmapBundle));
                object_init_ex(return_value, php_wxBitmapBundle_entry);
                ((wxBitmapBundle_php*)ptr)->phpObj = *return_value;
                zo_wxBitmapBundle* zo1 = Z_wxBitmapBundle_P(return_value);
                zo1->native_object = (wxBitmapBundle_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapBundle::FromImage\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmapBundle wxBitmapBundle::FromImpl(wxBitmapBundleImpl &impl)
   Create a bundle from a custom bitmap bundle implementation. */
PHP_METHOD(php_wxBitmapBundle, FromImpl)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapBundle::FromImpl\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundle* current_object;
    wxphp_object_type current_object_type;
    wxBitmapBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapBundle::FromImpl call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPBUNDLE_TYPE){
                references = &((wxBitmapBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* impl0;
    wxBitmapBundleImpl* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&impl0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &impl0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(impl0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmapBundleImpl_P(impl0)->object_type;
                    argument_native_object = (void*) Z_wxBitmapBundleImpl_P(impl0)->native_object;
                    object_pointer0_0 = (wxBitmapBundleImpl*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXBITMAPBUNDLEIMPL_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'impl' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(impl0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'impl' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxBitmapBundle::FromImpl((wxBitmapBundleImpl*) object_pointer0_0) to return new object\n\n");
                #endif

                wxBitmapBundle value_to_return1;
                value_to_return1 = wxBitmapBundle::FromImpl((wxBitmapBundleImpl*) object_pointer0_0);
                void* ptr = safe_emalloc(1, sizeof(wxBitmapBundle_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxBitmapBundle));
                object_init_ex(return_value, php_wxBitmapBundle_entry);
                ((wxBitmapBundle_php*)ptr)->phpObj = *return_value;
                zo_wxBitmapBundle* zo1 = Z_wxBitmapBundle_P(return_value);
                zo1->native_object = (wxBitmapBundle_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapBundle::FromImpl\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmapBundle wxBitmapBundle::FromResources(string name)
   Create a bundle from the bitmaps in the application resources. */
PHP_METHOD(php_wxBitmapBundle, FromResources)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapBundle::FromResources\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundle* current_object;
    wxphp_object_type current_object_type;
    wxBitmapBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapBundle::FromResources call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPBUNDLE_TYPE){
                references = &((wxBitmapBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxBitmapBundle::FromResources(wxString(name0, wxConvUTF8)) to return new object\n\n");
                #endif

                wxBitmapBundle value_to_return1;
                value_to_return1 = wxBitmapBundle::FromResources(wxString(name0, wxConvUTF8));
                void* ptr = safe_emalloc(1, sizeof(wxBitmapBundle_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxBitmapBundle));
                object_init_ex(return_value, php_wxBitmapBundle_entry);
                ((wxBitmapBundle_php*)ptr)->phpObj = *return_value;
                zo_wxBitmapBundle* zo1 = Z_wxBitmapBundle_P(return_value);
                zo1->native_object = (wxBitmapBundle_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapBundle::FromResources\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmapBundle wxBitmapBundle::FromFiles(string path, string filename, string extension)
   Create a bundle from bitmaps stored as files. */
PHP_METHOD(php_wxBitmapBundle, FromFiles)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapBundle::FromFiles\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundle* current_object;
    wxphp_object_type current_object_type;
    wxBitmapBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapBundle::FromFiles call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPBUNDLE_TYPE){
                references = &((wxBitmapBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* path0;
    size_t path_len0;
    char* filename0;
    size_t filename_len0;
    char* extension0;
    size_t extension_len0;
    bool overload0_called = false;

    //Parameters for overload 1
    char* fullpathname1;
    size_t fullpathname_len1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ss|s' (&path0, &path_len0, &filename0, &filename_len0, &extension0, &extension_len0)\n");
        #endif

        char parse_parameters_string[] = "ss|s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &path0, &path_len0, &filename0, &filename_len0, &extension0, &extension_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&fullpathname1, &fullpathname_len1)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &fullpathname1, &fullpathname_len1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxBitmapBundle::FromFiles(wxString(path0, wxConvUTF8), wxString(filename0, wxConvUTF8)) to return new object\n\n");
                #endif

                wxBitmapBundle value_to_return2;
                value_to_return2 = wxBitmapBundle::FromFiles(wxString(path0, wxConvUTF8), wxString(filename0, wxConvUTF8));
                void* ptr = safe_emalloc(1, sizeof(wxBitmapBundle_php), 0);
                memcpy(ptr, (void*) &value_to_return2, sizeof(wxBitmapBundle));
                object_init_ex(return_value, php_wxBitmapBundle_entry);
                ((wxBitmapBundle_php*)ptr)->phpObj = *return_value;
                zo_wxBitmapBundle* zo2 = Z_wxBitmapBundle_P(return_value);
                zo2->native_object = (wxBitmapBundle_php*) ptr;


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxBitmapBundle::FromFiles(wxString(path0, wxConvUTF8), wxString(filename0, wxConvUTF8), wxString(extension0, wxConvUTF8)) to return new object\n\n");
                #endif

                wxBitmapBundle value_to_return3;
                value_to_return3 = wxBitmapBundle::FromFiles(wxString(path0, wxConvUTF8), wxString(filename0, wxConvUTF8), wxString(extension0, wxConvUTF8));
                void* ptr = safe_emalloc(1, sizeof(wxBitmapBundle_php), 0);
                memcpy(ptr, (void*) &value_to_return3, sizeof(wxBitmapBundle));
                object_init_ex(return_value, php_wxBitmapBundle_entry);
                ((wxBitmapBundle_php*)ptr)->phpObj = *return_value;
                zo_wxBitmapBundle* zo3 = Z_wxBitmapBundle_P(return_value);
                zo3->native_object = (wxBitmapBundle_php*) ptr;


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxBitmapBundle::FromFiles(wxString(fullpathname1, wxConvUTF8)) to return new object\n\n");
                #endif

                wxBitmapBundle value_to_return1;
                value_to_return1 = wxBitmapBundle::FromFiles(wxString(fullpathname1, wxConvUTF8));
                void* ptr = safe_emalloc(1, sizeof(wxBitmapBundle_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxBitmapBundle));
                object_init_ex(return_value, php_wxBitmapBundle_entry);
                ((wxBitmapBundle_php*)ptr)->phpObj = *return_value;
                zo_wxBitmapBundle* zo1 = Z_wxBitmapBundle_P(return_value);
                zo1->native_object = (wxBitmapBundle_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapBundle::FromFiles\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmapBundle wxBitmapBundle::FromSVG(string &data, wxSize sizeDef)
   Create a bundle from the SVG image. */
PHP_METHOD(php_wxBitmapBundle, FromSVG)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapBundle::FromSVG\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundle* current_object;
    wxphp_object_type current_object_type;
    wxBitmapBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapBundle::FromSVG call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPBUNDLE_TYPE){
                references = &((wxBitmapBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* data0;
    size_t data_len0;
    zval data0_ref;
    zval* sizeDef0;
    wxSize* object_pointer0_1 = 0;
    bool overload0_called = false;

    //Parameters for overload 1
    char* data1;
    size_t data_len1;
    zval* sizeDef1;
    wxSize* object_pointer1_1 = 0;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sO' (&data0, &data_len0, &sizeDef0, php_wxSize_entry)\n");
        #endif

        char parse_parameters_string[] = "sO";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &data0, &data_len0, &sizeDef0, php_wxSize_entry ) == SUCCESS)
        {
            if(arguments_received >= 2){
                if(Z_TYPE_P(sizeDef0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(sizeDef0)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(sizeDef0)->native_object;
                    object_pointer0_1 = (wxSize*) argument_native_object;
                    if (!object_pointer0_1 )
                    {
                        goto overload1;
                    }
                }
                else if(Z_TYPE_P(sizeDef0) != IS_NULL)
                {
                    goto overload1;
                }
            }

            overload0_called = true;
            already_called = true;

            char parse_references_string[] = "zz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, data0_ref, &dummy );
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sO' (&data1, &data_len1, &sizeDef1, php_wxSize_entry)\n");
        #endif

        char parse_parameters_string[] = "sO";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &data1, &data_len1, &sizeDef1, php_wxSize_entry ) == SUCCESS)
        {
            if(arguments_received >= 2){
                if(Z_TYPE_P(sizeDef1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(sizeDef1)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(sizeDef1)->native_object;
                    object_pointer1_1 = (wxSize*) argument_native_object;
                    if (!object_pointer1_1 )
                    {
                        zend_error(E_ERROR, "Parameter 'sizeDef' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(sizeDef1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'sizeDef' not null, could not be retreived correctly.");
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxBitmapBundle::FromSVG(data0, *(wxSize*) object_pointer0_1) to return new object\n\n");
                #endif

                wxBitmapBundle value_to_return2;
                value_to_return2 = wxBitmapBundle::FromSVG(data0, *(wxSize*) object_pointer0_1);
                void* ptr = safe_emalloc(1, sizeof(wxBitmapBundle_php), 0);
                memcpy(ptr, (void*) &value_to_return2, sizeof(wxBitmapBundle));
                object_init_ex(return_value, php_wxBitmapBundle_entry);
                ((wxBitmapBundle_php*)ptr)->phpObj = *return_value;
                zo_wxBitmapBundle* zo2 = Z_wxBitmapBundle_P(return_value);
                zo2->native_object = (wxBitmapBundle_php*) ptr;

                ZVAL_STRING(&data0_ref, data0);

                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxBitmapBundle::FromSVG(data1, *(wxSize*) object_pointer1_1) to return new object\n\n");
                #endif

                wxBitmapBundle value_to_return2;
                value_to_return2 = wxBitmapBundle::FromSVG(data1, *(wxSize*) object_pointer1_1);
                void* ptr = safe_emalloc(1, sizeof(wxBitmapBundle_php), 0);
                memcpy(ptr, (void*) &value_to_return2, sizeof(wxBitmapBundle));
                object_init_ex(return_value, php_wxBitmapBundle_entry);
                ((wxBitmapBundle_php*)ptr)->phpObj = *return_value;
                zo_wxBitmapBundle* zo2 = Z_wxBitmapBundle_P(return_value);
                zo2->native_object = (wxBitmapBundle_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapBundle::FromSVG\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmapBundle wxBitmapBundle::FromSVGFile(string path, wxSize sizeDef)
   Create a bundle from the SVG image loaded from the given file. */
PHP_METHOD(php_wxBitmapBundle, FromSVGFile)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapBundle::FromSVGFile\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundle* current_object;
    wxphp_object_type current_object_type;
    wxBitmapBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapBundle::FromSVGFile call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPBUNDLE_TYPE){
                references = &((wxBitmapBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* path0;
    size_t path_len0;
    zval* sizeDef0;
    wxSize* object_pointer0_1 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sO' (&path0, &path_len0, &sizeDef0, php_wxSize_entry)\n");
        #endif

        char parse_parameters_string[] = "sO";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &path0, &path_len0, &sizeDef0, php_wxSize_entry ) == SUCCESS)
        {
            if(arguments_received >= 2){
                if(Z_TYPE_P(sizeDef0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(sizeDef0)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(sizeDef0)->native_object;
                    object_pointer0_1 = (wxSize*) argument_native_object;
                    if (!object_pointer0_1 )
                    {
                        zend_error(E_ERROR, "Parameter 'sizeDef' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(sizeDef0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'sizeDef' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxBitmapBundle::FromSVGFile(wxString(path0, wxConvUTF8), *(wxSize*) object_pointer0_1) to return new object\n\n");
                #endif

                wxBitmapBundle value_to_return2;
                value_to_return2 = wxBitmapBundle::FromSVGFile(wxString(path0, wxConvUTF8), *(wxSize*) object_pointer0_1);
                void* ptr = safe_emalloc(1, sizeof(wxBitmapBundle_php), 0);
                memcpy(ptr, (void*) &value_to_return2, sizeof(wxBitmapBundle));
                object_init_ex(return_value, php_wxBitmapBundle_entry);
                ((wxBitmapBundle_php*)ptr)->phpObj = *return_value;
                zo_wxBitmapBundle* zo2 = Z_wxBitmapBundle_P(return_value);
                zo2->native_object = (wxBitmapBundle_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapBundle::FromSVGFile\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmapBundle wxBitmapBundle::FromSVGResource(string name, wxSize sizeDef)
   Create a bundle from the SVG image loaded from an application resource. */
PHP_METHOD(php_wxBitmapBundle, FromSVGResource)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapBundle::FromSVGResource\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundle* current_object;
    wxphp_object_type current_object_type;
    wxBitmapBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapBundle::FromSVGResource call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPBUNDLE_TYPE){
                references = &((wxBitmapBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    zval* sizeDef0;
    wxSize* object_pointer0_1 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sO' (&name0, &name_len0, &sizeDef0, php_wxSize_entry)\n");
        #endif

        char parse_parameters_string[] = "sO";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0, &sizeDef0, php_wxSize_entry ) == SUCCESS)
        {
            if(arguments_received >= 2){
                if(Z_TYPE_P(sizeDef0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(sizeDef0)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(sizeDef0)->native_object;
                    object_pointer0_1 = (wxSize*) argument_native_object;
                    if (!object_pointer0_1 )
                    {
                        zend_error(E_ERROR, "Parameter 'sizeDef' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(sizeDef0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'sizeDef' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxBitmapBundle::FromSVGResource(wxString(name0, wxConvUTF8), *(wxSize*) object_pointer0_1) to return new object\n\n");
                #endif

                wxBitmapBundle value_to_return2;
                value_to_return2 = wxBitmapBundle::FromSVGResource(wxString(name0, wxConvUTF8), *(wxSize*) object_pointer0_1);
                void* ptr = safe_emalloc(1, sizeof(wxBitmapBundle_php), 0);
                memcpy(ptr, (void*) &value_to_return2, sizeof(wxBitmapBundle));
                object_init_ex(return_value, php_wxBitmapBundle_entry);
                ((wxBitmapBundle_php*)ptr)->phpObj = *return_value;
                zo_wxBitmapBundle* zo2 = Z_wxBitmapBundle_P(return_value);
                zo2->native_object = (wxBitmapBundle_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapBundle::FromSVGResource\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxBitmapBundleImpl_free(void *object)
{
    zo_wxBitmapBundleImpl* custom_object = (zo_wxBitmapBundleImpl*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxBitmapBundleImpl_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxBitmapBundleImpl done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxBitmapBundleImpl_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxBitmapBundleImpl_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapBundleImpl* custom_object;

    custom_object = (zo_wxBitmapBundleImpl*) ecalloc(
        1,
        sizeof(zo_wxBitmapBundleImpl)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxBitmapBundleImpl_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXBITMAPBUNDLEIMPL_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto wxSize wxBitmapBundleImpl::GetDefaultSize()
   Return the size of the bitmaps represented by this bundle in the default DPI. */
wxSize wxBitmapBundleImpl_php::GetDefaultSize()const
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxBitmapBundleImpl::GetDefaultSize\n");
    php_printf("===========================================\n");
    #endif

    zval* params[1];
    zval arguments[1];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "GetDefaultSize");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "GetDefaultSize");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "GetDefaultSize",
            14,
            &function_return_value,
            0,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxBitmapBundleImpl::GetDefaultSize'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    if(Z_TYPE(function_return_value) == IS_OBJECT)
    {
        return_object = (void*) Z_wxSize_P(&function_return_value)->native_object;
    }

    //Threat it as a normal object on the calling function and not a php user space intiialized one
    Z_wxSize_P(&function_return_value)->is_user_initialized = 0;
    wxSize_php* var = (wxSize_php*) return_object;
    var->references.UnInitialize();

    return *(wxSize*) return_object;

}
/* }}} */

/* {{{ proto wxSize wxBitmapBundleImpl::GetPreferredBitmapSizeAtScale(float scale)
   Return the preferred size that should be used at the given scale. */
wxSize wxBitmapBundleImpl_php::GetPreferredBitmapSizeAtScale(double scale)const
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxBitmapBundleImpl::GetPreferredBitmapSizeAtScale\n");
    php_printf("===========================================\n");
    #endif

    zval* params[1];
    zval arguments[1];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "GetPreferredBitmapSizeAtScale");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    ZVAL_DOUBLE(&arguments[0], scale);
    
    for(int i=0; i<1; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "GetPreferredBitmapSizeAtScale");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "GetPreferredBitmapSizeAtScale",
            29,
            &function_return_value,
            1,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<1; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxBitmapBundleImpl::GetPreferredBitmapSizeAtScale'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    if(Z_TYPE(function_return_value) == IS_OBJECT)
    {
        return_object = (void*) Z_wxSize_P(&function_return_value)->native_object;
    }

    //Threat it as a normal object on the calling function and not a php user space intiialized one
    Z_wxSize_P(&function_return_value)->is_user_initialized = 0;
    wxSize_php* var = (wxSize_php*) return_object;
    var->references.UnInitialize();

    return *(wxSize*) return_object;

}
/* }}} */

/* {{{ proto wxBitmap wxBitmapBundleImpl::GetBitmap(wxSize size)
   Retrieve the bitmap of exactly the given size. */
wxBitmap wxBitmapBundleImpl_php::GetBitmap(const wxSize& size)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxBitmapBundleImpl::GetBitmap\n");
    php_printf("===========================================\n");
    #endif

    zval* params[1];
    zval arguments[1];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "GetBitmap");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    object_init_ex(&arguments[0], php_wxSize_entry);
    Z_wxSize_P(&arguments[0])->native_object = (wxSize_php*) &size;
    
    for(int i=0; i<1; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "GetBitmap");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "GetBitmap",
            9,
            &function_return_value,
            1,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<1; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxBitmapBundleImpl::GetBitmap'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    if(Z_TYPE(function_return_value) == IS_OBJECT)
    {
        return_object = (void*) Z_wxBitmap_P(&function_return_value)->native_object;
    }

    //Threat it as a normal object on the calling function and not a php user space intiialized one
    Z_wxBitmap_P(&function_return_value)->is_user_initialized = 0;
    wxBitmap_php* var = (wxBitmap_php*) return_object;
    var->references.UnInitialize();

    return *(wxBitmap*) return_object;

}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGraphicsGradientStop_free(void *object)
{
    zo_wxGraphicsGradientStop* custom_object = (zo_wxGraphicsGradientStop*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGraphicsGradientStop_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxGraphicsGradientStop done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxGraphicsGradientStop_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGraphicsGradientStop_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxGraphicsGradientStop* custom_object;

    custom_object = (zo_wxGraphicsGradientStop*) ecalloc(
        1,
        sizeof(zo_wxGraphicsGradientStop)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxGraphicsGradientStop_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRAPHICSGRADIENTSTOP_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto wxColour wxGraphicsGradientStop::GetColour()
   Return the stop colour. */
PHP_METHOD(php_wxGraphicsGradientStop, GetColour)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGraphicsGradientStop::GetColour\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGraphicsGradientStop* current_object;
    wxphp_object_type current_object_type;
    wxGraphicsGradientStop_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGraphicsGradientStop_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGraphicsGradientStop::GetColour call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOP_TYPE){
                references = &((wxGraphicsGradientStop_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGraphicsGradientStop::GetColour() to return object reference\n\n");
                #endif

                wxColour_php* value_to_return0;
                value_to_return0 = (wxColour_php*) &((wxGraphicsGradientStop_php*)native_object)->GetColour();

                if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxColour_entry);
                    Z_wxColour_P(return_value)->native_object = (wxColour_php*) value_to_return0;
                }

                if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxGraphicsGradientStop::GetColour at call 6 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGraphicsGradientStop::GetColour\n"
        );
    }
}
/* }}} */

/* {{{ proto float wxGraphicsGradientStop::GetPosition()
   Return the stop position. */
PHP_METHOD(php_wxGraphicsGradientStop, GetPosition)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGraphicsGradientStop::GetPosition\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGraphicsGradientStop* current_object;
    wxphp_object_type current_object_type;
    wxGraphicsGradientStop_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGraphicsGradientStop_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGraphicsGradientStop::GetPosition call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOP_TYPE){
                references = &((wxGraphicsGradientStop_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxGraphicsGradientStop::GetPosition())\n\n");
                #endif

                RETVAL_DOUBLE(((wxGraphicsGradientStop_php*)native_object)->GetPosition());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGraphicsGradientStop::GetPosition\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxGraphicsGradientStop::SetColour(wxColour col)
   Change the stop colour. */
PHP_METHOD(php_wxGraphicsGradientStop, SetColour)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGraphicsGradientStop::SetColour\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGraphicsGradientStop* current_object;
    wxphp_object_type current_object_type;
    wxGraphicsGradientStop_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGraphicsGradientStop_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGraphicsGradientStop::SetColour call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOP_TYPE){
                references = &((wxGraphicsGradientStop_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* col0;
    wxColour* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&col0, php_wxColour_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &col0, php_wxColour_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(col0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxColour_P(col0)->object_type;
                    argument_native_object = (void*) Z_wxColour_P(col0)->native_object;
                    object_pointer0_0 = (wxColour*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'col' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(col0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'col' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGraphicsGradientStop::SetColour(*(wxColour*) object_pointer0_0)\n\n");
                #endif

                ((wxGraphicsGradientStop_php*)native_object)->SetColour(*(wxColour*) object_pointer0_0);

                references->AddReference(col0, "wxGraphicsGradientStop::SetColour at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGraphicsGradientStop::SetColour\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxGraphicsGradientStop::SetPosition(float pos)
   Change the stop position. */
PHP_METHOD(php_wxGraphicsGradientStop, SetPosition)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGraphicsGradientStop::SetPosition\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGraphicsGradientStop* current_object;
    wxphp_object_type current_object_type;
    wxGraphicsGradientStop_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGraphicsGradientStop_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGraphicsGradientStop::SetPosition call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOP_TYPE){
                references = &((wxGraphicsGradientStop_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    double pos0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'd' (&pos0)\n");
        #endif

        char parse_parameters_string[] = "d";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pos0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGraphicsGradientStop::SetPosition(pos0)\n\n");
                #endif

                ((wxGraphicsGradientStop_php*)native_object)->SetPosition(pos0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGraphicsGradientStop::SetPosition\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxGraphicsGradientStop::wxGraphicsGradientStop(wxColour col, float pos)
   Creates a stop with the given colour and position. */
PHP_METHOD(php_wxGraphicsGradientStop, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGraphicsGradientStop::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGraphicsGradientStop* current_object;
    wxGraphicsGradientStop_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    zval* col0;
    wxColour* object_pointer0_0 = 0;
    double pos0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|Od' (&col0, php_wxColour_entry, &pos0)\n");
        #endif

        char parse_parameters_string[] = "|Od";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &col0, php_wxColour_entry, &pos0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(col0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxColour_P(col0)->object_type;
                    argument_native_object = (void*) Z_wxColour_P(col0)->native_object;
                    object_pointer0_0 = (wxColour*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'col' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(col0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'col' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxGraphicsGradientStop_php();

                native_object->references.Initialize();
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxColour*) object_pointer0_0)\n");
                #endif

                native_object = new wxGraphicsGradientStop_php(*(wxColour*) object_pointer0_0);

                native_object->references.Initialize();
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxColour*) object_pointer0_0, pos0)\n");
                #endif

                native_object = new wxGraphicsGradientStop_php(*(wxColour*) object_pointer0_0, pos0);

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxGraphicsGradientStop_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxGraphicsGradientStop::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGraphicsGradientStops_free(void *object)
{
    zo_wxGraphicsGradientStops* custom_object = (zo_wxGraphicsGradientStops*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGraphicsGradientStops_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxGraphicsGradientStops done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxGraphicsGradientStops_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGraphicsGradientStops_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxGraphicsGradientStops* custom_object;

    custom_object = (zo_wxGraphicsGradientStops*) ecalloc(
        1,
        sizeof(zo_wxGraphicsGradientStops)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxGraphicsGradientStops_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRAPHICSGRADIENTSTOPS_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxGraphicsGradientStops::Add(wxGraphicsGradientStop stop)
   Add a new stop. */
PHP_METHOD(php_wxGraphicsGradientStops, Add)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGraphicsGradientStops::Add\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGraphicsGradientStops* current_object;
    wxphp_object_type current_object_type;
    wxGraphicsGradientStops_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGraphicsGradientStops_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGraphicsGradientStops::Add call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOPS_TYPE){
                references = &((wxGraphicsGradientStops_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* stop0;
    wxGraphicsGradientStop* object_pointer0_0 = 0;
    bool overload0_called = false;

    //Parameters for overload 1
    zval* col1;
    wxColour* object_pointer1_0 = 0;
    double pos1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&stop0, php_wxGraphicsGradientStop_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &stop0, php_wxGraphicsGradientStop_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(stop0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxGraphicsGradientStop_P(stop0)->object_type;
                    argument_native_object = (void*) Z_wxGraphicsGradientStop_P(stop0)->native_object;
                    object_pointer0_0 = (wxGraphicsGradientStop*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        goto overload1;
                    }
                }
                else if(Z_TYPE_P(stop0) != IS_NULL)
                {
                    goto overload1;
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'Od' (&col1, php_wxColour_entry, &pos1)\n");
        #endif

        char parse_parameters_string[] = "Od";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &col1, php_wxColour_entry, &pos1 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(col1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxColour_P(col1)->object_type;
                    argument_native_object = (void*) Z_wxColour_P(col1)->native_object;
                    object_pointer1_0 = (wxColour*) argument_native_object;
                    if (!object_pointer1_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'col' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(col1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'col' not null, could not be retreived correctly.");
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGraphicsGradientStops::Add(*(wxGraphicsGradientStop*) object_pointer0_0)\n\n");
                #endif

                ((wxGraphicsGradientStops_php*)native_object)->Add(*(wxGraphicsGradientStop*) object_pointer0_0);

                references->AddReference(stop0, "wxGraphicsGradientStops::Add at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGraphicsGradientStops::Add(*(wxColour*) object_pointer1_0, pos1)\n\n");
                #endif

                ((wxGraphicsGradientStops_php*)native_object)->Add(*(wxColour*) object_pointer1_0, pos1);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGraphicsGradientStops::Add\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxGraphicsGradientStops::GetCount()
   Returns the number of stops. */
PHP_METHOD(php_wxGraphicsGradientStops, GetCount)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGraphicsGradientStops::GetCount\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGraphicsGradientStops* current_object;
    wxphp_object_type current_object_type;
    wxGraphicsGradientStops_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGraphicsGradientStops_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGraphicsGradientStops::GetCount call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOPS_TYPE){
                references = &((wxGraphicsGradientStops_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxGraphicsGradientStops::GetCount())\n\n");
                #endif

                RETVAL_LONG(((wxGraphicsGradientStops_php*)native_object)->GetCount());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGraphicsGradientStops::GetCount\n"
        );
    }
}
/* }}} */

/* {{{ proto wxColour wxGraphicsGradientStops::GetEndColour()
   Returns the end colour. */
PHP_METHOD(php_wxGraphicsGradientStops, GetEndColour)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGraphicsGradientStops::GetEndColour\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGraphicsGradientStops* current_object;
    wxphp_object_type current_object_type;
    wxGraphicsGradientStops_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGraphicsGradientStops_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGraphicsGradientStops::GetEndColour call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOPS_TYPE){
                references = &((wxGraphicsGradientStops_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGraphicsGradientStops::GetEndColour() to return new object\n\n");
                #endif

                wxColour value_to_return0;
                value_to_return0 = ((wxGraphicsGradientStops_php*)native_object)->GetEndColour();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxColour));
                object_init_ex(return_value, php_wxColour_entry);
                ((wxColour_php*)ptr)->phpObj = *return_value;
                zo_wxColour* zo0 = Z_wxColour_P(return_value);
                zo0->native_object = (wxColour_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGraphicsGradientStops::GetEndColour\n"
        );
    }
}
/* }}} */

/* {{{ proto wxColour wxGraphicsGradientStops::GetStartColour()
   Returns the start colour. */
PHP_METHOD(php_wxGraphicsGradientStops, GetStartColour)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGraphicsGradientStops::GetStartColour\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGraphicsGradientStops* current_object;
    wxphp_object_type current_object_type;
    wxGraphicsGradientStops_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGraphicsGradientStops_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGraphicsGradientStops::GetStartColour call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOPS_TYPE){
                references = &((wxGraphicsGradientStops_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGraphicsGradientStops::GetStartColour() to return new object\n\n");
                #endif

                wxColour value_to_return0;
                value_to_return0 = ((wxGraphicsGradientStops_php*)native_object)->GetStartColour();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxColour));
                object_init_ex(return_value, php_wxColour_entry);
                ((wxColour_php*)ptr)->phpObj = *return_value;
                zo_wxColour* zo0 = Z_wxColour_P(return_value);
                zo0->native_object = (wxColour_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGraphicsGradientStops::GetStartColour\n"
        );
    }
}
/* }}} */

/* {{{ proto wxGraphicsGradientStop wxGraphicsGradientStops::Item(int n)
   Returns the stop at the given index. */
PHP_METHOD(php_wxGraphicsGradientStops, Item)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGraphicsGradientStops::Item\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGraphicsGradientStops* current_object;
    wxphp_object_type current_object_type;
    wxGraphicsGradientStops_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGraphicsGradientStops_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGraphicsGradientStops::Item call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOPS_TYPE){
                references = &((wxGraphicsGradientStops_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long n0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&n0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &n0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGraphicsGradientStops::Item((unsigned) n0) to return new object\n\n");
                #endif

                wxGraphicsGradientStop value_to_return1;
                value_to_return1 = ((wxGraphicsGradientStops_php*)native_object)->Item((unsigned) n0);
                void* ptr = safe_emalloc(1, sizeof(wxGraphicsGradientStop_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxGraphicsGradientStop));
                object_init_ex(return_value, php_wxGraphicsGradientStop_entry);
                ((wxGraphicsGradientStop_php*)ptr)->phpObj = *return_value;
                zo_wxGraphicsGradientStop* zo1 = Z_wxGraphicsGradientStop_P(return_value);
                zo1->native_object = (wxGraphicsGradientStop_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGraphicsGradientStops::Item\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxGraphicsGradientStops::SetEndColour(wxColour col)
   Set the end colour to col. */
PHP_METHOD(php_wxGraphicsGradientStops, SetEndColour)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGraphicsGradientStops::SetEndColour\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGraphicsGradientStops* current_object;
    wxphp_object_type current_object_type;
    wxGraphicsGradientStops_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGraphicsGradientStops_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGraphicsGradientStops::SetEndColour call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOPS_TYPE){
                references = &((wxGraphicsGradientStops_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* col0;
    wxColour* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&col0, php_wxColour_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &col0, php_wxColour_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(col0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxColour_P(col0)->object_type;
                    argument_native_object = (void*) Z_wxColour_P(col0)->native_object;
                    object_pointer0_0 = (wxColour*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'col' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(col0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'col' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGraphicsGradientStops::SetEndColour(*(wxColour*) object_pointer0_0)\n\n");
                #endif

                ((wxGraphicsGradientStops_php*)native_object)->SetEndColour(*(wxColour*) object_pointer0_0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGraphicsGradientStops::SetEndColour\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxGraphicsGradientStops::SetStartColour(wxColour col)
   Set the start colour to col. */
PHP_METHOD(php_wxGraphicsGradientStops, SetStartColour)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGraphicsGradientStops::SetStartColour\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGraphicsGradientStops* current_object;
    wxphp_object_type current_object_type;
    wxGraphicsGradientStops_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGraphicsGradientStops_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGraphicsGradientStops::SetStartColour call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOPS_TYPE){
                references = &((wxGraphicsGradientStops_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* col0;
    wxColour* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&col0, php_wxColour_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &col0, php_wxColour_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(col0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxColour_P(col0)->object_type;
                    argument_native_object = (void*) Z_wxColour_P(col0)->native_object;
                    object_pointer0_0 = (wxColour*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'col' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(col0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'col' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGraphicsGradientStops::SetStartColour(*(wxColour*) object_pointer0_0)\n\n");
                #endif

                ((wxGraphicsGradientStops_php*)native_object)->SetStartColour(*(wxColour*) object_pointer0_0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGraphicsGradientStops::SetStartColour\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxGraphicsGradientStops::wxGraphicsGradientStops(wxColour startCol, wxColour endCol)
   Initializes the gradient stops with the given boundary colours. */
PHP_METHOD(php_wxGraphicsGradientStops, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGraphicsGradientStops::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGraphicsGradientStops* current_object;
    wxGraphicsGradientStops_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    zval* startCol0;
    wxColour* object_pointer0_0 = 0;
    zval* endCol0;
    wxColour* object_pointer0_1 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|OO' (&startCol0, php_wxColour_entry, &endCol0, php_wxColour_entry)\n");
        #endif

        char parse_parameters_string[] = "|OO";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &startCol0, php_wxColour_entry, &endCol0, php_wxColour_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(startCol0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxColour_P(startCol0)->object_type;
                    argument_native_object = (void*) Z_wxColour_P(startCol0)->native_object;
                    object_pointer0_0 = (wxColour*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'startCol' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(startCol0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'startCol' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 2){
                if(Z_TYPE_P(endCol0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxColour_P(endCol0)->object_type;
                    argument_native_object = (void*) Z_wxColour_P(endCol0)->native_object;
                    object_pointer0_1 = (wxColour*) argument_native_object;
                    if (!object_pointer0_1 )
                    {
                        zend_error(E_ERROR, "Parameter 'endCol' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(endCol0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'endCol' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxGraphicsGradientStops_php();

                native_object->references.Initialize();
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxColour*) object_pointer0_0)\n");
                #endif

                native_object = new wxGraphicsGradientStops_php(*(wxColour*) object_pointer0_0);

                native_object->references.Initialize();
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxColour*) object_pointer0_0, *(wxColour*) object_pointer0_1)\n");
                #endif

                native_object = new wxGraphicsGradientStops_php(*(wxColour*) object_pointer0_0, *(wxColour*) object_pointer0_1);

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxGraphicsGradientStops_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxGraphicsGradientStops::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxBitmapHandler_free(void *object)
{
    zo_wxBitmapHandler* custom_object = (zo_wxBitmapHandler*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxBitmapHandler_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxBitmapHandler done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxBitmapHandler_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxBitmapHandler_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapHandler* custom_object;

    custom_object = (zo_wxBitmapHandler*) ecalloc(
        1,
        sizeof(zo_wxBitmapHandler)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxBitmapHandler_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXBITMAPHANDLER_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxBitmapHandler::wxBitmapHandler()
   Default constructor. */
PHP_METHOD(php_wxBitmapHandler, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapHandler::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapHandler* current_object;
    wxBitmapHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxBitmapHandler_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxBitmapHandler_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxBitmapHandler::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto  wxBitmapHandler::SetType(wxBitmapType type)
   Sets the handler type. */
PHP_METHOD(php_wxBitmapHandler, SetType)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapHandler::SetType\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapHandler* current_object;
    wxphp_object_type current_object_type;
    wxBitmapHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapHandler::SetType call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPHANDLER_TYPE){
                references = &((wxBitmapHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long type0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&type0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &type0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBitmapHandler::SetType((wxBitmapType) type0)\n\n");
                #endif

                ((wxBitmapHandler_php*)native_object)->SetType((wxBitmapType) type0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapHandler::SetType\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxBitmapHandler::SetName(string name)
   Sets the handler name. */
PHP_METHOD(php_wxBitmapHandler, SetName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapHandler::SetName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapHandler* current_object;
    wxphp_object_type current_object_type;
    wxBitmapHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapHandler::SetName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPHANDLER_TYPE){
                references = &((wxBitmapHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBitmapHandler::SetName(wxString(name0, wxConvUTF8))\n\n");
                #endif

                ((wxBitmapHandler_php*)native_object)->SetName(wxString(name0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapHandler::SetName\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxBitmapHandler::SetExtension(string extension)
   Sets the handler extension. */
PHP_METHOD(php_wxBitmapHandler, SetExtension)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapHandler::SetExtension\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapHandler* current_object;
    wxphp_object_type current_object_type;
    wxBitmapHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapHandler::SetExtension call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPHANDLER_TYPE){
                references = &((wxBitmapHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* extension0;
    size_t extension_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&extension0, &extension_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &extension0, &extension_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBitmapHandler::SetExtension(wxString(extension0, wxConvUTF8))\n\n");
                #endif

                ((wxBitmapHandler_php*)native_object)->SetExtension(wxString(extension0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapHandler::SetExtension\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxBitmapHandler::LoadFile(wxBitmap &bitmap, string name, wxBitmapType type, int desiredWidth, int desiredHeight)
   Loads a bitmap from a file or resource, putting the resulting data into bitmap. */
PHP_METHOD(php_wxBitmapHandler, LoadFile)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapHandler::LoadFile\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapHandler* current_object;
    wxphp_object_type current_object_type;
    wxBitmapHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapHandler::LoadFile call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPHANDLER_TYPE){
                references = &((wxBitmapHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* bitmap0;
    wxBitmap* object_pointer0_0 = 0;
    char* name0;
    size_t name_len0;
    long type0;
    long desiredWidth0;
    long desiredHeight0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 5)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'zslll' (&bitmap0, &name0, &name_len0, &type0, &desiredWidth0, &desiredHeight0)\n");
        #endif

        char parse_parameters_string[] = "zslll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap0, &name0, &name_len0, &type0, &desiredWidth0, &desiredHeight0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap0)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap0)->native_object;
                    object_pointer0_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXBITMAP_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(bitmap0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxBitmapHandler::LoadFile((wxBitmap*) object_pointer0_0, wxString(name0, wxConvUTF8), (wxBitmapType) type0, (int) desiredWidth0, (int) desiredHeight0))\n\n");
                #endif

                RETVAL_BOOL(((wxBitmapHandler_php*)native_object)->LoadFile((wxBitmap*) object_pointer0_0, wxString(name0, wxConvUTF8), (wxBitmapType) type0, (int) desiredWidth0, (int) desiredHeight0));

                references->AddReference(bitmap0, "wxBitmapHandler::LoadFile at call 1 with 5 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapHandler::LoadFile\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmapType wxBitmapHandler::GetType()
   Gets the bitmap type associated with this handler. */
PHP_METHOD(php_wxBitmapHandler, GetType)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapHandler::GetType\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapHandler* current_object;
    wxphp_object_type current_object_type;
    wxBitmapHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapHandler::GetType call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPHANDLER_TYPE){
                references = &((wxBitmapHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxBitmapHandler::GetType())\n\n");
                #endif

                RETVAL_LONG(((wxBitmapHandler_php*)native_object)->GetType());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapHandler::GetType\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxBitmapHandler::GetName()
   Gets the name of this handler. */
PHP_METHOD(php_wxBitmapHandler, GetName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapHandler::GetName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapHandler* current_object;
    wxphp_object_type current_object_type;
    wxBitmapHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapHandler::GetName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPHANDLER_TYPE){
                references = &((wxBitmapHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxBitmapHandler::GetName().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxBitmapHandler_php*)native_object)->GetName();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapHandler::GetName\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxBitmapHandler::GetExtension()
   Gets the file extension associated with this handler. */
PHP_METHOD(php_wxBitmapHandler, GetExtension)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapHandler::GetExtension\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapHandler* current_object;
    wxphp_object_type current_object_type;
    wxBitmapHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapHandler::GetExtension call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPHANDLER_TYPE){
                references = &((wxBitmapHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxBitmapHandler::GetExtension().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxBitmapHandler_php*)native_object)->GetExtension();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapHandler::GetExtension\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxBitmapHandler::SaveFile(wxBitmap bitmap, string name, wxBitmapType type, wxPalette palette)
   Saves a bitmap in the named file. */
PHP_METHOD(php_wxBitmapHandler, SaveFile)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapHandler::SaveFile\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapHandler* current_object;
    wxphp_object_type current_object_type;
    wxBitmapHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapHandler::SaveFile call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPHANDLER_TYPE){
                references = &((wxBitmapHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* bitmap0;
    wxBitmap* object_pointer0_0 = 0;
    char* name0;
    size_t name_len0;
    long type0;
    zval* palette0;
    wxPalette* object_pointer0_3 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 3  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'zsl|z' (&bitmap0, &name0, &name_len0, &type0, &palette0)\n");
        #endif

        char parse_parameters_string[] = "zsl|z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap0, &name0, &name_len0, &type0, &palette0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap0)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap0)->native_object;
                    object_pointer0_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXBITMAP_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(bitmap0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 4){
                if(Z_TYPE_P(palette0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPalette_P(palette0)->object_type;
                    argument_native_object = (void*) Z_wxPalette_P(palette0)->native_object;
                    object_pointer0_3 = (wxPalette*) argument_native_object;
                    if (!object_pointer0_3 || (argument_type != PHP_WXPALETTE_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'palette' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(palette0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'palette' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxBitmapHandler::SaveFile((const wxBitmap*) object_pointer0_0, wxString(name0, wxConvUTF8), (wxBitmapType) type0))\n\n");
                #endif

                RETVAL_BOOL(((wxBitmapHandler_php*)native_object)->SaveFile((const wxBitmap*) object_pointer0_0, wxString(name0, wxConvUTF8), (wxBitmapType) type0));

                references->AddReference(bitmap0, "wxBitmapHandler::SaveFile at call 1 with 3 argument(s)");

                return;
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxBitmapHandler::SaveFile((const wxBitmap*) object_pointer0_0, wxString(name0, wxConvUTF8), (wxBitmapType) type0, (const wxPalette*) object_pointer0_3))\n\n");
                #endif

                RETVAL_BOOL(((wxBitmapHandler_php*)native_object)->SaveFile((const wxBitmap*) object_pointer0_0, wxString(name0, wxConvUTF8), (wxBitmapType) type0, (const wxPalette*) object_pointer0_3));

                references->AddReference(bitmap0, "wxBitmapHandler::SaveFile at call 1 with 4 argument(s)");
                references->AddReference(palette0, "wxBitmapHandler::SaveFile at call 1 with 4 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapHandler::SaveFile\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxBitmapHandler::Create(wxBitmap &bitmap, void data, wxBitmapType type, int width, int height, int depth)
   Creates a bitmap from the given data, which can be of arbitrary type. */
PHP_METHOD(php_wxBitmapHandler, Create)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmapHandler::Create\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmapHandler* current_object;
    wxphp_object_type current_object_type;
    wxBitmapHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmapHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmapHandler::Create call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAPHANDLER_TYPE){
                references = &((wxBitmapHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* bitmap0;
    wxBitmap* object_pointer0_0 = 0;
    char* data0;
    size_t data_len0;
    long type0;
    long width0;
    long height0;
    long depth0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 5  && arguments_received <= 6)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'zslll|l' (&bitmap0, &data0, &data_len0, &type0, &width0, &height0, &depth0)\n");
        #endif

        char parse_parameters_string[] = "zslll|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap0, &data0, &data_len0, &type0, &width0, &height0, &depth0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap0)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap0)->native_object;
                    object_pointer0_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXBITMAP_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(bitmap0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxBitmapHandler::Create((wxBitmap*) object_pointer0_0, (const void*) data0, (wxBitmapType) type0, (int) width0, (int) height0))\n\n");
                #endif

                RETVAL_BOOL(((wxBitmapHandler_php*)native_object)->Create((wxBitmap*) object_pointer0_0, (const void*) data0, (wxBitmapType) type0, (int) width0, (int) height0));

                references->AddReference(bitmap0, "wxBitmapHandler::Create at call 1 with 5 argument(s)");

                return;
                break;
            }
            case 6:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxBitmapHandler::Create((wxBitmap*) object_pointer0_0, (const void*) data0, (wxBitmapType) type0, (int) width0, (int) height0, (int) depth0))\n\n");
                #endif

                RETVAL_BOOL(((wxBitmapHandler_php*)native_object)->Create((wxBitmap*) object_pointer0_0, (const void*) data0, (wxBitmapType) type0, (int) width0, (int) height0, (int) depth0));

                references->AddReference(bitmap0, "wxBitmapHandler::Create at call 1 with 6 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmapHandler::Create\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxBitmap_free(void *object)
{
    zo_wxBitmap* custom_object = (zo_wxBitmap*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxBitmap_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxBitmap done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxBitmap_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxBitmap_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* custom_object;

    custom_object = (zo_wxBitmap*) ecalloc(
        1,
        sizeof(zo_wxBitmap)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxBitmap_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXBITMAP_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxBitmap::AddHandler(wxBitmapHandler &handler)
   Adds a handler to the end of the static list of format handlers. */
PHP_METHOD(php_wxBitmap, AddHandler)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::AddHandler\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::AddHandler call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* handler0;
    wxBitmapHandler* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&handler0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &handler0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(handler0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmapHandler_P(handler0)->object_type;
                    argument_native_object = (void*) Z_wxBitmapHandler_P(handler0)->native_object;
                    object_pointer0_0 = (wxBitmapHandler*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXBITMAPHANDLER_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'handler' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(handler0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'handler' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxBitmap::AddHandler((wxBitmapHandler*) object_pointer0_0)\n\n");
                #endif

                wxBitmap::AddHandler((wxBitmapHandler*) object_pointer0_0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::AddHandler\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxBitmap::CleanUpHandlers()
   Deletes all bitmap handlers. */
PHP_METHOD(php_wxBitmap, CleanUpHandlers)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::CleanUpHandlers\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::CleanUpHandlers call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxBitmap::CleanUpHandlers()\n\n");
                #endif

                wxBitmap::CleanUpHandlers();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::CleanUpHandlers\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmap wxBitmap::ConvertToDisabled(int brightness)
   Returns disabled (dimmed) version of the bitmap. */
PHP_METHOD(php_wxBitmap, ConvertToDisabled)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::ConvertToDisabled\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::ConvertToDisabled call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long brightness0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&brightness0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &brightness0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBitmap::ConvertToDisabled() to return new object\n\n");
                #endif

                wxBitmap value_to_return0;
                value_to_return0 = ((wxBitmap_php*)native_object)->ConvertToDisabled();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxBitmap));
                object_init_ex(return_value, php_wxBitmap_entry);
                ((wxBitmap_php*)ptr)->phpObj = *return_value;
                zo_wxBitmap* zo0 = Z_wxBitmap_P(return_value);
                zo0->native_object = (wxBitmap_php*) ptr;


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBitmap::ConvertToDisabled((unsigned char) brightness0) to return new object\n\n");
                #endif

                wxBitmap value_to_return1;
                value_to_return1 = ((wxBitmap_php*)native_object)->ConvertToDisabled((unsigned char) brightness0);
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxBitmap));
                object_init_ex(return_value, php_wxBitmap_entry);
                ((wxBitmap_php*)ptr)->phpObj = *return_value;
                zo_wxBitmap* zo1 = Z_wxBitmap_P(return_value);
                zo1->native_object = (wxBitmap_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::ConvertToDisabled\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxBitmap::wxBitmap()
   Default constructor. */
PHP_METHOD(php_wxBitmap, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    zval* bitmap1;
    wxBitmap* object_pointer1_0 = 0;
    bool overload1_called = false;

    //Parameters for overload 2
        long width2;
    long height2;
    long depth2;
    bool overload2_called = false;

    //Parameters for overload 3
    long width3;
    long height3;
    long depth3;
    bool overload3_called = false;

    //Parameters for overload 4
    zval* sz4;
    wxSize* object_pointer4_0 = 0;
    long depth4;
    bool overload4_called = false;

    //Parameters for overload 5
    long width5;
    long height5;
    zval* dc5;
    wxDC* object_pointer5_2 = 0;
    bool overload5_called = false;

    //Parameters for overload 6
    char* name6;
    size_t name_len6;
    long type6;
    bool overload6_called = false;

    //Parameters for overload 7
    zval* img7;
    wxImage* object_pointer7_0 = 0;
    long depth7;
    bool overload7_called = false;

    //Parameters for overload 8
    zval* img8;
    wxImage* object_pointer8_0 = 0;
    zval* dc8;
    wxDC* object_pointer8_1 = 0;
    bool overload8_called = false;

    //Parameters for overload 9
    zval* cursor9;
    wxCursor* object_pointer9_0 = 0;
    bool overload9_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&bitmap1, php_wxBitmap_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap1, php_wxBitmap_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap1)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap1)->native_object;
                    object_pointer1_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer1_0 )
                    {
                        goto overload2;
                    }
                }
                else if(Z_TYPE_P(bitmap1) != IS_NULL)
                {
                    goto overload2;
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received >= 3  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll|l' (&width2, &height2, &depth2)\n");
        #endif

        char parse_parameters_string[] = "ll|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &width2, &height2, &depth2 ) == SUCCESS)
        {
            overload2_called = true;
            already_called = true;
        }
    }

    //Overload 3
    overload3:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll|l' (&width3, &height3, &depth3)\n");
        #endif

        char parse_parameters_string[] = "ll|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &width3, &height3, &depth3 ) == SUCCESS)
        {
            overload3_called = true;
            already_called = true;
        }
    }

    //Overload 4
    overload4:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O|l' (&sz4, php_wxSize_entry, &depth4)\n");
        #endif

        char parse_parameters_string[] = "O|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &sz4, php_wxSize_entry, &depth4 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(sz4) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(sz4)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(sz4)->native_object;
                    object_pointer4_0 = (wxSize*) argument_native_object;
                    if (!object_pointer4_0 )
                    {
                        goto overload5;
                    }
                }
                else if(Z_TYPE_P(sz4) != IS_NULL)
                {
                    goto overload5;
                }
            }

            overload4_called = true;
            already_called = true;
        }
    }

    //Overload 5
    overload5:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'llo' (&width5, &height5, &dc5)\n");
        #endif

        char parse_parameters_string[] = "llo";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &width5, &height5, &dc5 ) == SUCCESS)
        {
            if(arguments_received >= 3){
                if(Z_TYPE_P(dc5) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxDC_P(dc5)->object_type;
                    argument_native_object = (void*) Z_wxDC_P(dc5)->native_object;
                    object_pointer5_2 = (wxDC*) argument_native_object;
                    if (!object_pointer5_2 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
                    {
                        goto overload6;
                    }
                }
                else if(Z_TYPE_P(dc5) != IS_NULL)
                {
                    goto overload6;
                }
            }

            overload5_called = true;
            already_called = true;
        }
    }

    //Overload 6
    overload6:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|l' (&name6, &name_len6, &type6)\n");
        #endif

        char parse_parameters_string[] = "s|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name6, &name_len6, &type6 ) == SUCCESS)
        {
            overload6_called = true;
            already_called = true;
        }
    }

    //Overload 7
    overload7:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O|l' (&img7, php_wxImage_entry, &depth7)\n");
        #endif

        char parse_parameters_string[] = "O|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &img7, php_wxImage_entry, &depth7 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(img7) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxImage_P(img7)->object_type;
                    argument_native_object = (void*) Z_wxImage_P(img7)->native_object;
                    object_pointer7_0 = (wxImage*) argument_native_object;
                    if (!object_pointer7_0 )
                    {
                        goto overload8;
                    }
                }
                else if(Z_TYPE_P(img7) != IS_NULL)
                {
                    goto overload8;
                }
            }

            overload7_called = true;
            already_called = true;
        }
    }

    //Overload 8
    overload8:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'Oo' (&img8, php_wxImage_entry, &dc8)\n");
        #endif

        char parse_parameters_string[] = "Oo";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &img8, php_wxImage_entry, &dc8 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(img8) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxImage_P(img8)->object_type;
                    argument_native_object = (void*) Z_wxImage_P(img8)->native_object;
                    object_pointer8_0 = (wxImage*) argument_native_object;
                    if (!object_pointer8_0 )
                    {
                        goto overload9;
                    }
                }
                else if(Z_TYPE_P(img8) != IS_NULL)
                {
                    goto overload9;
                }
            }

            if(arguments_received >= 2){
                if(Z_TYPE_P(dc8) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxDC_P(dc8)->object_type;
                    argument_native_object = (void*) Z_wxDC_P(dc8)->native_object;
                    object_pointer8_1 = (wxDC*) argument_native_object;
                    if (!object_pointer8_1 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
                    {
                        goto overload9;
                    }
                }
                else if(Z_TYPE_P(dc8) != IS_NULL)
                {
                    goto overload9;
                }
            }

            overload8_called = true;
            already_called = true;
        }
    }

    //Overload 9
    overload9:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&cursor9, php_wxCursor_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &cursor9, php_wxCursor_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(cursor9) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxCursor_P(cursor9)->object_type;
                    argument_native_object = (void*) Z_wxCursor_P(cursor9)->native_object;
                    object_pointer9_0 = (wxCursor*) argument_native_object;
                    if (!object_pointer9_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'cursor' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(cursor9) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'cursor' not null, could not be retreived correctly.");
                }
            }

            overload9_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxBitmap_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxBitmap*) object_pointer1_0)\n");
                #endif

                native_object = new wxBitmap_php(*(wxBitmap*) object_pointer1_0);

                native_object->references.Initialize();
                ((wxBitmap_php*) native_object)->references.AddReference(bitmap1, "wxBitmap::wxBitmap at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) width2, (int) height2)\n");
                #endif

                native_object = new wxBitmap_php((int) width2, (int) height2);

                native_object->references.Initialize();
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) width2, (int) height2, (int) depth2)\n");
                #endif

                native_object = new wxBitmap_php((int) width2, (int) height2, (int) depth2);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload3_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) width3, (int) height3)\n");
                #endif

                native_object = new wxBitmap_php((int) width3, (int) height3);

                native_object->references.Initialize();
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) width3, (int) height3, (int) depth3)\n");
                #endif

                native_object = new wxBitmap_php((int) width3, (int) height3, (int) depth3);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload4_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxSize*) object_pointer4_0)\n");
                #endif

                native_object = new wxBitmap_php(*(wxSize*) object_pointer4_0);

                native_object->references.Initialize();
                ((wxBitmap_php*) native_object)->references.AddReference(sz4, "wxBitmap::wxBitmap at call 4 with 1 argument(s)");
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxSize*) object_pointer4_0, (int) depth4)\n");
                #endif

                native_object = new wxBitmap_php(*(wxSize*) object_pointer4_0, (int) depth4);

                native_object->references.Initialize();
                ((wxBitmap_php*) native_object)->references.AddReference(sz4, "wxBitmap::wxBitmap at call 4 with 2 argument(s)");
                break;
            }
        }
    }

    if(overload5_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) width5, (int) height5, *(wxDC*) object_pointer5_2)\n");
                #endif

                native_object = new wxBitmap_php((int) width5, (int) height5, *(wxDC*) object_pointer5_2);

                native_object->references.Initialize();
                ((wxBitmap_php*) native_object)->references.AddReference(dc5, "wxBitmap::wxBitmap at call 4 with 3 argument(s)");
                break;
            }
        }
    }

    if(overload6_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(name6, wxConvUTF8))\n");
                #endif

                native_object = new wxBitmap_php(wxString(name6, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(name6, wxConvUTF8), (wxBitmapType) type6)\n");
                #endif

                native_object = new wxBitmap_php(wxString(name6, wxConvUTF8), (wxBitmapType) type6);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload7_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxImage*) object_pointer7_0)\n");
                #endif

                native_object = new wxBitmap_php(*(wxImage*) object_pointer7_0);

                native_object->references.Initialize();
                ((wxBitmap_php*) native_object)->references.AddReference(img7, "wxBitmap::wxBitmap at call 4 with 1 argument(s)");
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxImage*) object_pointer7_0, (int) depth7)\n");
                #endif

                native_object = new wxBitmap_php(*(wxImage*) object_pointer7_0, (int) depth7);

                native_object->references.Initialize();
                ((wxBitmap_php*) native_object)->references.AddReference(img7, "wxBitmap::wxBitmap at call 4 with 2 argument(s)");
                break;
            }
        }
    }

    if(overload8_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxImage*) object_pointer8_0, *(wxDC*) object_pointer8_1)\n");
                #endif

                native_object = new wxBitmap_php(*(wxImage*) object_pointer8_0, *(wxDC*) object_pointer8_1);

                native_object->references.Initialize();
                ((wxBitmap_php*) native_object)->references.AddReference(img8, "wxBitmap::wxBitmap at call 4 with 2 argument(s)");
                ((wxBitmap_php*) native_object)->references.AddReference(dc8, "wxBitmap::wxBitmap at call 4 with 2 argument(s)");
                break;
            }
        }
    }

    if(overload9_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxCursor*) object_pointer9_0)\n");
                #endif

                native_object = new wxBitmap_php(*(wxCursor*) object_pointer9_0);

                native_object->references.Initialize();
                ((wxBitmap_php*) native_object)->references.AddReference(cursor9, "wxBitmap::wxBitmap at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxBitmap_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxBitmap::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto bool wxBitmap::LoadFile(string name, wxBitmapType type)
   Loads a bitmap from a file or resource. */
PHP_METHOD(php_wxBitmap, LoadFile)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::LoadFile\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::LoadFile call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    long type0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|l' (&name0, &name_len0, &type0)\n");
        #endif

        char parse_parameters_string[] = "s|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0, &type0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxBitmap::LoadFile(wxString(name0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxBitmap_php*)native_object)->LoadFile(wxString(name0, wxConvUTF8)));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxBitmap::LoadFile(wxString(name0, wxConvUTF8), (wxBitmapType) type0))\n\n");
                #endif

                RETVAL_BOOL(((wxBitmap_php*)native_object)->LoadFile(wxString(name0, wxConvUTF8), (wxBitmapType) type0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::LoadFile\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxBitmap::RemoveHandler(string name)
   Finds the handler with the given name, and removes it. */
PHP_METHOD(php_wxBitmap, RemoveHandler)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::RemoveHandler\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::RemoveHandler call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxBitmap::RemoveHandler(wxString(name0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(wxBitmap::RemoveHandler(wxString(name0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::RemoveHandler\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxBitmap::SaveFile(string name, wxBitmapType type, wxPalette palette)
   Saves a bitmap in the named file. */
PHP_METHOD(php_wxBitmap, SaveFile)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::SaveFile\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::SaveFile call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    long type0;
    zval* palette0;
    wxPalette* object_pointer0_2 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sl|z' (&name0, &name_len0, &type0, &palette0)\n");
        #endif

        char parse_parameters_string[] = "sl|z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0, &type0, &palette0 ) == SUCCESS)
        {
            if(arguments_received >= 3){
                if(Z_TYPE_P(palette0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPalette_P(palette0)->object_type;
                    argument_native_object = (void*) Z_wxPalette_P(palette0)->native_object;
                    object_pointer0_2 = (wxPalette*) argument_native_object;
                    if (!object_pointer0_2 || (argument_type != PHP_WXPALETTE_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'palette' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(palette0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'palette' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxBitmap::SaveFile(wxString(name0, wxConvUTF8), (wxBitmapType) type0))\n\n");
                #endif

                RETVAL_BOOL(((wxBitmap_php*)native_object)->SaveFile(wxString(name0, wxConvUTF8), (wxBitmapType) type0));


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxBitmap::SaveFile(wxString(name0, wxConvUTF8), (wxBitmapType) type0, (const wxPalette*) object_pointer0_2))\n\n");
                #endif

                RETVAL_BOOL(((wxBitmap_php*)native_object)->SaveFile(wxString(name0, wxConvUTF8), (wxBitmapType) type0, (const wxPalette*) object_pointer0_2));

                references->AddReference(palette0, "wxBitmap::SaveFile at call 1 with 3 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::SaveFile\n"
        );
    }
}
/* }}} */

/* {{{ proto wxImage wxBitmap::ConvertToImage()
   Creates an image from a platform-dependent bitmap. */
PHP_METHOD(php_wxBitmap, ConvertToImage)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::ConvertToImage\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::ConvertToImage call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBitmap::ConvertToImage() to return new object\n\n");
                #endif

                wxImage value_to_return0;
                value_to_return0 = ((wxBitmap_php*)native_object)->ConvertToImage();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo0 = Z_wxImage_P(return_value);
                zo0->native_object = (wxImage_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::ConvertToImage\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxBitmap::CopyFromIcon(wxIcon icon)
   Creates the bitmap from an icon. */
PHP_METHOD(php_wxBitmap, CopyFromIcon)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::CopyFromIcon\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::CopyFromIcon call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* icon0;
    wxIcon* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&icon0, php_wxIcon_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &icon0, php_wxIcon_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(icon0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxIcon_P(icon0)->object_type;
                    argument_native_object = (void*) Z_wxIcon_P(icon0)->native_object;
                    object_pointer0_0 = (wxIcon*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'icon' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(icon0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'icon' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxBitmap::CopyFromIcon(*(wxIcon*) object_pointer0_0))\n\n");
                #endif

                RETVAL_BOOL(((wxBitmap_php*)native_object)->CopyFromIcon(*(wxIcon*) object_pointer0_0));

                references->AddReference(icon0, "wxBitmap::CopyFromIcon at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::CopyFromIcon\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxBitmap::Create(int width, int height, wxDC dc)
   Create a bitmap compatible with the given DC, inheriting its magnification factor. */
PHP_METHOD(php_wxBitmap, Create)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::Create\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::Create call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long width0;
    long height0;
    zval* dc0;
    wxDC* object_pointer0_2 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'llo' (&width0, &height0, &dc0)\n");
        #endif

        char parse_parameters_string[] = "llo";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &width0, &height0, &dc0 ) == SUCCESS)
        {
            if(arguments_received >= 3){
                if(Z_TYPE_P(dc0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxDC_P(dc0)->object_type;
                    argument_native_object = (void*) Z_wxDC_P(dc0)->native_object;
                    object_pointer0_2 = (wxDC*) argument_native_object;
                    if (!object_pointer0_2 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(dc0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxBitmap::Create((int) width0, (int) height0, *(wxDC*) object_pointer0_2))\n\n");
                #endif

                RETVAL_BOOL(((wxBitmap_php*)native_object)->Create((int) width0, (int) height0, *(wxDC*) object_pointer0_2));

                references->AddReference(dc0, "wxBitmap::Create at call 3 with 3 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::Create\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmapHandler wxBitmap::FindHandler(string name)
   Finds the handler with the given name. */
PHP_METHOD(php_wxBitmap, FindHandler)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::FindHandler\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::FindHandler call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    bool overload0_called = false;

    //Parameters for overload 1
    char* extension1;
    size_t extension_len1;
    long bitmapType1;
    bool overload1_called = false;

    //Parameters for overload 2
    long bitmapType2;
    bool overload2_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sl' (&extension1, &extension_len1, &bitmapType1)\n");
        #endif

        char parse_parameters_string[] = "sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &extension1, &extension_len1, &bitmapType1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&bitmapType2)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmapType2 ) == SUCCESS)
        {
            overload2_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxBitmap::FindHandler(wxString(name0, wxConvUTF8)) to return object pointer\n\n");
                #endif

                wxBitmapHandler_php* value_to_return1;
                value_to_return1 = (wxBitmapHandler_php*) wxBitmap::FindHandler(wxString(name0, wxConvUTF8));
                if(value_to_return1 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return1->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return1->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return1->phpObj);
                        zval_add_ref(&value_to_return1->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxBitmapHandler_entry);
                    Z_wxBitmapHandler_P(return_value)->native_object = (wxBitmapHandler_php*) value_to_return1;
                }



                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxBitmap::FindHandler(wxString(extension1, wxConvUTF8), (wxBitmapType) bitmapType1) to return object pointer\n\n");
                #endif

                wxBitmapHandler_php* value_to_return2;
                value_to_return2 = (wxBitmapHandler_php*) wxBitmap::FindHandler(wxString(extension1, wxConvUTF8), (wxBitmapType) bitmapType1);
                if(value_to_return2 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return2->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return2->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return2->phpObj);
                        zval_add_ref(&value_to_return2->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxBitmapHandler_entry);
                    Z_wxBitmapHandler_P(return_value)->native_object = (wxBitmapHandler_php*) value_to_return2;
                }



                return;
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxBitmap::FindHandler((wxBitmapType) bitmapType2) to return object pointer\n\n");
                #endif

                wxBitmapHandler_php* value_to_return1;
                value_to_return1 = (wxBitmapHandler_php*) wxBitmap::FindHandler((wxBitmapType) bitmapType2);
                if(value_to_return1 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return1->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return1->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return1->phpObj);
                        zval_add_ref(&value_to_return1->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxBitmapHandler_entry);
                    Z_wxBitmapHandler_P(return_value)->native_object = (wxBitmapHandler_php*) value_to_return1;
                }



                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::FindHandler\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxBitmap::GetDepth()
   Gets the colour depth of the bitmap. */
PHP_METHOD(php_wxBitmap, GetDepth)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::GetDepth\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::GetDepth call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxBitmap::GetDepth())\n\n");
                #endif

                RETVAL_LONG(((wxBitmap_php*)native_object)->GetDepth());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::GetDepth\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxBitmap::GetHeight()
   Returns the height of the bitmap in physical pixels. */
PHP_METHOD(php_wxBitmap, GetHeight)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::GetHeight\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::GetHeight call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxBitmap::GetHeight())\n\n");
                #endif

                RETVAL_LONG(((wxBitmap_php*)native_object)->GetHeight());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::GetHeight\n"
        );
    }
}
/* }}} */

/* {{{ proto wxMask wxBitmap::GetMask()
   Gets the associated mask (if any) which may have been loaded from a file or set for the bitmap. */
PHP_METHOD(php_wxBitmap, GetMask)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::GetMask\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::GetMask call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBitmap::GetMask() to return object pointer\n\n");
                #endif

                wxMask_php* value_to_return0;
                value_to_return0 = (wxMask_php*) ((wxBitmap_php*)native_object)->GetMask();

                if(value_to_return0 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxMask_entry);
                    Z_wxMask_P(return_value)->native_object = (wxMask_php*) value_to_return0;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxBitmap::GetMask at call 5 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::GetMask\n"
        );
    }
}
/* }}} */

/* {{{ proto wxPalette wxBitmap::GetPalette()
   Gets the associated palette (if any) which may have been loaded from a file or set for the bitmap. */
PHP_METHOD(php_wxBitmap, GetPalette)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::GetPalette\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::GetPalette call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBitmap::GetPalette() to return object pointer\n\n");
                #endif

                wxPalette_php* value_to_return0;
                value_to_return0 = (wxPalette_php*) ((wxBitmap_php*)native_object)->GetPalette();

                if(value_to_return0 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxPalette_entry);
                    Z_wxPalette_P(return_value)->native_object = (wxPalette_php*) value_to_return0;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxBitmap::GetPalette at call 5 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::GetPalette\n"
        );
    }
}
/* }}} */

/* {{{ proto wxSize wxBitmap::GetSize()
   Returns the size of the bitmap in physical pixels. */
PHP_METHOD(php_wxBitmap, GetSize)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::GetSize\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::GetSize call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBitmap::GetSize() to return new object\n\n");
                #endif

                wxSize value_to_return0;
                value_to_return0 = ((wxBitmap_php*)native_object)->GetSize();
                void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxSize));
                object_init_ex(return_value, php_wxSize_entry);
                ((wxSize_php*)ptr)->phpObj = *return_value;
                zo_wxSize* zo0 = Z_wxSize_P(return_value);
                zo0->native_object = (wxSize_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::GetSize\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmap wxBitmap::GetSubBitmap(wxRect rect)
   Returns a sub bitmap of the current one as long as the rect belongs entirely to the bitmap. */
PHP_METHOD(php_wxBitmap, GetSubBitmap)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::GetSubBitmap\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::GetSubBitmap call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* rect0;
    wxRect* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&rect0, php_wxRect_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &rect0, php_wxRect_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(rect0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxRect_P(rect0)->object_type;
                    argument_native_object = (void*) Z_wxRect_P(rect0)->native_object;
                    object_pointer0_0 = (wxRect*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(rect0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBitmap::GetSubBitmap(*(wxRect*) object_pointer0_0) to return new object\n\n");
                #endif

                wxBitmap value_to_return1;
                value_to_return1 = ((wxBitmap_php*)native_object)->GetSubBitmap(*(wxRect*) object_pointer0_0);
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxBitmap));
                object_init_ex(return_value, php_wxBitmap_entry);
                ((wxBitmap_php*)ptr)->phpObj = *return_value;
                zo_wxBitmap* zo1 = Z_wxBitmap_P(return_value);
                zo1->native_object = (wxBitmap_php*) ptr;

                references->AddReference(rect0, "wxBitmap::GetSubBitmap at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::GetSubBitmap\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxBitmap::GetWidth()
   Returns the width of the bitmap in physical pixels. */
PHP_METHOD(php_wxBitmap, GetWidth)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::GetWidth\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::GetWidth call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxBitmap::GetWidth())\n\n");
                #endif

                RETVAL_LONG(((wxBitmap_php*)native_object)->GetWidth());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::GetWidth\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxBitmap::InitStandardHandlers()
   Adds the standard bitmap format handlers, which, depending on wxWidgets configuration, can be handlers for Windows bitmap, Windows bitmap resource, and XPM. */
PHP_METHOD(php_wxBitmap, InitStandardHandlers)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::InitStandardHandlers\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::InitStandardHandlers call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxBitmap::InitStandardHandlers()\n\n");
                #endif

                wxBitmap::InitStandardHandlers();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::InitStandardHandlers\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxBitmap::InsertHandler(wxBitmapHandler &handler)
   Adds a handler at the start of the static list of format handlers. */
PHP_METHOD(php_wxBitmap, InsertHandler)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::InsertHandler\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::InsertHandler call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* handler0;
    wxBitmapHandler* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&handler0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &handler0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(handler0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmapHandler_P(handler0)->object_type;
                    argument_native_object = (void*) Z_wxBitmapHandler_P(handler0)->native_object;
                    object_pointer0_0 = (wxBitmapHandler*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXBITMAPHANDLER_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'handler' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(handler0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'handler' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxBitmap::InsertHandler((wxBitmapHandler*) object_pointer0_0)\n\n");
                #endif

                wxBitmap::InsertHandler((wxBitmapHandler*) object_pointer0_0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::InsertHandler\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxBitmap::IsOk()
   Returns true if bitmap data is present. */
PHP_METHOD(php_wxBitmap, IsOk)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::IsOk\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::IsOk call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxBitmap::IsOk())\n\n");
                #endif

                RETVAL_BOOL(((wxBitmap_php*)native_object)->IsOk());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::IsOk\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxBitmap::SetMask(wxMask &mask)
   Sets the mask for this bitmap. */
PHP_METHOD(php_wxBitmap, SetMask)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::SetMask\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::SetMask call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* mask0;
    wxMask* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&mask0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &mask0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(mask0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxMask_P(mask0)->object_type;
                    argument_native_object = (void*) Z_wxMask_P(mask0)->native_object;
                    object_pointer0_0 = (wxMask*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXMASK_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'mask' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(mask0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'mask' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBitmap::SetMask((wxMask*) object_pointer0_0)\n\n");
                #endif

                ((wxBitmap_php*)native_object)->SetMask((wxMask*) object_pointer0_0);

                references->AddReference(mask0, "wxBitmap::SetMask at call 1 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::SetMask\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxBitmap::SetPalette(wxPalette palette)
   Sets the associated palette. */
PHP_METHOD(php_wxBitmap, SetPalette)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBitmap::SetPalette\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBitmap* current_object;
    wxphp_object_type current_object_type;
    wxBitmap_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBitmap_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBitmap::SetPalette call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBITMAP_TYPE){
                references = &((wxBitmap_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* palette0;
    wxPalette* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&palette0, php_wxPalette_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &palette0, php_wxPalette_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(palette0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPalette_P(palette0)->object_type;
                    argument_native_object = (void*) Z_wxPalette_P(palette0)->native_object;
                    object_pointer0_0 = (wxPalette*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'palette' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(palette0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'palette' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBitmap::SetPalette(*(wxPalette*) object_pointer0_0)\n\n");
                #endif

                ((wxBitmap_php*)native_object)->SetPalette(*(wxPalette*) object_pointer0_0);

                references->AddReference(palette0, "wxBitmap::SetPalette at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBitmap::SetPalette\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxMask_free(void *object)
{
    zo_wxMask* custom_object = (zo_wxMask*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxMask_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxMask done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxMask_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxMask_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxMask* custom_object;

    custom_object = (zo_wxMask*) ecalloc(
        1,
        sizeof(zo_wxMask)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxMask_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXMASK_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto bool wxMask::Create(wxBitmap bitmap, int index)
   Constructs a mask from a bitmap and a palette index that indicates the background. */
PHP_METHOD(php_wxMask, Create)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxMask::Create\n");
    php_printf("===========================================\n");
    #endif

    zo_wxMask* current_object;
    wxphp_object_type current_object_type;
    wxMask_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxMask_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxMask::Create call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXMASK_TYPE){
                references = &((wxMask_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* bitmap0;
    wxBitmap* object_pointer0_0 = 0;
    long index0;
    bool overload0_called = false;

    //Parameters for overload 1
    zval* bitmap1;
    wxBitmap* object_pointer1_0 = 0;
    bool overload1_called = false;

    //Parameters for overload 2
    zval* bitmap2;
    wxBitmap* object_pointer2_0 = 0;
    zval* colour2;
    wxColour* object_pointer2_1 = 0;
    bool overload2_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'Ol' (&bitmap0, php_wxBitmap_entry, &index0)\n");
        #endif

        char parse_parameters_string[] = "Ol";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap0, php_wxBitmap_entry, &index0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap0)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap0)->native_object;
                    object_pointer0_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        goto overload1;
                    }
                }
                else if(Z_TYPE_P(bitmap0) != IS_NULL)
                {
                    goto overload1;
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&bitmap1, php_wxBitmap_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap1, php_wxBitmap_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap1)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap1)->native_object;
                    object_pointer1_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer1_0 )
                    {
                        goto overload2;
                    }
                }
                else if(Z_TYPE_P(bitmap1) != IS_NULL)
                {
                    goto overload2;
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'OO' (&bitmap2, php_wxBitmap_entry, &colour2, php_wxColour_entry)\n");
        #endif

        char parse_parameters_string[] = "OO";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap2, php_wxBitmap_entry, &colour2, php_wxColour_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap2) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap2)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap2)->native_object;
                    object_pointer2_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer2_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(bitmap2) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 2){
                if(Z_TYPE_P(colour2) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxColour_P(colour2)->object_type;
                    argument_native_object = (void*) Z_wxColour_P(colour2)->native_object;
                    object_pointer2_1 = (wxColour*) argument_native_object;
                    if (!object_pointer2_1 )
                    {
                        zend_error(E_ERROR, "Parameter 'colour' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(colour2) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'colour' not null, could not be retreived correctly.");
                }
            }

            overload2_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxMask::Create(*(wxBitmap*) object_pointer0_0, (int) index0))\n\n");
                #endif

                RETVAL_BOOL(((wxMask_php*)native_object)->Create(*(wxBitmap*) object_pointer0_0, (int) index0));

                references->AddReference(bitmap0, "wxMask::Create at call 3 with 2 argument(s)");

                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxMask::Create(*(wxBitmap*) object_pointer1_0))\n\n");
                #endif

                RETVAL_BOOL(((wxMask_php*)native_object)->Create(*(wxBitmap*) object_pointer1_0));

                references->AddReference(bitmap1, "wxMask::Create at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxMask::Create(*(wxBitmap*) object_pointer2_0, *(wxColour*) object_pointer2_1))\n\n");
                #endif

                RETVAL_BOOL(((wxMask_php*)native_object)->Create(*(wxBitmap*) object_pointer2_0, *(wxColour*) object_pointer2_1));

                references->AddReference(bitmap2, "wxMask::Create at call 3 with 2 argument(s)");
                references->AddReference(colour2, "wxMask::Create at call 3 with 2 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxMask::Create\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxMask::wxMask()
   Default constructor. */
PHP_METHOD(php_wxMask, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxMask::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxMask* current_object;
    wxMask_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    zval* bitmap1;
    wxBitmap* object_pointer1_0 = 0;
    long index1;
    bool overload1_called = false;

    //Parameters for overload 2
    zval* bitmap2;
    wxBitmap* object_pointer2_0 = 0;
    bool overload2_called = false;

    //Parameters for overload 3
    zval* bitmap3;
    wxBitmap* object_pointer3_0 = 0;
    zval* colour3;
    wxColour* object_pointer3_1 = 0;
    bool overload3_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'Ol' (&bitmap1, php_wxBitmap_entry, &index1)\n");
        #endif

        char parse_parameters_string[] = "Ol";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap1, php_wxBitmap_entry, &index1 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap1)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap1)->native_object;
                    object_pointer1_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer1_0 )
                    {
                        goto overload2;
                    }
                }
                else if(Z_TYPE_P(bitmap1) != IS_NULL)
                {
                    goto overload2;
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&bitmap2, php_wxBitmap_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap2, php_wxBitmap_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap2) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap2)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap2)->native_object;
                    object_pointer2_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer2_0 )
                    {
                        goto overload3;
                    }
                }
                else if(Z_TYPE_P(bitmap2) != IS_NULL)
                {
                    goto overload3;
                }
            }

            overload2_called = true;
            already_called = true;
        }
    }

    //Overload 3
    overload3:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'OO' (&bitmap3, php_wxBitmap_entry, &colour3, php_wxColour_entry)\n");
        #endif

        char parse_parameters_string[] = "OO";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap3, php_wxBitmap_entry, &colour3, php_wxColour_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap3) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap3)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap3)->native_object;
                    object_pointer3_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer3_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(bitmap3) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 2){
                if(Z_TYPE_P(colour3) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxColour_P(colour3)->object_type;
                    argument_native_object = (void*) Z_wxColour_P(colour3)->native_object;
                    object_pointer3_1 = (wxColour*) argument_native_object;
                    if (!object_pointer3_1 )
                    {
                        zend_error(E_ERROR, "Parameter 'colour' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(colour3) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'colour' not null, could not be retreived correctly.");
                }
            }

            overload3_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxMask_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxBitmap*) object_pointer1_0, (int) index1)\n");
                #endif

                native_object = new wxMask_php(*(wxBitmap*) object_pointer1_0, (int) index1);

                native_object->references.Initialize();
                ((wxMask_php*) native_object)->references.AddReference(bitmap1, "wxMask::wxMask at call 4 with 2 argument(s)");
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxBitmap*) object_pointer2_0)\n");
                #endif

                native_object = new wxMask_php(*(wxBitmap*) object_pointer2_0);

                native_object->references.Initialize();
                ((wxMask_php*) native_object)->references.AddReference(bitmap2, "wxMask::wxMask at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    if(overload3_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxBitmap*) object_pointer3_0, *(wxColour*) object_pointer3_1)\n");
                #endif

                native_object = new wxMask_php(*(wxBitmap*) object_pointer3_0, *(wxColour*) object_pointer3_1);

                native_object->references.Initialize();
                ((wxMask_php*) native_object)->references.AddReference(bitmap3, "wxMask::wxMask at call 4 with 2 argument(s)");
                ((wxMask_php*) native_object)->references.AddReference(colour3, "wxMask::wxMask at call 4 with 2 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxMask_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxMask::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxBrush_free(void *object)
{
    zo_wxBrush* custom_object = (zo_wxBrush*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxBrush_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxBrush done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxBrush_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxBrush_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxBrush* custom_object;

    custom_object = (zo_wxBrush*) ecalloc(
        1,
        sizeof(zo_wxBrush)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxBrush_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXBRUSH_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto wxColour wxBrush::GetColour()
   Returns a reference to the brush colour. */
PHP_METHOD(php_wxBrush, GetColour)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBrush::GetColour\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBrush* current_object;
    wxphp_object_type current_object_type;
    wxBrush_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBrush_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBrush::GetColour call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBRUSH_TYPE){
                references = &((wxBrush_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBrush::GetColour() to return new object\n\n");
                #endif

                wxColour value_to_return0;
                value_to_return0 = ((wxBrush_php*)native_object)->GetColour();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxColour));
                object_init_ex(return_value, php_wxColour_entry);
                ((wxColour_php*)ptr)->phpObj = *return_value;
                zo_wxColour* zo0 = Z_wxColour_P(return_value);
                zo0->native_object = (wxColour_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBrush::GetColour\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmap wxBrush::GetStipple()
   Gets a pointer to the stipple bitmap. */
PHP_METHOD(php_wxBrush, GetStipple)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBrush::GetStipple\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBrush* current_object;
    wxphp_object_type current_object_type;
    wxBrush_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBrush_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBrush::GetStipple call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBRUSH_TYPE){
                references = &((wxBrush_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBrush::GetStipple() to return object pointer\n\n");
                #endif

                wxBitmap_php* value_to_return0;
                value_to_return0 = (wxBitmap_php*) ((wxBrush_php*)native_object)->GetStipple();

                if(value_to_return0 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxBitmap_entry);
                    Z_wxBitmap_P(return_value)->native_object = (wxBitmap_php*) value_to_return0;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxBrush::GetStipple at call 5 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBrush::GetStipple\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBrushStyle wxBrush::GetStyle()
   Returns the brush style, one of the wxBrushStyle values. */
PHP_METHOD(php_wxBrush, GetStyle)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBrush::GetStyle\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBrush* current_object;
    wxphp_object_type current_object_type;
    wxBrush_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBrush_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBrush::GetStyle call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBRUSH_TYPE){
                references = &((wxBrush_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxBrush::GetStyle())\n\n");
                #endif

                RETVAL_LONG(((wxBrush_php*)native_object)->GetStyle());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBrush::GetStyle\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxBrush::IsHatch()
   Returns true if the style of the brush is any of hatched fills. */
PHP_METHOD(php_wxBrush, IsHatch)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBrush::IsHatch\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBrush* current_object;
    wxphp_object_type current_object_type;
    wxBrush_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBrush_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBrush::IsHatch call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBRUSH_TYPE){
                references = &((wxBrush_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxBrush::IsHatch())\n\n");
                #endif

                RETVAL_BOOL(((wxBrush_php*)native_object)->IsHatch());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBrush::IsHatch\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxBrush::IsNonTransparent()
   Returns true if the brush is a valid non-transparent brush. */
PHP_METHOD(php_wxBrush, IsNonTransparent)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBrush::IsNonTransparent\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBrush* current_object;
    wxphp_object_type current_object_type;
    wxBrush_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBrush_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBrush::IsNonTransparent call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBRUSH_TYPE){
                references = &((wxBrush_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxBrush::IsNonTransparent())\n\n");
                #endif

                RETVAL_BOOL(((wxBrush_php*)native_object)->IsNonTransparent());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBrush::IsNonTransparent\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxBrush::IsOk()
   Returns true if the brush is initialised. */
PHP_METHOD(php_wxBrush, IsOk)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBrush::IsOk\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBrush* current_object;
    wxphp_object_type current_object_type;
    wxBrush_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBrush_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBrush::IsOk call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBRUSH_TYPE){
                references = &((wxBrush_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxBrush::IsOk())\n\n");
                #endif

                RETVAL_BOOL(((wxBrush_php*)native_object)->IsOk());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBrush::IsOk\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxBrush::IsTransparent()
   Returns true if the brush is transparent. */
PHP_METHOD(php_wxBrush, IsTransparent)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBrush::IsTransparent\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBrush* current_object;
    wxphp_object_type current_object_type;
    wxBrush_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBrush_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBrush::IsTransparent call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBRUSH_TYPE){
                references = &((wxBrush_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxBrush::IsTransparent())\n\n");
                #endif

                RETVAL_BOOL(((wxBrush_php*)native_object)->IsTransparent());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBrush::IsTransparent\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxBrush::SetColour(wxColour colour)
   Sets the brush colour using red, green and blue values. */
PHP_METHOD(php_wxBrush, SetColour)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBrush::SetColour\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBrush* current_object;
    wxphp_object_type current_object_type;
    wxBrush_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBrush_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBrush::SetColour call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBRUSH_TYPE){
                references = &((wxBrush_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* colour0;
    wxColour* object_pointer0_0 = 0;
    bool overload0_called = false;

    //Parameters for overload 1
    long red1;
    long green1;
    long blue1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&colour0, php_wxColour_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &colour0, php_wxColour_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(colour0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxColour_P(colour0)->object_type;
                    argument_native_object = (void*) Z_wxColour_P(colour0)->native_object;
                    object_pointer0_0 = (wxColour*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        goto overload1;
                    }
                }
                else if(Z_TYPE_P(colour0) != IS_NULL)
                {
                    goto overload1;
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'lll' (&red1, &green1, &blue1)\n");
        #endif

        char parse_parameters_string[] = "lll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &red1, &green1, &blue1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBrush::SetColour(*(wxColour*) object_pointer0_0)\n\n");
                #endif

                ((wxBrush_php*)native_object)->SetColour(*(wxColour*) object_pointer0_0);

                references->AddReference(colour0, "wxBrush::SetColour at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBrush::SetColour((unsigned char) red1, (unsigned char) green1, (unsigned char) blue1)\n\n");
                #endif

                ((wxBrush_php*)native_object)->SetColour((unsigned char) red1, (unsigned char) green1, (unsigned char) blue1);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBrush::SetColour\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxBrush::SetStipple(wxBitmap bitmap)
   Sets the stipple bitmap. */
PHP_METHOD(php_wxBrush, SetStipple)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBrush::SetStipple\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBrush* current_object;
    wxphp_object_type current_object_type;
    wxBrush_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBrush_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBrush::SetStipple call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBRUSH_TYPE){
                references = &((wxBrush_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* bitmap0;
    wxBitmap* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&bitmap0, php_wxBitmap_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap0)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap0)->native_object;
                    object_pointer0_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(bitmap0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBrush::SetStipple(*(wxBitmap*) object_pointer0_0)\n\n");
                #endif

                ((wxBrush_php*)native_object)->SetStipple(*(wxBitmap*) object_pointer0_0);

                references->AddReference(bitmap0, "wxBrush::SetStipple at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBrush::SetStipple\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxBrush::SetStyle(wxBrushStyle style)
   Sets the brush style. */
PHP_METHOD(php_wxBrush, SetStyle)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBrush::SetStyle\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBrush* current_object;
    wxphp_object_type current_object_type;
    wxBrush_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxBrush_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxBrush::SetStyle call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXBRUSH_TYPE){
                references = &((wxBrush_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long style0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&style0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &style0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxBrush::SetStyle((wxBrushStyle) style0)\n\n");
                #endif

                ((wxBrush_php*)native_object)->SetStyle((wxBrushStyle) style0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxBrush::SetStyle\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxBrush::wxBrush()
   Default constructor. */
PHP_METHOD(php_wxBrush, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBrush::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBrush* current_object;
    wxBrush_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    zval* colour1;
    wxColour* object_pointer1_0 = 0;
    long style1;
    bool overload1_called = false;

    //Parameters for overload 2
    zval* stippleBitmap2;
    wxBitmap* object_pointer2_0 = 0;
    bool overload2_called = false;

    //Parameters for overload 3
    zval* brush3;
    wxBrush* object_pointer3_0 = 0;
    bool overload3_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O|l' (&colour1, php_wxColour_entry, &style1)\n");
        #endif

        char parse_parameters_string[] = "O|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &colour1, php_wxColour_entry, &style1 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(colour1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxColour_P(colour1)->object_type;
                    argument_native_object = (void*) Z_wxColour_P(colour1)->native_object;
                    object_pointer1_0 = (wxColour*) argument_native_object;
                    if (!object_pointer1_0 )
                    {
                        goto overload2;
                    }
                }
                else if(Z_TYPE_P(colour1) != IS_NULL)
                {
                    goto overload2;
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&stippleBitmap2, php_wxBitmap_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &stippleBitmap2, php_wxBitmap_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(stippleBitmap2) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(stippleBitmap2)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(stippleBitmap2)->native_object;
                    object_pointer2_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer2_0 )
                    {
                        goto overload3;
                    }
                }
                else if(Z_TYPE_P(stippleBitmap2) != IS_NULL)
                {
                    goto overload3;
                }
            }

            overload2_called = true;
            already_called = true;
        }
    }

    //Overload 3
    overload3:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&brush3, php_wxBrush_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &brush3, php_wxBrush_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(brush3) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBrush_P(brush3)->object_type;
                    argument_native_object = (void*) Z_wxBrush_P(brush3)->native_object;
                    object_pointer3_0 = (wxBrush*) argument_native_object;
                    if (!object_pointer3_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'brush' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(brush3) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'brush' not null, could not be retreived correctly.");
                }
            }

            overload3_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxBrush_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxColour*) object_pointer1_0)\n");
                #endif

                native_object = new wxBrush_php(*(wxColour*) object_pointer1_0);

                native_object->references.Initialize();
                ((wxBrush_php*) native_object)->references.AddReference(colour1, "wxBrush::wxBrush at call 4 with 1 argument(s)");
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxColour*) object_pointer1_0, (wxBrushStyle) style1)\n");
                #endif

                native_object = new wxBrush_php(*(wxColour*) object_pointer1_0, (wxBrushStyle) style1);

                native_object->references.Initialize();
                ((wxBrush_php*) native_object)->references.AddReference(colour1, "wxBrush::wxBrush at call 4 with 2 argument(s)");
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxBitmap*) object_pointer2_0)\n");
                #endif

                native_object = new wxBrush_php(*(wxBitmap*) object_pointer2_0);

                native_object->references.Initialize();
                ((wxBrush_php*) native_object)->references.AddReference(stippleBitmap2, "wxBrush::wxBrush at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    if(overload3_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxBrush*) object_pointer3_0)\n");
                #endif

                native_object = new wxBrush_php(*(wxBrush*) object_pointer3_0);

                native_object->references.Initialize();
                ((wxBrush_php*) native_object)->references.AddReference(brush3, "wxBrush::wxBrush at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxBrush_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxBrush::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxColour_free(void *object)
{
    zo_wxColour* custom_object = (zo_wxColour*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxColour_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxColour done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxColour_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxColour_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxColour* custom_object;

    custom_object = (zo_wxColour*) ecalloc(
        1,
        sizeof(zo_wxColour)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxColour_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXCOLOUR_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxColour::wxColour()
   Default constructor. */
PHP_METHOD(php_wxColour, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxColour::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxColour* current_object;
    wxColour_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    long red1;
    long green1;
    long blue1;
    long alpha1;
    bool overload1_called = false;

    //Parameters for overload 2
    char* colourName2;
    size_t colourName_len2;
    bool overload2_called = false;

    //Parameters for overload 3
    long colRGB3;
    bool overload3_called = false;

    //Parameters for overload 4
    zval* colour4;
    wxColour* object_pointer4_0 = 0;
    bool overload4_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 3  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'lll|l' (&red1, &green1, &blue1, &alpha1)\n");
        #endif

        char parse_parameters_string[] = "lll|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &red1, &green1, &blue1, &alpha1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&colourName2, &colourName_len2)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &colourName2, &colourName_len2 ) == SUCCESS)
        {
            overload2_called = true;
            already_called = true;
        }
    }

    //Overload 3
    overload3:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&colRGB3)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &colRGB3 ) == SUCCESS)
        {
            overload3_called = true;
            already_called = true;
        }
    }

    //Overload 4
    overload4:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&colour4, php_wxColour_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &colour4, php_wxColour_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(colour4) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxColour_P(colour4)->object_type;
                    argument_native_object = (void*) Z_wxColour_P(colour4)->native_object;
                    object_pointer4_0 = (wxColour*) argument_native_object;
                    if (!object_pointer4_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'colour' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(colour4) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'colour' not null, could not be retreived correctly.");
                }
            }

            overload4_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxColour_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((unsigned char) red1, (unsigned char) green1, (unsigned char) blue1)\n");
                #endif

                native_object = new wxColour_php((unsigned char) red1, (unsigned char) green1, (unsigned char) blue1);

                native_object->references.Initialize();
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((unsigned char) red1, (unsigned char) green1, (unsigned char) blue1, (unsigned char) alpha1)\n");
                #endif

                native_object = new wxColour_php((unsigned char) red1, (unsigned char) green1, (unsigned char) blue1, (unsigned char) alpha1);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(colourName2, wxConvUTF8))\n");
                #endif

                native_object = new wxColour_php(wxString(colourName2, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload3_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((unsigned long) colRGB3)\n");
                #endif

                native_object = new wxColour_php((unsigned long) colRGB3);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload4_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxColour*) object_pointer4_0)\n");
                #endif

                native_object = new wxColour_php(*(wxColour*) object_pointer4_0);

                native_object->references.Initialize();
                ((wxColour_php*) native_object)->references.AddReference(colour4, "wxColour::wxColour at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxColour_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxColour::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto  wxColour::Set(int red, int green, int blue, int alpha)
   Sets the RGB intensity values using the given values (first overload), extracting them from the packed long (second overload), using the given string (third overload). */
PHP_METHOD(php_wxColour, Set)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxColour::Set\n");
    php_printf("===========================================\n");
    #endif

    zo_wxColour* current_object;
    wxphp_object_type current_object_type;
    wxColour_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxColour_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxColour::Set call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCOLOUR_TYPE){
                references = &((wxColour_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long red0;
    long green0;
    long blue0;
    long alpha0;
    bool overload0_called = false;

    //Parameters for overload 1
    long RGB1;
    bool overload1_called = false;

    //Parameters for overload 2
    char* str2;
    size_t str_len2;
    bool overload2_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 3  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'lll|l' (&red0, &green0, &blue0, &alpha0)\n");
        #endif

        char parse_parameters_string[] = "lll|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &red0, &green0, &blue0, &alpha0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&RGB1)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &RGB1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&str2, &str_len2)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &str2, &str_len2 ) == SUCCESS)
        {
            overload2_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxColour::Set((unsigned char) red0, (unsigned char) green0, (unsigned char) blue0)\n\n");
                #endif

                ((wxColour_php*)native_object)->Set((unsigned char) red0, (unsigned char) green0, (unsigned char) blue0);


                return;
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxColour::Set((unsigned char) red0, (unsigned char) green0, (unsigned char) blue0, (unsigned char) alpha0)\n\n");
                #endif

                ((wxColour_php*)native_object)->Set((unsigned char) red0, (unsigned char) green0, (unsigned char) blue0, (unsigned char) alpha0);


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxColour::Set((unsigned long) RGB1)\n\n");
                #endif

                ((wxColour_php*)native_object)->Set((unsigned long) RGB1);


                return;
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxColour::Set(wxString(str2, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxColour_php*)native_object)->Set(wxString(str2, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxColour::Set\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxColour::Red()
   Returns the red intensity. */
PHP_METHOD(php_wxColour, Red)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxColour::Red\n");
    php_printf("===========================================\n");
    #endif

    zo_wxColour* current_object;
    wxphp_object_type current_object_type;
    wxColour_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxColour_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxColour::Red call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCOLOUR_TYPE){
                references = &((wxColour_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxColour::Red())\n\n");
                #endif

                RETVAL_LONG(((wxColour_php*)native_object)->Red());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxColour::Red\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxColour::SetRGB(int colRGB)
   Sets the RGB or RGBA colour values from a single 32 bit value. */
PHP_METHOD(php_wxColour, SetRGB)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxColour::SetRGB\n");
    php_printf("===========================================\n");
    #endif

    zo_wxColour* current_object;
    wxphp_object_type current_object_type;
    wxColour_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxColour_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxColour::SetRGB call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCOLOUR_TYPE){
                references = &((wxColour_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long colRGB0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&colRGB0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &colRGB0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxColour::SetRGB((wxUint32) colRGB0)\n\n");
                #endif

                ((wxColour_php*)native_object)->SetRGB((wxUint32) colRGB0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxColour::SetRGB\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxColour::SetRGBA(int colRGBA)
   Sets the RGB or RGBA colour values from a single 32 bit value. */
PHP_METHOD(php_wxColour, SetRGBA)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxColour::SetRGBA\n");
    php_printf("===========================================\n");
    #endif

    zo_wxColour* current_object;
    wxphp_object_type current_object_type;
    wxColour_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxColour_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxColour::SetRGBA call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCOLOUR_TYPE){
                references = &((wxColour_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long colRGBA0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&colRGBA0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &colRGBA0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxColour::SetRGBA((wxUint32) colRGBA0)\n\n");
                #endif

                ((wxColour_php*)native_object)->SetRGBA((wxUint32) colRGBA0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxColour::SetRGBA\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxColour::Blue()
   Returns the blue intensity. */
PHP_METHOD(php_wxColour, Blue)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxColour::Blue\n");
    php_printf("===========================================\n");
    #endif

    zo_wxColour* current_object;
    wxphp_object_type current_object_type;
    wxColour_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxColour_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxColour::Blue call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCOLOUR_TYPE){
                references = &((wxColour_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxColour::Blue())\n\n");
                #endif

                RETVAL_LONG(((wxColour_php*)native_object)->Blue());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxColour::Blue\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxColour::Green()
   Returns the green intensity. */
PHP_METHOD(php_wxColour, Green)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxColour::Green\n");
    php_printf("===========================================\n");
    #endif

    zo_wxColour* current_object;
    wxphp_object_type current_object_type;
    wxColour_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxColour_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxColour::Green call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCOLOUR_TYPE){
                references = &((wxColour_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxColour::Green())\n\n");
                #endif

                RETVAL_LONG(((wxColour_php*)native_object)->Green());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxColour::Green\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxColour::GetRGBA()
   Gets the RGB or RGBA colour values as a single 32 bit value. */
PHP_METHOD(php_wxColour, GetRGBA)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxColour::GetRGBA\n");
    php_printf("===========================================\n");
    #endif

    zo_wxColour* current_object;
    wxphp_object_type current_object_type;
    wxColour_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxColour_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxColour::GetRGBA call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCOLOUR_TYPE){
                references = &((wxColour_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxColour::GetRGBA())\n\n");
                #endif

                RETVAL_LONG(((wxColour_php*)native_object)->GetRGBA());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxColour::GetRGBA\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxColour::GetRGB()
   Gets the RGB or RGBA colour values as a single 32 bit value. */
PHP_METHOD(php_wxColour, GetRGB)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxColour::GetRGB\n");
    php_printf("===========================================\n");
    #endif

    zo_wxColour* current_object;
    wxphp_object_type current_object_type;
    wxColour_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxColour_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxColour::GetRGB call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCOLOUR_TYPE){
                references = &((wxColour_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxColour::GetRGB())\n\n");
                #endif

                RETVAL_LONG(((wxColour_php*)native_object)->GetRGB());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxColour::GetRGB\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxColour::Alpha()
   Returns the alpha value, on platforms where alpha is not yet supported, this always returns wxALPHA_OPAQUE. */
PHP_METHOD(php_wxColour, Alpha)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxColour::Alpha\n");
    php_printf("===========================================\n");
    #endif

    zo_wxColour* current_object;
    wxphp_object_type current_object_type;
    wxColour_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxColour_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxColour::Alpha call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCOLOUR_TYPE){
                references = &((wxColour_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxColour::Alpha())\n\n");
                #endif

                RETVAL_LONG(((wxColour_php*)native_object)->Alpha());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxColour::Alpha\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxCursor_free(void *object)
{
    zo_wxCursor* custom_object = (zo_wxCursor*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxCursor_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxCursor done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxCursor_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxCursor_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxCursor* custom_object;

    custom_object = (zo_wxCursor*) ecalloc(
        1,
        sizeof(zo_wxCursor)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxCursor_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXCURSOR_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto bool wxCursor::IsOk()
   Returns true if cursor data is present. */
PHP_METHOD(php_wxCursor, IsOk)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxCursor::IsOk\n");
    php_printf("===========================================\n");
    #endif

    zo_wxCursor* current_object;
    wxphp_object_type current_object_type;
    wxCursor_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxCursor_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxCursor::IsOk call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCURSOR_TYPE){
                references = &((wxCursor_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxCursor::IsOk())\n\n");
                #endif

                RETVAL_BOOL(((wxCursor_php*)native_object)->IsOk());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxCursor::IsOk\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxCursor::wxCursor()
   Default constructor. */
PHP_METHOD(php_wxCursor, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxCursor::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxCursor* current_object;
    wxCursor_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    char* cursorName1;
    size_t cursorName_len1;
    long type1;
    long hotSpotX1;
    long hotSpotY1;
    bool overload1_called = false;

    //Parameters for overload 2
    long cursorId2;
    bool overload2_called = false;

    //Parameters for overload 3
    zval* image3;
    wxImage* object_pointer3_0 = 0;
    bool overload3_called = false;

    //Parameters for overload 4
    zval* cursor4;
    wxCursor* object_pointer4_0 = 0;
    bool overload4_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 1  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|lll' (&cursorName1, &cursorName_len1, &type1, &hotSpotX1, &hotSpotY1)\n");
        #endif

        char parse_parameters_string[] = "s|lll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &cursorName1, &cursorName_len1, &type1, &hotSpotX1, &hotSpotY1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&cursorId2)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &cursorId2 ) == SUCCESS)
        {
            overload2_called = true;
            already_called = true;
        }
    }

    //Overload 3
    overload3:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&image3, php_wxImage_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &image3, php_wxImage_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(image3) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxImage_P(image3)->object_type;
                    argument_native_object = (void*) Z_wxImage_P(image3)->native_object;
                    object_pointer3_0 = (wxImage*) argument_native_object;
                    if (!object_pointer3_0 )
                    {
                        goto overload4;
                    }
                }
                else if(Z_TYPE_P(image3) != IS_NULL)
                {
                    goto overload4;
                }
            }

            overload3_called = true;
            already_called = true;
        }
    }

    //Overload 4
    overload4:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&cursor4, php_wxCursor_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &cursor4, php_wxCursor_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(cursor4) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxCursor_P(cursor4)->object_type;
                    argument_native_object = (void*) Z_wxCursor_P(cursor4)->native_object;
                    object_pointer4_0 = (wxCursor*) argument_native_object;
                    if (!object_pointer4_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'cursor' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(cursor4) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'cursor' not null, could not be retreived correctly.");
                }
            }

            overload4_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxCursor_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(cursorName1, wxConvUTF8))\n");
                #endif

                native_object = new wxCursor_php(wxString(cursorName1, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(cursorName1, wxConvUTF8), (wxBitmapType) type1)\n");
                #endif

                native_object = new wxCursor_php(wxString(cursorName1, wxConvUTF8), (wxBitmapType) type1);

                native_object->references.Initialize();
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(cursorName1, wxConvUTF8), (wxBitmapType) type1, (int) hotSpotX1)\n");
                #endif

                native_object = new wxCursor_php(wxString(cursorName1, wxConvUTF8), (wxBitmapType) type1, (int) hotSpotX1);

                native_object->references.Initialize();
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(cursorName1, wxConvUTF8), (wxBitmapType) type1, (int) hotSpotX1, (int) hotSpotY1)\n");
                #endif

                native_object = new wxCursor_php(wxString(cursorName1, wxConvUTF8), (wxBitmapType) type1, (int) hotSpotX1, (int) hotSpotY1);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxStockCursor) cursorId2)\n");
                #endif

                native_object = new wxCursor_php((wxStockCursor) cursorId2);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload3_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxImage*) object_pointer3_0)\n");
                #endif

                native_object = new wxCursor_php(*(wxImage*) object_pointer3_0);

                native_object->references.Initialize();
                ((wxCursor_php*) native_object)->references.AddReference(image3, "wxCursor::wxCursor at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    if(overload4_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxCursor*) object_pointer4_0)\n");
                #endif

                native_object = new wxCursor_php(*(wxCursor*) object_pointer4_0);

                native_object->references.Initialize();
                ((wxCursor_php*) native_object)->references.AddReference(cursor4, "wxCursor::wxCursor at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxCursor_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxCursor::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxDCClipper_free(void *object)
{
    zo_wxDCClipper* custom_object = (zo_wxDCClipper*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxDCClipper_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxDCClipper done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxDCClipper_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxDCClipper_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxDCClipper* custom_object;

    custom_object = (zo_wxDCClipper*) ecalloc(
        1,
        sizeof(zo_wxDCClipper)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxDCClipper_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXDCCLIPPER_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxDCClipper::wxDCClipper(wxDC &dc, wxRegion region)
   Sets the clipping region to the specified region/coordinates. */
PHP_METHOD(php_wxDCClipper, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDCClipper::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDCClipper* current_object;
    wxDCClipper_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    zval* dc0;
    wxDC* object_pointer0_0 = 0;
    zval* region0;
    wxRegion* object_pointer0_1 = 0;
    bool overload0_called = false;

    //Parameters for overload 1
    zval* dc1;
    wxDC* object_pointer1_0 = 0;
    zval* rect1;
    wxRect* object_pointer1_1 = 0;
    bool overload1_called = false;

    //Parameters for overload 2
    zval* dc2;
    wxDC* object_pointer2_0 = 0;
    long x2;
    long y2;
    long w2;
    long h2;
    bool overload2_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'oO' (&dc0, &region0, php_wxRegion_entry)\n");
        #endif

        char parse_parameters_string[] = "oO";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &dc0, &region0, php_wxRegion_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(dc0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxDC_P(dc0)->object_type;
                    argument_native_object = (void*) Z_wxDC_P(dc0)->native_object;
                    object_pointer0_0 = (wxDC*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
                    {
                        goto overload1;
                    }
                }
                else if(Z_TYPE_P(dc0) != IS_NULL)
                {
                    goto overload1;
                }
            }

            if(arguments_received >= 2){
                if(Z_TYPE_P(region0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxRegion_P(region0)->object_type;
                    argument_native_object = (void*) Z_wxRegion_P(region0)->native_object;
                    object_pointer0_1 = (wxRegion*) argument_native_object;
                    if (!object_pointer0_1 )
                    {
                        goto overload1;
                    }
                }
                else if(Z_TYPE_P(region0) != IS_NULL)
                {
                    goto overload1;
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'oO' (&dc1, &rect1, php_wxRect_entry)\n");
        #endif

        char parse_parameters_string[] = "oO";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &dc1, &rect1, php_wxRect_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(dc1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxDC_P(dc1)->object_type;
                    argument_native_object = (void*) Z_wxDC_P(dc1)->native_object;
                    object_pointer1_0 = (wxDC*) argument_native_object;
                    if (!object_pointer1_0 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
                    {
                        goto overload2;
                    }
                }
                else if(Z_TYPE_P(dc1) != IS_NULL)
                {
                    goto overload2;
                }
            }

            if(arguments_received >= 2){
                if(Z_TYPE_P(rect1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxRect_P(rect1)->object_type;
                    argument_native_object = (void*) Z_wxRect_P(rect1)->native_object;
                    object_pointer1_1 = (wxRect*) argument_native_object;
                    if (!object_pointer1_1 )
                    {
                        goto overload2;
                    }
                }
                else if(Z_TYPE_P(rect1) != IS_NULL)
                {
                    goto overload2;
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 5)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ollll' (&dc2, &x2, &y2, &w2, &h2)\n");
        #endif

        char parse_parameters_string[] = "ollll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &dc2, &x2, &y2, &w2, &h2 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(dc2) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxDC_P(dc2)->object_type;
                    argument_native_object = (void*) Z_wxDC_P(dc2)->native_object;
                    object_pointer2_0 = (wxDC*) argument_native_object;
                    if (!object_pointer2_0 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(dc2) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
                }
            }

            overload2_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxDC*) object_pointer0_0, *(wxRegion*) object_pointer0_1)\n");
                #endif

                native_object = new wxDCClipper_php(*(wxDC*) object_pointer0_0, *(wxRegion*) object_pointer0_1);

                native_object->references.Initialize();
                ((wxDCClipper_php*) native_object)->references.AddReference(dc0, "wxDCClipper::wxDCClipper at call 4 with 2 argument(s)");
                ((wxDCClipper_php*) native_object)->references.AddReference(region0, "wxDCClipper::wxDCClipper at call 4 with 2 argument(s)");
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxDC*) object_pointer1_0, *(wxRect*) object_pointer1_1)\n");
                #endif

                native_object = new wxDCClipper_php(*(wxDC*) object_pointer1_0, *(wxRect*) object_pointer1_1);

                native_object->references.Initialize();
                ((wxDCClipper_php*) native_object)->references.AddReference(dc1, "wxDCClipper::wxDCClipper at call 4 with 2 argument(s)");
                ((wxDCClipper_php*) native_object)->references.AddReference(rect1, "wxDCClipper::wxDCClipper at call 4 with 2 argument(s)");
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxDC*) object_pointer2_0, (wxCoord) x2, (wxCoord) y2, (wxCoord) w2, (wxCoord) h2)\n");
                #endif

                native_object = new wxDCClipper_php(*(wxDC*) object_pointer2_0, (wxCoord) x2, (wxCoord) y2, (wxCoord) w2, (wxCoord) h2);

                native_object->references.Initialize();
                ((wxDCClipper_php*) native_object)->references.AddReference(dc2, "wxDCClipper::wxDCClipper at call 4 with 5 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxDCClipper_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxDCClipper::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFont_free(void *object)
{
    zo_wxFont* custom_object = (zo_wxFont*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFont_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxFont done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxFont_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFont_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxFont* custom_object;

    custom_object = (zo_wxFont*) ecalloc(
        1,
        sizeof(zo_wxFont)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxFont_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFONT_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxFont::wxFont()
   Default ctor. */
PHP_METHOD(php_wxFont, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    zval* font1;
    wxFont* object_pointer1_0 = 0;
    bool overload1_called = false;

    //Parameters for overload 2
    long pointSize2;
    long family2;
    long style2;
    long weight2;
    bool underline2;
    char* faceName2;
    size_t faceName_len2;
    long encoding2;
    bool overload2_called = false;

    //Parameters for overload 3
    zval* pixelSize3;
    wxSize* object_pointer3_0 = 0;
    long family3;
    long style3;
    long weight3;
    bool underline3;
    char* faceName3;
    size_t faceName_len3;
    long encoding3;
    bool overload3_called = false;

    //Parameters for overload 4
    char* nativeInfoString4;
    size_t nativeInfoString_len4;
    bool overload4_called = false;

    //Parameters for overload 5
    zval* nativeInfo5;
    wxNativeFontInfo* object_pointer5_0 = 0;
    bool overload5_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&font1, php_wxFont_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &font1, php_wxFont_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(font1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxFont_P(font1)->object_type;
                    argument_native_object = (void*) Z_wxFont_P(font1)->native_object;
                    object_pointer1_0 = (wxFont*) argument_native_object;
                    if (!object_pointer1_0 )
                    {
                        goto overload2;
                    }
                }
                else if(Z_TYPE_P(font1) != IS_NULL)
                {
                    goto overload2;
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received >= 4  && arguments_received <= 7)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'llll|bsl' (&pointSize2, &family2, &style2, &weight2, &underline2, &faceName2, &faceName_len2, &encoding2)\n");
        #endif

        char parse_parameters_string[] = "llll|bsl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pointSize2, &family2, &style2, &weight2, &underline2, &faceName2, &faceName_len2, &encoding2 ) == SUCCESS)
        {
            overload2_called = true;
            already_called = true;
        }
    }

    //Overload 3
    overload3:
    if(!already_called && arguments_received >= 4  && arguments_received <= 7)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'Olll|bsl' (&pixelSize3, php_wxSize_entry, &family3, &style3, &weight3, &underline3, &faceName3, &faceName_len3, &encoding3)\n");
        #endif

        char parse_parameters_string[] = "Olll|bsl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pixelSize3, php_wxSize_entry, &family3, &style3, &weight3, &underline3, &faceName3, &faceName_len3, &encoding3 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(pixelSize3) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(pixelSize3)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(pixelSize3)->native_object;
                    object_pointer3_0 = (wxSize*) argument_native_object;
                    if (!object_pointer3_0 )
                    {
                        goto overload4;
                    }
                }
                else if(Z_TYPE_P(pixelSize3) != IS_NULL)
                {
                    goto overload4;
                }
            }

            overload3_called = true;
            already_called = true;
        }
    }

    //Overload 4
    overload4:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&nativeInfoString4, &nativeInfoString_len4)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &nativeInfoString4, &nativeInfoString_len4 ) == SUCCESS)
        {
            overload4_called = true;
            already_called = true;
        }
    }

    //Overload 5
    overload5:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&nativeInfo5, php_wxNativeFontInfo_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &nativeInfo5, php_wxNativeFontInfo_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(nativeInfo5) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxNativeFontInfo_P(nativeInfo5)->object_type;
                    argument_native_object = (void*) Z_wxNativeFontInfo_P(nativeInfo5)->native_object;
                    object_pointer5_0 = (wxNativeFontInfo*) argument_native_object;
                    if (!object_pointer5_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'nativeInfo' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(nativeInfo5) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'nativeInfo' not null, could not be retreived correctly.");
                }
            }

            overload5_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxFont_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxFont*) object_pointer1_0)\n");
                #endif

                native_object = new wxFont_php(*(wxFont*) object_pointer1_0);

                native_object->references.Initialize();
                ((wxFont_php*) native_object)->references.AddReference(font1, "wxFont::wxFont at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) pointSize2, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2)\n");
                #endif

                native_object = new wxFont_php((int) pointSize2, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2);

                native_object->references.Initialize();
                break;
            }
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) pointSize2, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2)\n");
                #endif

                native_object = new wxFont_php((int) pointSize2, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2);

                native_object->references.Initialize();
                break;
            }
            case 6:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) pointSize2, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2, wxString(faceName2, wxConvUTF8))\n");
                #endif

                native_object = new wxFont_php((int) pointSize2, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2, wxString(faceName2, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
            case 7:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) pointSize2, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2, wxString(faceName2, wxConvUTF8), (wxFontEncoding) encoding2)\n");
                #endif

                native_object = new wxFont_php((int) pointSize2, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2, wxString(faceName2, wxConvUTF8), (wxFontEncoding) encoding2);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload3_called)
    {
        switch(arguments_received)
        {
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (wxFontStyle) style3, (wxFontWeight) weight3)\n");
                #endif

                native_object = new wxFont_php(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (wxFontStyle) style3, (wxFontWeight) weight3);

                native_object->references.Initialize();
                ((wxFont_php*) native_object)->references.AddReference(pixelSize3, "wxFont::wxFont at call 4 with 4 argument(s)");
                break;
            }
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (wxFontStyle) style3, (wxFontWeight) weight3, underline3)\n");
                #endif

                native_object = new wxFont_php(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (wxFontStyle) style3, (wxFontWeight) weight3, underline3);

                native_object->references.Initialize();
                ((wxFont_php*) native_object)->references.AddReference(pixelSize3, "wxFont::wxFont at call 4 with 5 argument(s)");
                break;
            }
            case 6:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (wxFontStyle) style3, (wxFontWeight) weight3, underline3, wxString(faceName3, wxConvUTF8))\n");
                #endif

                native_object = new wxFont_php(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (wxFontStyle) style3, (wxFontWeight) weight3, underline3, wxString(faceName3, wxConvUTF8));

                native_object->references.Initialize();
                ((wxFont_php*) native_object)->references.AddReference(pixelSize3, "wxFont::wxFont at call 4 with 6 argument(s)");
                break;
            }
            case 7:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (wxFontStyle) style3, (wxFontWeight) weight3, underline3, wxString(faceName3, wxConvUTF8), (wxFontEncoding) encoding3)\n");
                #endif

                native_object = new wxFont_php(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (wxFontStyle) style3, (wxFontWeight) weight3, underline3, wxString(faceName3, wxConvUTF8), (wxFontEncoding) encoding3);

                native_object->references.Initialize();
                ((wxFont_php*) native_object)->references.AddReference(pixelSize3, "wxFont::wxFont at call 4 with 7 argument(s)");
                break;
            }
        }
    }

    if(overload4_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(nativeInfoString4, wxConvUTF8))\n");
                #endif

                native_object = new wxFont_php(wxString(nativeInfoString4, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload5_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxNativeFontInfo*) object_pointer5_0)\n");
                #endif

                native_object = new wxFont_php(*(wxNativeFontInfo*) object_pointer5_0);

                native_object->references.Initialize();
                ((wxFont_php*) native_object)->references.AddReference(nativeInfo5, "wxFont::wxFont at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxFont_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxFont::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto wxFont wxFont::Bold()
   Returns a bold version of this font. */
PHP_METHOD(php_wxFont, Bold)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::Bold\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::Bold call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::Bold() to return new object\n\n");
                #endif

                wxFont value_to_return0;
                value_to_return0 = ((wxFont_php*)native_object)->Bold();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxFont_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxFont));
                object_init_ex(return_value, php_wxFont_entry);
                ((wxFont_php*)ptr)->phpObj = *return_value;
                zo_wxFont* zo0 = Z_wxFont_P(return_value);
                zo0->native_object = (wxFont_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::Bold\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFontEncoding wxFont::GetDefaultEncoding()
   Returns the current application's default encoding. */
PHP_METHOD(php_wxFont, GetDefaultEncoding)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::GetDefaultEncoding\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::GetDefaultEncoding call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_LONG(wxFont::GetDefaultEncoding())\n\n");
                #endif

                RETVAL_LONG(wxFont::GetDefaultEncoding());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::GetDefaultEncoding\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFontEncoding wxFont::GetEncoding()
   Returns the encoding of this font. */
PHP_METHOD(php_wxFont, GetEncoding)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::GetEncoding\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::GetEncoding call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFont::GetEncoding())\n\n");
                #endif

                RETVAL_LONG(((wxFont_php*)native_object)->GetEncoding());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::GetEncoding\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFont::GetFaceName()
   Returns the face name associated with the font, or the empty string if there is no face information. */
PHP_METHOD(php_wxFont, GetFaceName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::GetFaceName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::GetFaceName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFont::GetFaceName().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxFont_php*)native_object)->GetFaceName();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::GetFaceName\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFontFamily wxFont::GetFamily()
   Gets the font family if possible. */
PHP_METHOD(php_wxFont, GetFamily)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::GetFamily\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::GetFamily call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFont::GetFamily())\n\n");
                #endif

                RETVAL_LONG(((wxFont_php*)native_object)->GetFamily());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::GetFamily\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFont::GetNativeFontInfoDesc()
   Returns the platform-dependent string completely describing this font. */
PHP_METHOD(php_wxFont, GetNativeFontInfoDesc)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::GetNativeFontInfoDesc\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::GetNativeFontInfoDesc call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFont::GetNativeFontInfoDesc().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxFont_php*)native_object)->GetNativeFontInfoDesc();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::GetNativeFontInfoDesc\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFont::GetNativeFontInfoUserDesc()
   Returns a user-friendly string for this font object. */
PHP_METHOD(php_wxFont, GetNativeFontInfoUserDesc)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::GetNativeFontInfoUserDesc\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::GetNativeFontInfoUserDesc call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFont::GetNativeFontInfoUserDesc().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxFont_php*)native_object)->GetNativeFontInfoUserDesc();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::GetNativeFontInfoUserDesc\n"
        );
    }
}
/* }}} */

/* {{{ proto wxSize wxFont::GetPixelSize()
   Gets the pixel size. */
PHP_METHOD(php_wxFont, GetPixelSize)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::GetPixelSize\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::GetPixelSize call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::GetPixelSize() to return new object\n\n");
                #endif

                wxSize value_to_return0;
                value_to_return0 = ((wxFont_php*)native_object)->GetPixelSize();
                void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxSize));
                object_init_ex(return_value, php_wxSize_entry);
                ((wxSize_php*)ptr)->phpObj = *return_value;
                zo_wxSize* zo0 = Z_wxSize_P(return_value);
                zo0->native_object = (wxSize_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::GetPixelSize\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxFont::GetPointSize()
   Gets the point size as an integer number. */
PHP_METHOD(php_wxFont, GetPointSize)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::GetPointSize\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::GetPointSize call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFont::GetPointSize())\n\n");
                #endif

                RETVAL_LONG(((wxFont_php*)native_object)->GetPointSize());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::GetPointSize\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFontStyle wxFont::GetStyle()
   Gets the font style. */
PHP_METHOD(php_wxFont, GetStyle)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::GetStyle\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::GetStyle call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFont::GetStyle())\n\n");
                #endif

                RETVAL_LONG(((wxFont_php*)native_object)->GetStyle());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::GetStyle\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFont::GetUnderlined()
   Returns true if the font is underlined, false otherwise. */
PHP_METHOD(php_wxFont, GetUnderlined)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::GetUnderlined\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::GetUnderlined call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFont::GetUnderlined())\n\n");
                #endif

                RETVAL_BOOL(((wxFont_php*)native_object)->GetUnderlined());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::GetUnderlined\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFontWeight wxFont::GetWeight()
   Gets the font weight. */
PHP_METHOD(php_wxFont, GetWeight)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::GetWeight\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::GetWeight call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFont::GetWeight())\n\n");
                #endif

                RETVAL_LONG(((wxFont_php*)native_object)->GetWeight());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::GetWeight\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFont::IsFixedWidth()
   Returns true if the font is a fixed width (or monospaced) font, false if it is a proportional one or font is invalid. */
PHP_METHOD(php_wxFont, IsFixedWidth)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::IsFixedWidth\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::IsFixedWidth call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFont::IsFixedWidth())\n\n");
                #endif

                RETVAL_BOOL(((wxFont_php*)native_object)->IsFixedWidth());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::IsFixedWidth\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFont::IsOk()
   Returns true if this object is a valid font, false otherwise. */
PHP_METHOD(php_wxFont, IsOk)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::IsOk\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::IsOk call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFont::IsOk())\n\n");
                #endif

                RETVAL_BOOL(((wxFont_php*)native_object)->IsOk());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::IsOk\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFont wxFont::Italic()
   Returns an italic version of this font. */
PHP_METHOD(php_wxFont, Italic)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::Italic\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::Italic call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::Italic() to return new object\n\n");
                #endif

                wxFont value_to_return0;
                value_to_return0 = ((wxFont_php*)native_object)->Italic();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxFont_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxFont));
                object_init_ex(return_value, php_wxFont_entry);
                ((wxFont_php*)ptr)->phpObj = *return_value;
                zo_wxFont* zo0 = Z_wxFont_P(return_value);
                zo0->native_object = (wxFont_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::Italic\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFont wxFont::Larger()
   Returns a larger version of this font. */
PHP_METHOD(php_wxFont, Larger)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::Larger\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::Larger call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::Larger() to return new object\n\n");
                #endif

                wxFont value_to_return0;
                value_to_return0 = ((wxFont_php*)native_object)->Larger();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxFont_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxFont));
                object_init_ex(return_value, php_wxFont_entry);
                ((wxFont_php*)ptr)->phpObj = *return_value;
                zo_wxFont* zo0 = Z_wxFont_P(return_value);
                zo0->native_object = (wxFont_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::Larger\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFont wxFont::MakeBold()
   Changes this font to be bold. */
PHP_METHOD(php_wxFont, MakeBold)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::MakeBold\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::MakeBold call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::MakeBold() to return object reference\n\n");
                #endif

                wxFont_php* value_to_return0;
                value_to_return0 = (wxFont_php*) &((wxFont_php*)native_object)->MakeBold();

                if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return0;
                }

                if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxFont::MakeBold at call 6 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::MakeBold\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFont wxFont::MakeItalic()
   Changes this font to be italic. */
PHP_METHOD(php_wxFont, MakeItalic)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::MakeItalic\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::MakeItalic call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::MakeItalic() to return object reference\n\n");
                #endif

                wxFont_php* value_to_return0;
                value_to_return0 = (wxFont_php*) &((wxFont_php*)native_object)->MakeItalic();

                if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return0;
                }

                if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxFont::MakeItalic at call 6 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::MakeItalic\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFont wxFont::MakeLarger()
   Changes this font to be larger. */
PHP_METHOD(php_wxFont, MakeLarger)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::MakeLarger\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::MakeLarger call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::MakeLarger() to return object reference\n\n");
                #endif

                wxFont_php* value_to_return0;
                value_to_return0 = (wxFont_php*) &((wxFont_php*)native_object)->MakeLarger();

                if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return0;
                }

                if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxFont::MakeLarger at call 6 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::MakeLarger\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFont wxFont::MakeSmaller()
   Changes this font to be smaller. */
PHP_METHOD(php_wxFont, MakeSmaller)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::MakeSmaller\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::MakeSmaller call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::MakeSmaller() to return object reference\n\n");
                #endif

                wxFont_php* value_to_return0;
                value_to_return0 = (wxFont_php*) &((wxFont_php*)native_object)->MakeSmaller();

                if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return0;
                }

                if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxFont::MakeSmaller at call 6 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::MakeSmaller\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFont wxFont::MakeUnderlined()
   Changes this font to be underlined. */
PHP_METHOD(php_wxFont, MakeUnderlined)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::MakeUnderlined\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::MakeUnderlined call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::MakeUnderlined() to return object reference\n\n");
                #endif

                wxFont_php* value_to_return0;
                value_to_return0 = (wxFont_php*) &((wxFont_php*)native_object)->MakeUnderlined();

                if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return0;
                }

                if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxFont::MakeUnderlined at call 6 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::MakeUnderlined\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFont wxFont::New(int pointSize, wxFontFamily family, wxFontStyle style, wxFontWeight weight, bool underline, string faceName, wxFontEncoding encoding)
   This function takes the same parameters as the relative wxFont constructor and returns a new font object allocated on the heap. */
PHP_METHOD(php_wxFont, NewMethod)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::New\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::New call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long pointSize0;
    long family0;
    long style0;
    long weight0;
    bool underline0;
    char* faceName0;
    size_t faceName_len0;
    long encoding0;
    bool overload0_called = false;

    //Parameters for overload 1
    long pointSize1;
    long family1;
    long flags1;
    char* faceName1;
    size_t faceName_len1;
    long encoding1;
    bool overload1_called = false;

    //Parameters for overload 2
    zval* pixelSize2;
    wxSize* object_pointer2_0 = 0;
    long family2;
    long style2;
    long weight2;
    bool underline2;
    char* faceName2;
    size_t faceName_len2;
    long encoding2;
    bool overload2_called = false;

    //Parameters for overload 3
    zval* pixelSize3;
    wxSize* object_pointer3_0 = 0;
    long family3;
    long flags3;
    char* faceName3;
    size_t faceName_len3;
    long encoding3;
    bool overload3_called = false;

    //Parameters for overload 4
    zval* nativeInfo4;
    wxNativeFontInfo* object_pointer4_0 = 0;
    bool overload4_called = false;

    //Parameters for overload 5
    char* nativeInfoString5;
    size_t nativeInfoString_len5;
    bool overload5_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 4  && arguments_received <= 7)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'llll|bsl' (&pointSize0, &family0, &style0, &weight0, &underline0, &faceName0, &faceName_len0, &encoding0)\n");
        #endif

        char parse_parameters_string[] = "llll|bsl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pointSize0, &family0, &style0, &weight0, &underline0, &faceName0, &faceName_len0, &encoding0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 2  && arguments_received <= 5)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll|lsl' (&pointSize1, &family1, &flags1, &faceName1, &faceName_len1, &encoding1)\n");
        #endif

        char parse_parameters_string[] = "ll|lsl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pointSize1, &family1, &flags1, &faceName1, &faceName_len1, &encoding1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received >= 4  && arguments_received <= 7)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'Olll|bsl' (&pixelSize2, php_wxSize_entry, &family2, &style2, &weight2, &underline2, &faceName2, &faceName_len2, &encoding2)\n");
        #endif

        char parse_parameters_string[] = "Olll|bsl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pixelSize2, php_wxSize_entry, &family2, &style2, &weight2, &underline2, &faceName2, &faceName_len2, &encoding2 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(pixelSize2) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(pixelSize2)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(pixelSize2)->native_object;
                    object_pointer2_0 = (wxSize*) argument_native_object;
                    if (!object_pointer2_0 )
                    {
                        goto overload3;
                    }
                }
                else if(Z_TYPE_P(pixelSize2) != IS_NULL)
                {
                    goto overload3;
                }
            }

            overload2_called = true;
            already_called = true;
        }
    }

    //Overload 3
    overload3:
    if(!already_called && arguments_received >= 2  && arguments_received <= 5)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'Ol|lsl' (&pixelSize3, php_wxSize_entry, &family3, &flags3, &faceName3, &faceName_len3, &encoding3)\n");
        #endif

        char parse_parameters_string[] = "Ol|lsl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pixelSize3, php_wxSize_entry, &family3, &flags3, &faceName3, &faceName_len3, &encoding3 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(pixelSize3) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(pixelSize3)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(pixelSize3)->native_object;
                    object_pointer3_0 = (wxSize*) argument_native_object;
                    if (!object_pointer3_0 )
                    {
                        goto overload4;
                    }
                }
                else if(Z_TYPE_P(pixelSize3) != IS_NULL)
                {
                    goto overload4;
                }
            }

            overload3_called = true;
            already_called = true;
        }
    }

    //Overload 4
    overload4:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&nativeInfo4, php_wxNativeFontInfo_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &nativeInfo4, php_wxNativeFontInfo_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(nativeInfo4) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxNativeFontInfo_P(nativeInfo4)->object_type;
                    argument_native_object = (void*) Z_wxNativeFontInfo_P(nativeInfo4)->native_object;
                    object_pointer4_0 = (wxNativeFontInfo*) argument_native_object;
                    if (!object_pointer4_0 )
                    {
                        goto overload5;
                    }
                }
                else if(Z_TYPE_P(nativeInfo4) != IS_NULL)
                {
                    goto overload5;
                }
            }

            overload4_called = true;
            already_called = true;
        }
    }

    //Overload 5
    overload5:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&nativeInfoString5, &nativeInfoString_len5)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &nativeInfoString5, &nativeInfoString_len5 ) == SUCCESS)
        {
            overload5_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFont::New((int) pointSize0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return4;
                value_to_return4 = (wxFont_php*) wxFont::New((int) pointSize0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0);
                if(value_to_return4 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return4->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return4->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return4->phpObj);
                        zval_add_ref(&value_to_return4->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return4;
                }



                return;
                break;
            }
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFont::New((int) pointSize0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return5;
                value_to_return5 = (wxFont_php*) wxFont::New((int) pointSize0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0);
                if(value_to_return5 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return5->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return5->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return5->phpObj);
                        zval_add_ref(&value_to_return5->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return5;
                }



                return;
                break;
            }
            case 6:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFont::New((int) pointSize0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0, wxString(faceName0, wxConvUTF8)) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return6;
                value_to_return6 = (wxFont_php*) wxFont::New((int) pointSize0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0, wxString(faceName0, wxConvUTF8));
                if(value_to_return6 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return6->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return6->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return6->phpObj);
                        zval_add_ref(&value_to_return6->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return6;
                }



                return;
                break;
            }
            case 7:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFont::New((int) pointSize0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0, wxString(faceName0, wxConvUTF8), (wxFontEncoding) encoding0) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return7;
                value_to_return7 = (wxFont_php*) wxFont::New((int) pointSize0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0, wxString(faceName0, wxConvUTF8), (wxFontEncoding) encoding0);
                if(value_to_return7 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return7->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return7->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return7->phpObj);
                        zval_add_ref(&value_to_return7->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return7;
                }



                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFont::New((int) pointSize1, (wxFontFamily) family1) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return2;
                value_to_return2 = (wxFont_php*) wxFont::New((int) pointSize1, (wxFontFamily) family1);
                if(value_to_return2 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return2->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return2->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return2->phpObj);
                        zval_add_ref(&value_to_return2->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return2;
                }



                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFont::New((int) pointSize1, (wxFontFamily) family1, (int) flags1) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return3;
                value_to_return3 = (wxFont_php*) wxFont::New((int) pointSize1, (wxFontFamily) family1, (int) flags1);
                if(value_to_return3 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return3->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return3->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return3->phpObj);
                        zval_add_ref(&value_to_return3->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return3;
                }



                return;
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFont::New((int) pointSize1, (wxFontFamily) family1, (int) flags1, wxString(faceName1, wxConvUTF8)) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return4;
                value_to_return4 = (wxFont_php*) wxFont::New((int) pointSize1, (wxFontFamily) family1, (int) flags1, wxString(faceName1, wxConvUTF8));
                if(value_to_return4 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return4->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return4->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return4->phpObj);
                        zval_add_ref(&value_to_return4->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return4;
                }



                return;
                break;
            }
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFont::New((int) pointSize1, (wxFontFamily) family1, (int) flags1, wxString(faceName1, wxConvUTF8), (wxFontEncoding) encoding1) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return5;
                value_to_return5 = (wxFont_php*) wxFont::New((int) pointSize1, (wxFontFamily) family1, (int) flags1, wxString(faceName1, wxConvUTF8), (wxFontEncoding) encoding1);
                if(value_to_return5 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return5->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return5->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return5->phpObj);
                        zval_add_ref(&value_to_return5->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return5;
                }



                return;
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFont::New(*(wxSize*) object_pointer2_0, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return4;
                value_to_return4 = (wxFont_php*) wxFont::New(*(wxSize*) object_pointer2_0, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2);
                if(value_to_return4 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return4->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return4->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return4->phpObj);
                        zval_add_ref(&value_to_return4->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return4;
                }



                return;
                break;
            }
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFont::New(*(wxSize*) object_pointer2_0, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return5;
                value_to_return5 = (wxFont_php*) wxFont::New(*(wxSize*) object_pointer2_0, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2);
                if(value_to_return5 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return5->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return5->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return5->phpObj);
                        zval_add_ref(&value_to_return5->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return5;
                }



                return;
                break;
            }
            case 6:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFont::New(*(wxSize*) object_pointer2_0, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2, wxString(faceName2, wxConvUTF8)) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return6;
                value_to_return6 = (wxFont_php*) wxFont::New(*(wxSize*) object_pointer2_0, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2, wxString(faceName2, wxConvUTF8));
                if(value_to_return6 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return6->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return6->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return6->phpObj);
                        zval_add_ref(&value_to_return6->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return6;
                }



                return;
                break;
            }
            case 7:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFont::New(*(wxSize*) object_pointer2_0, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2, wxString(faceName2, wxConvUTF8), (wxFontEncoding) encoding2) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return7;
                value_to_return7 = (wxFont_php*) wxFont::New(*(wxSize*) object_pointer2_0, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2, wxString(faceName2, wxConvUTF8), (wxFontEncoding) encoding2);
                if(value_to_return7 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return7->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return7->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return7->phpObj);
                        zval_add_ref(&value_to_return7->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return7;
                }



                return;
                break;
            }
        }
    }

    if(overload3_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFont::New(*(wxSize*) object_pointer3_0, (wxFontFamily) family3) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return2;
                value_to_return2 = (wxFont_php*) wxFont::New(*(wxSize*) object_pointer3_0, (wxFontFamily) family3);
                if(value_to_return2 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return2->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return2->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return2->phpObj);
                        zval_add_ref(&value_to_return2->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return2;
                }



                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFont::New(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (int) flags3) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return3;
                value_to_return3 = (wxFont_php*) wxFont::New(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (int) flags3);
                if(value_to_return3 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return3->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return3->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return3->phpObj);
                        zval_add_ref(&value_to_return3->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return3;
                }



                return;
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFont::New(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (int) flags3, wxString(faceName3, wxConvUTF8)) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return4;
                value_to_return4 = (wxFont_php*) wxFont::New(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (int) flags3, wxString(faceName3, wxConvUTF8));
                if(value_to_return4 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return4->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return4->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return4->phpObj);
                        zval_add_ref(&value_to_return4->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return4;
                }



                return;
                break;
            }
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFont::New(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (int) flags3, wxString(faceName3, wxConvUTF8), (wxFontEncoding) encoding3) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return5;
                value_to_return5 = (wxFont_php*) wxFont::New(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (int) flags3, wxString(faceName3, wxConvUTF8), (wxFontEncoding) encoding3);
                if(value_to_return5 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return5->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return5->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return5->phpObj);
                        zval_add_ref(&value_to_return5->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return5;
                }



                return;
                break;
            }
        }
    }

    if(overload4_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFont::New(*(wxNativeFontInfo*) object_pointer4_0) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return1;
                value_to_return1 = (wxFont_php*) wxFont::New(*(wxNativeFontInfo*) object_pointer4_0);
                if(value_to_return1 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return1->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return1->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return1->phpObj);
                        zval_add_ref(&value_to_return1->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return1;
                }



                return;
                break;
            }
        }
    }

    if(overload5_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFont::New(wxString(nativeInfoString5, wxConvUTF8)) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return1;
                value_to_return1 = (wxFont_php*) wxFont::New(wxString(nativeInfoString5, wxConvUTF8));
                if(value_to_return1 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return1->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return1->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return1->phpObj);
                        zval_add_ref(&value_to_return1->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return1;
                }



                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::New\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFont wxFont::Scale(float x)
   Changes the size of this font. */
PHP_METHOD(php_wxFont, Scale)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::Scale\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::Scale call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    double x0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'd' (&x0)\n");
        #endif

        char parse_parameters_string[] = "d";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &x0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::Scale(x0) to return object reference\n\n");
                #endif

                wxFont_php* value_to_return1;
                value_to_return1 = (wxFont_php*) &((wxFont_php*)native_object)->Scale(x0);

                if(value_to_return1->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return1->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return1->phpObj);
                        zval_add_ref(&value_to_return1->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return1;
                }

                if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxFont::Scale at call 6 with 1 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::Scale\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFont wxFont::Scaled(float x)
   Returns a scaled version of this font. */
PHP_METHOD(php_wxFont, Scaled)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::Scaled\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::Scaled call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    double x0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'd' (&x0)\n");
        #endif

        char parse_parameters_string[] = "d";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &x0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::Scaled(x0) to return new object\n\n");
                #endif

                wxFont value_to_return1;
                value_to_return1 = ((wxFont_php*)native_object)->Scaled(x0);
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxFont_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxFont));
                object_init_ex(return_value, php_wxFont_entry);
                ((wxFont_php*)ptr)->phpObj = *return_value;
                zo_wxFont* zo1 = Z_wxFont_P(return_value);
                zo1->native_object = (wxFont_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::Scaled\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFont::SetDefaultEncoding(wxFontEncoding encoding)
   Sets the default font encoding. */
PHP_METHOD(php_wxFont, SetDefaultEncoding)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::SetDefaultEncoding\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::SetDefaultEncoding call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long encoding0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&encoding0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &encoding0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFont::SetDefaultEncoding((wxFontEncoding) encoding0)\n\n");
                #endif

                wxFont::SetDefaultEncoding((wxFontEncoding) encoding0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::SetDefaultEncoding\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFont::SetEncoding(wxFontEncoding encoding)
   Sets the encoding for this font. */
PHP_METHOD(php_wxFont, SetEncoding)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::SetEncoding\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::SetEncoding call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long encoding0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&encoding0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &encoding0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::SetEncoding((wxFontEncoding) encoding0)\n\n");
                #endif

                ((wxFont_php*)native_object)->SetEncoding((wxFontEncoding) encoding0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::SetEncoding\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFont::SetFaceName(string faceName)
   Sets the facename for the font. */
PHP_METHOD(php_wxFont, SetFaceName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::SetFaceName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::SetFaceName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* faceName0;
    size_t faceName_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&faceName0, &faceName_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &faceName0, &faceName_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFont::SetFaceName(wxString(faceName0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxFont_php*)native_object)->SetFaceName(wxString(faceName0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::SetFaceName\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFont::SetFamily(wxFontFamily family)
   Sets the font family. */
PHP_METHOD(php_wxFont, SetFamily)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::SetFamily\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::SetFamily call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long family0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&family0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &family0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::SetFamily((wxFontFamily) family0)\n\n");
                #endif

                ((wxFont_php*)native_object)->SetFamily((wxFontFamily) family0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::SetFamily\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFont::SetNativeFontInfo(string info)
   Creates the font corresponding to the given native font description string which must have been previously returned by GetNativeFontInfoDesc(). */
PHP_METHOD(php_wxFont, SetNativeFontInfo)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::SetNativeFontInfo\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::SetNativeFontInfo call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* info0;
    size_t info_len0;
    bool overload0_called = false;

    //Parameters for overload 1
    zval* info1;
    wxNativeFontInfo* object_pointer1_0 = 0;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&info0, &info_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &info0, &info_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&info1, php_wxNativeFontInfo_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &info1, php_wxNativeFontInfo_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(info1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxNativeFontInfo_P(info1)->object_type;
                    argument_native_object = (void*) Z_wxNativeFontInfo_P(info1)->native_object;
                    object_pointer1_0 = (wxNativeFontInfo*) argument_native_object;
                    if (!object_pointer1_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'info' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(info1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'info' not null, could not be retreived correctly.");
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFont::SetNativeFontInfo(wxString(info0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxFont_php*)native_object)->SetNativeFontInfo(wxString(info0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::SetNativeFontInfo(*(wxNativeFontInfo*) object_pointer1_0)\n\n");
                #endif

                ((wxFont_php*)native_object)->SetNativeFontInfo(*(wxNativeFontInfo*) object_pointer1_0);

                references->AddReference(info1, "wxFont::SetNativeFontInfo at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::SetNativeFontInfo\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFont::SetNativeFontInfoUserDesc(string info)
   Creates the font corresponding to the given native font description string and returns true if the creation was successful. */
PHP_METHOD(php_wxFont, SetNativeFontInfoUserDesc)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::SetNativeFontInfoUserDesc\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::SetNativeFontInfoUserDesc call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* info0;
    size_t info_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&info0, &info_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &info0, &info_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFont::SetNativeFontInfoUserDesc(wxString(info0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxFont_php*)native_object)->SetNativeFontInfoUserDesc(wxString(info0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::SetNativeFontInfoUserDesc\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFont::SetPixelSize(wxSize pixelSize)
   Sets the pixel size. */
PHP_METHOD(php_wxFont, SetPixelSize)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::SetPixelSize\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::SetPixelSize call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* pixelSize0;
    wxSize* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&pixelSize0, php_wxSize_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pixelSize0, php_wxSize_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(pixelSize0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(pixelSize0)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(pixelSize0)->native_object;
                    object_pointer0_0 = (wxSize*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'pixelSize' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(pixelSize0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'pixelSize' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::SetPixelSize(*(wxSize*) object_pointer0_0)\n\n");
                #endif

                ((wxFont_php*)native_object)->SetPixelSize(*(wxSize*) object_pointer0_0);

                references->AddReference(pixelSize0, "wxFont::SetPixelSize at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::SetPixelSize\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFont::SetPointSize(int pointSize)
   Sets the font size in points to an integer value. */
PHP_METHOD(php_wxFont, SetPointSize)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::SetPointSize\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::SetPointSize call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long pointSize0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&pointSize0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pointSize0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::SetPointSize((int) pointSize0)\n\n");
                #endif

                ((wxFont_php*)native_object)->SetPointSize((int) pointSize0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::SetPointSize\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFont::SetStyle(wxFontStyle style)
   Sets the font style. */
PHP_METHOD(php_wxFont, SetStyle)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::SetStyle\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::SetStyle call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long style0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&style0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &style0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::SetStyle((wxFontStyle) style0)\n\n");
                #endif

                ((wxFont_php*)native_object)->SetStyle((wxFontStyle) style0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::SetStyle\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFont::SetSymbolicSize(wxFontSymbolicSize size)
   Sets the font size using a predefined symbolic size name. */
PHP_METHOD(php_wxFont, SetSymbolicSize)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::SetSymbolicSize\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::SetSymbolicSize call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long size0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&size0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &size0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::SetSymbolicSize((wxFontSymbolicSize) size0)\n\n");
                #endif

                ((wxFont_php*)native_object)->SetSymbolicSize((wxFontSymbolicSize) size0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::SetSymbolicSize\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFont::SetSymbolicSizeRelativeTo(wxFontSymbolicSize size, int base)
   Sets the font size compared to the base font size. */
PHP_METHOD(php_wxFont, SetSymbolicSizeRelativeTo)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::SetSymbolicSizeRelativeTo\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::SetSymbolicSizeRelativeTo call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long size0;
    long base0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (&size0, &base0)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &size0, &base0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::SetSymbolicSizeRelativeTo((wxFontSymbolicSize) size0, (int) base0)\n\n");
                #endif

                ((wxFont_php*)native_object)->SetSymbolicSizeRelativeTo((wxFontSymbolicSize) size0, (int) base0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::SetSymbolicSizeRelativeTo\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFont::SetUnderlined(bool underlined)
   Sets underlining. */
PHP_METHOD(php_wxFont, SetUnderlined)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::SetUnderlined\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::SetUnderlined call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool underlined0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'b' (&underlined0)\n");
        #endif

        char parse_parameters_string[] = "b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &underlined0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::SetUnderlined(underlined0)\n\n");
                #endif

                ((wxFont_php*)native_object)->SetUnderlined(underlined0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::SetUnderlined\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFont::SetWeight(wxFontWeight weight)
   Sets the font weight. */
PHP_METHOD(php_wxFont, SetWeight)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::SetWeight\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::SetWeight call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long weight0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&weight0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &weight0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::SetWeight((wxFontWeight) weight0)\n\n");
                #endif

                ((wxFont_php*)native_object)->SetWeight((wxFontWeight) weight0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::SetWeight\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFont wxFont::Smaller()
   Returns a smaller version of this font. */
PHP_METHOD(php_wxFont, Smaller)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::Smaller\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::Smaller call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::Smaller() to return new object\n\n");
                #endif

                wxFont value_to_return0;
                value_to_return0 = ((wxFont_php*)native_object)->Smaller();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxFont_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxFont));
                object_init_ex(return_value, php_wxFont_entry);
                ((wxFont_php*)ptr)->phpObj = *return_value;
                zo_wxFont* zo0 = Z_wxFont_P(return_value);
                zo0->native_object = (wxFont_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::Smaller\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFont wxFont::Underlined()
   Returns underlined version of this font. */
PHP_METHOD(php_wxFont, Underlined)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::Underlined\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::Underlined call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::Underlined() to return new object\n\n");
                #endif

                wxFont value_to_return0;
                value_to_return0 = ((wxFont_php*)native_object)->Underlined();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxFont_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxFont));
                object_init_ex(return_value, php_wxFont_entry);
                ((wxFont_php*)ptr)->phpObj = *return_value;
                zo_wxFont* zo0 = Z_wxFont_P(return_value);
                zo0->native_object = (wxFont_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::Underlined\n"
        );
    }
}
/* }}} */

/* {{{ proto wxNativeFontInfo wxFont::GetNativeFontInfo()
   Returns a font with the same face/size as the given one but with normal weight and style and not underlined nor stricken through. */
PHP_METHOD(php_wxFont, GetNativeFontInfo)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFont::GetNativeFontInfo\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFont* current_object;
    wxphp_object_type current_object_type;
    wxFont_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFont_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFont::GetNativeFontInfo call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONT_TYPE){
                references = &((wxFont_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFont::GetNativeFontInfo() to return object pointer\n\n");
                #endif

                wxNativeFontInfo_php* value_to_return0;
                value_to_return0 = (wxNativeFontInfo_php*) ((wxFont_php*)native_object)->GetNativeFontInfo();

                if(value_to_return0 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxNativeFontInfo_entry);
                    Z_wxNativeFontInfo_P(return_value)->native_object = (wxNativeFontInfo_php*) value_to_return0;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxFont::GetNativeFontInfo at call 5 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFont::GetNativeFontInfo\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFontList_free(void *object)
{
    zo_wxFontList* custom_object = (zo_wxFontList*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFontList_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxFontList done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxFontList_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFontList_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxFontList* custom_object;

    custom_object = (zo_wxFontList*) ecalloc(
        1,
        sizeof(zo_wxFontList)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxFontList_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFONTLIST_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxFontList::wxFontList()
   Constructor. */
PHP_METHOD(php_wxFontList, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFontList::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFontList* current_object;
    wxFontList_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxFontList_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxFontList_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxFontList::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto wxFont wxFontList::FindOrCreateFont(int point_size, wxFontFamily family, wxFontStyle style, wxFontWeight weight, bool underline, string facename, wxFontEncoding encoding)
   Finds a font of the given specification, or creates one and adds it to the list. */
PHP_METHOD(php_wxFontList, FindOrCreateFont)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFontList::FindOrCreateFont\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFontList* current_object;
    wxphp_object_type current_object_type;
    wxFontList_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFontList_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFontList::FindOrCreateFont call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONTLIST_TYPE){
                references = &((wxFontList_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long point_size0;
    long family0;
    long style0;
    long weight0;
    bool underline0;
    char* facename0;
    size_t facename_len0;
    long encoding0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 4  && arguments_received <= 7)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'llll|bsl' (&point_size0, &family0, &style0, &weight0, &underline0, &facename0, &facename_len0, &encoding0)\n");
        #endif

        char parse_parameters_string[] = "llll|bsl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &point_size0, &family0, &style0, &weight0, &underline0, &facename0, &facename_len0, &encoding0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFontList::FindOrCreateFont((int) point_size0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return4;
                value_to_return4 = (wxFont_php*) ((wxFontList_php*)native_object)->FindOrCreateFont((int) point_size0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0);

                if(value_to_return4 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return4->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return4->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return4->phpObj);
                        zval_add_ref(&value_to_return4->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return4;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return4 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxFontList::FindOrCreateFont at call 5 with 4 argument(s)");
                }


                return;
                break;
            }
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFontList::FindOrCreateFont((int) point_size0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return5;
                value_to_return5 = (wxFont_php*) ((wxFontList_php*)native_object)->FindOrCreateFont((int) point_size0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0);

                if(value_to_return5 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return5->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return5->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return5->phpObj);
                        zval_add_ref(&value_to_return5->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return5;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return5 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxFontList::FindOrCreateFont at call 5 with 5 argument(s)");
                }


                return;
                break;
            }
            case 6:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFontList::FindOrCreateFont((int) point_size0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0, wxString(facename0, wxConvUTF8)) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return6;
                value_to_return6 = (wxFont_php*) ((wxFontList_php*)native_object)->FindOrCreateFont((int) point_size0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0, wxString(facename0, wxConvUTF8));

                if(value_to_return6 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return6->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return6->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return6->phpObj);
                        zval_add_ref(&value_to_return6->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return6;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return6 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxFontList::FindOrCreateFont at call 5 with 6 argument(s)");
                }


                return;
                break;
            }
            case 7:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFontList::FindOrCreateFont((int) point_size0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0, wxString(facename0, wxConvUTF8), (wxFontEncoding) encoding0) to return object pointer\n\n");
                #endif

                wxFont_php* value_to_return7;
                value_to_return7 = (wxFont_php*) ((wxFontList_php*)native_object)->FindOrCreateFont((int) point_size0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0, wxString(facename0, wxConvUTF8), (wxFontEncoding) encoding0);

                if(value_to_return7 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return7->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return7->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return7->phpObj);
                        zval_add_ref(&value_to_return7->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFont_entry);
                    Z_wxFont_P(return_value)->native_object = (wxFont_php*) value_to_return7;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return7 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxFontList::FindOrCreateFont at call 5 with 7 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFontList::FindOrCreateFont\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFontEnumerator_free(void *object)
{
    zo_wxFontEnumerator* custom_object = (zo_wxFontEnumerator*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFontEnumerator_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxFontEnumerator done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxFontEnumerator_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFontEnumerator_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxFontEnumerator* custom_object;

    custom_object = (zo_wxFontEnumerator*) ecalloc(
        1,
        sizeof(zo_wxFontEnumerator)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxFontEnumerator_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFONTENUMERATOR_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto bool wxFontEnumerator::OnFontEncoding(string font, string encoding)
   Called by EnumerateEncodings() for each match. */
bool wxFontEnumerator_php::OnFontEncoding(const wxString& font, const wxString& encoding)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxFontEnumerator::OnFontEncoding\n");
    php_printf("===========================================\n");
    #endif

    zval* params[2];
    zval arguments[2];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "OnFontEncoding");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    ZVAL_STRING(&arguments[0], font.ToUTF8().data());
    ZVAL_STRING(&arguments[1], encoding.ToUTF8().data());
    
    for(int i=0; i<2; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "OnFontEncoding");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "OnFontEncoding",
            14,
            &function_return_value,
            2,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<2; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Returning userspace value.\n");
        #endif

        return Z_TYPE(function_return_value) == IS_TRUE;
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Calling original method\n");
    php_printf("===========================================\n\n");
    #endif

    //Call original method
    return wxFontEnumerator::OnFontEncoding(
        font, encoding    );
}
/* }}} */

/* {{{ proto bool wxFontEnumerator::OnFacename(string font)
   Called by EnumerateFacenames() for each match. */
bool wxFontEnumerator_php::OnFacename(const wxString& font)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxFontEnumerator::OnFacename\n");
    php_printf("===========================================\n");
    #endif

    zval* params[1];
    zval arguments[1];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "OnFacename");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    ZVAL_STRING(&arguments[0], font.ToUTF8().data());
    
    for(int i=0; i<1; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "OnFacename");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "OnFacename",
            10,
            &function_return_value,
            1,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<1; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Returning userspace value.\n");
        #endif

        return Z_TYPE(function_return_value) == IS_TRUE;
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Calling original method\n");
    php_printf("===========================================\n\n");
    #endif

    //Call original method
    return wxFontEnumerator::OnFacename(
        font    );
}
/* }}} */

/* {{{ proto bool wxFontEnumerator::IsValidFacename(string facename)
   Returns true if the given string is valid face name, i.e. */
PHP_METHOD(php_wxFontEnumerator, IsValidFacename)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFontEnumerator::IsValidFacename\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFontEnumerator* current_object;
    wxphp_object_type current_object_type;
    wxFontEnumerator_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFontEnumerator_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFontEnumerator::IsValidFacename call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONTENUMERATOR_TYPE){
                references = &((wxFontEnumerator_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* facename0;
    size_t facename_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&facename0, &facename_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &facename0, &facename_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxFontEnumerator::IsValidFacename(wxString(facename0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(wxFontEnumerator::IsValidFacename(wxString(facename0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFontEnumerator::IsValidFacename\n"
        );
    }
}
/* }}} */

/* {{{ proto array wxFontEnumerator::GetFacenames(wxFontEncoding encoding, bool fixedWidthOnly)
   Return array of strings containing all facenames found by EnumerateFacenames(). */
PHP_METHOD(php_wxFontEnumerator, GetFacenames)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFontEnumerator::GetFacenames\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFontEnumerator* current_object;
    wxphp_object_type current_object_type;
    wxFontEnumerator_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFontEnumerator_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFontEnumerator::GetFacenames call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONTENUMERATOR_TYPE){
                references = &((wxFontEnumerator_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long encoding0;
    bool fixedWidthOnly0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|lb' (&encoding0, &fixedWidthOnly0)\n");
        #endif

        char parse_parameters_string[] = "|lb";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &encoding0, &fixedWidthOnly0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFontEnumerator::GetFacenames() to return strings array\n\n");
                #endif

                wxArrayString value_to_return0;
                value_to_return0 = wxFontEnumerator::GetFacenames();
                array_init(return_value);
                for(size_t i=0; i<value_to_return0.GetCount(); i++)
                {
                    add_next_index_string(return_value, value_to_return0[i].ToUTF8().data());
                }


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFontEnumerator::GetFacenames((wxFontEncoding) encoding0) to return strings array\n\n");
                #endif

                wxArrayString value_to_return1;
                value_to_return1 = wxFontEnumerator::GetFacenames((wxFontEncoding) encoding0);
                array_init(return_value);
                for(size_t i=0; i<value_to_return1.GetCount(); i++)
                {
                    add_next_index_string(return_value, value_to_return1[i].ToUTF8().data());
                }


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFontEnumerator::GetFacenames((wxFontEncoding) encoding0, fixedWidthOnly0) to return strings array\n\n");
                #endif

                wxArrayString value_to_return2;
                value_to_return2 = wxFontEnumerator::GetFacenames((wxFontEncoding) encoding0, fixedWidthOnly0);
                array_init(return_value);
                for(size_t i=0; i<value_to_return2.GetCount(); i++)
                {
                    add_next_index_string(return_value, value_to_return2[i].ToUTF8().data());
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFontEnumerator::GetFacenames\n"
        );
    }
}
/* }}} */

/* {{{ proto array wxFontEnumerator::GetEncodings(string facename)
   Return array of strings containing all encodings found by EnumerateEncodings(). */
PHP_METHOD(php_wxFontEnumerator, GetEncodings)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFontEnumerator::GetEncodings\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFontEnumerator* current_object;
    wxphp_object_type current_object_type;
    wxFontEnumerator_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFontEnumerator_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFontEnumerator::GetEncodings call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONTENUMERATOR_TYPE){
                references = &((wxFontEnumerator_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* facename0;
    size_t facename_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|s' (&facename0, &facename_len0)\n");
        #endif

        char parse_parameters_string[] = "|s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &facename0, &facename_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFontEnumerator::GetEncodings() to return strings array\n\n");
                #endif

                wxArrayString value_to_return0;
                value_to_return0 = wxFontEnumerator::GetEncodings();
                array_init(return_value);
                for(size_t i=0; i<value_to_return0.GetCount(); i++)
                {
                    add_next_index_string(return_value, value_to_return0[i].ToUTF8().data());
                }


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFontEnumerator::GetEncodings(wxString(facename0, wxConvUTF8)) to return strings array\n\n");
                #endif

                wxArrayString value_to_return1;
                value_to_return1 = wxFontEnumerator::GetEncodings(wxString(facename0, wxConvUTF8));
                array_init(return_value);
                for(size_t i=0; i<value_to_return1.GetCount(); i++)
                {
                    add_next_index_string(return_value, value_to_return1[i].ToUTF8().data());
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFontEnumerator::GetEncodings\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFontEnumerator::EnumerateFacenames(wxFontEncoding encoding, bool fixedWidthOnly)
   Call OnFacename() for each font which supports given encoding (only if it is not wxFONTENCODING_SYSTEM) and is of fixed width (if fixedWidthOnly is true). */
PHP_METHOD(php_wxFontEnumerator, EnumerateFacenames)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFontEnumerator::EnumerateFacenames\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFontEnumerator* current_object;
    wxphp_object_type current_object_type;
    wxFontEnumerator_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFontEnumerator_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFontEnumerator::EnumerateFacenames call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONTENUMERATOR_TYPE){
                references = &((wxFontEnumerator_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long encoding0;
    bool fixedWidthOnly0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|lb' (&encoding0, &fixedWidthOnly0)\n");
        #endif

        char parse_parameters_string[] = "|lb";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &encoding0, &fixedWidthOnly0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFontEnumerator::EnumerateFacenames())\n\n");
                #endif

                if(current_object_type == PHP_WXFONTENUMERATOR_TYPE)
                {
                    RETVAL_BOOL(((wxFontEnumerator_php*)native_object)->EnumerateFacenames());
                }


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFontEnumerator::EnumerateFacenames((wxFontEncoding) encoding0))\n\n");
                #endif

                if(current_object_type == PHP_WXFONTENUMERATOR_TYPE)
                {
                    RETVAL_BOOL(((wxFontEnumerator_php*)native_object)->EnumerateFacenames((wxFontEncoding) encoding0));
                }


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFontEnumerator::EnumerateFacenames((wxFontEncoding) encoding0, fixedWidthOnly0))\n\n");
                #endif

                if(current_object_type == PHP_WXFONTENUMERATOR_TYPE)
                {
                    RETVAL_BOOL(((wxFontEnumerator_php*)native_object)->EnumerateFacenames((wxFontEncoding) encoding0, fixedWidthOnly0));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFontEnumerator::EnumerateFacenames\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFontEnumerator::EnumerateEncodings(string font)
   Call OnFontEncoding() for each encoding supported by the given font - or for each encoding supported by at least some font if font is not specified. */
PHP_METHOD(php_wxFontEnumerator, EnumerateEncodings)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFontEnumerator::EnumerateEncodings\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFontEnumerator* current_object;
    wxphp_object_type current_object_type;
    wxFontEnumerator_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFontEnumerator_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFontEnumerator::EnumerateEncodings call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONTENUMERATOR_TYPE){
                references = &((wxFontEnumerator_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* font0;
    size_t font_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|s' (&font0, &font_len0)\n");
        #endif

        char parse_parameters_string[] = "|s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &font0, &font_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFontEnumerator::EnumerateEncodings())\n\n");
                #endif

                if(current_object_type == PHP_WXFONTENUMERATOR_TYPE)
                {
                    RETVAL_BOOL(((wxFontEnumerator_php*)native_object)->EnumerateEncodings());
                }


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFontEnumerator::EnumerateEncodings(wxString(font0, wxConvUTF8)))\n\n");
                #endif

                if(current_object_type == PHP_WXFONTENUMERATOR_TYPE)
                {
                    RETVAL_BOOL(((wxFontEnumerator_php*)native_object)->EnumerateEncodings(wxString(font0, wxConvUTF8)));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFontEnumerator::EnumerateEncodings\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxNativeFontInfo_free(void *object)
{
    zo_wxNativeFontInfo* custom_object = (zo_wxNativeFontInfo*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxNativeFontInfo_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxNativeFontInfo done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxNativeFontInfo_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxNativeFontInfo_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* custom_object;

    custom_object = (zo_wxNativeFontInfo*) ecalloc(
        1,
        sizeof(zo_wxNativeFontInfo)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxNativeFontInfo_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXNATIVEFONTINFO_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxNativeFontInfo::wxNativeFontInfo() */
PHP_METHOD(php_wxNativeFontInfo, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNativeFontInfo::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* current_object;
    wxNativeFontInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    zval* info1;
    wxNativeFontInfo* object_pointer1_0 = 0;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&info1, php_wxNativeFontInfo_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &info1, php_wxNativeFontInfo_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(info1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxNativeFontInfo_P(info1)->object_type;
                    argument_native_object = (void*) Z_wxNativeFontInfo_P(info1)->native_object;
                    object_pointer1_0 = (wxNativeFontInfo*) argument_native_object;
                    if (!object_pointer1_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'info' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(info1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'info' not null, could not be retreived correctly.");
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxNativeFontInfo_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxNativeFontInfo*) object_pointer1_0)\n");
                #endif

                native_object = new wxNativeFontInfo_php(*(wxNativeFontInfo*) object_pointer1_0);

                native_object->references.Initialize();
                ((wxNativeFontInfo_php*) native_object)->references.AddReference(info1, "wxNativeFontInfo::wxNativeFontInfo at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxNativeFontInfo_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxNativeFontInfo::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto bool wxNativeFontInfo::FromString(string s) */
PHP_METHOD(php_wxNativeFontInfo, FromString)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNativeFontInfo::FromString\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* current_object;
    wxphp_object_type current_object_type;
    wxNativeFontInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNativeFontInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNativeFontInfo::FromString call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
                references = &((wxNativeFontInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* s0;
    size_t s_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&s0, &s_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &s0, &s_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxNativeFontInfo::FromString(wxString(s0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxNativeFontInfo_php*)native_object)->FromString(wxString(s0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNativeFontInfo::FromString\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxNativeFontInfo::FromUserString(string s) */
PHP_METHOD(php_wxNativeFontInfo, FromUserString)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNativeFontInfo::FromUserString\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* current_object;
    wxphp_object_type current_object_type;
    wxNativeFontInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNativeFontInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNativeFontInfo::FromUserString call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
                references = &((wxNativeFontInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* s0;
    size_t s_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&s0, &s_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &s0, &s_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxNativeFontInfo::FromUserString(wxString(s0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxNativeFontInfo_php*)native_object)->FromUserString(wxString(s0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNativeFontInfo::FromUserString\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFontEncoding wxNativeFontInfo::GetEncoding() */
PHP_METHOD(php_wxNativeFontInfo, GetEncoding)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNativeFontInfo::GetEncoding\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* current_object;
    wxphp_object_type current_object_type;
    wxNativeFontInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNativeFontInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNativeFontInfo::GetEncoding call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
                references = &((wxNativeFontInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxNativeFontInfo::GetEncoding())\n\n");
                #endif

                RETVAL_LONG(((wxNativeFontInfo_php*)native_object)->GetEncoding());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNativeFontInfo::GetEncoding\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxNativeFontInfo::GetFaceName() */
PHP_METHOD(php_wxNativeFontInfo, GetFaceName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNativeFontInfo::GetFaceName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* current_object;
    wxphp_object_type current_object_type;
    wxNativeFontInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNativeFontInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNativeFontInfo::GetFaceName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
                references = &((wxNativeFontInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxNativeFontInfo::GetFaceName().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxNativeFontInfo_php*)native_object)->GetFaceName();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNativeFontInfo::GetFaceName\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFontFamily wxNativeFontInfo::GetFamily() */
PHP_METHOD(php_wxNativeFontInfo, GetFamily)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNativeFontInfo::GetFamily\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* current_object;
    wxphp_object_type current_object_type;
    wxNativeFontInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNativeFontInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNativeFontInfo::GetFamily call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
                references = &((wxNativeFontInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxNativeFontInfo::GetFamily())\n\n");
                #endif

                RETVAL_LONG(((wxNativeFontInfo_php*)native_object)->GetFamily());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNativeFontInfo::GetFamily\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxNativeFontInfo::GetPointSize() */
PHP_METHOD(php_wxNativeFontInfo, GetPointSize)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNativeFontInfo::GetPointSize\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* current_object;
    wxphp_object_type current_object_type;
    wxNativeFontInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNativeFontInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNativeFontInfo::GetPointSize call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
                references = &((wxNativeFontInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxNativeFontInfo::GetPointSize())\n\n");
                #endif

                RETVAL_LONG(((wxNativeFontInfo_php*)native_object)->GetPointSize());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNativeFontInfo::GetPointSize\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFontStyle wxNativeFontInfo::GetStyle() */
PHP_METHOD(php_wxNativeFontInfo, GetStyle)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNativeFontInfo::GetStyle\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* current_object;
    wxphp_object_type current_object_type;
    wxNativeFontInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNativeFontInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNativeFontInfo::GetStyle call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
                references = &((wxNativeFontInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxNativeFontInfo::GetStyle())\n\n");
                #endif

                RETVAL_LONG(((wxNativeFontInfo_php*)native_object)->GetStyle());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNativeFontInfo::GetStyle\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxNativeFontInfo::GetUnderlined() */
PHP_METHOD(php_wxNativeFontInfo, GetUnderlined)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNativeFontInfo::GetUnderlined\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* current_object;
    wxphp_object_type current_object_type;
    wxNativeFontInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNativeFontInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNativeFontInfo::GetUnderlined call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
                references = &((wxNativeFontInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxNativeFontInfo::GetUnderlined())\n\n");
                #endif

                RETVAL_BOOL(((wxNativeFontInfo_php*)native_object)->GetUnderlined());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNativeFontInfo::GetUnderlined\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFontWeight wxNativeFontInfo::GetWeight() */
PHP_METHOD(php_wxNativeFontInfo, GetWeight)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNativeFontInfo::GetWeight\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* current_object;
    wxphp_object_type current_object_type;
    wxNativeFontInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNativeFontInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNativeFontInfo::GetWeight call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
                references = &((wxNativeFontInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxNativeFontInfo::GetWeight())\n\n");
                #endif

                RETVAL_LONG(((wxNativeFontInfo_php*)native_object)->GetWeight());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNativeFontInfo::GetWeight\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxNativeFontInfo::Init() */
PHP_METHOD(php_wxNativeFontInfo, Init)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNativeFontInfo::Init\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* current_object;
    wxphp_object_type current_object_type;
    wxNativeFontInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNativeFontInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNativeFontInfo::Init call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
                references = &((wxNativeFontInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxNativeFontInfo::Init()\n\n");
                #endif

                ((wxNativeFontInfo_php*)native_object)->Init();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNativeFontInfo::Init\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxNativeFontInfo::InitFromFont(wxFont font) */
PHP_METHOD(php_wxNativeFontInfo, InitFromFont)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNativeFontInfo::InitFromFont\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* current_object;
    wxphp_object_type current_object_type;
    wxNativeFontInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNativeFontInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNativeFontInfo::InitFromFont call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
                references = &((wxNativeFontInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* font0;
    wxFont* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&font0, php_wxFont_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &font0, php_wxFont_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(font0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxFont_P(font0)->object_type;
                    argument_native_object = (void*) Z_wxFont_P(font0)->native_object;
                    object_pointer0_0 = (wxFont*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'font' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(font0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'font' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxNativeFontInfo::InitFromFont(*(wxFont*) object_pointer0_0)\n\n");
                #endif

                ((wxNativeFontInfo_php*)native_object)->InitFromFont(*(wxFont*) object_pointer0_0);

                references->AddReference(font0, "wxNativeFontInfo::InitFromFont at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNativeFontInfo::InitFromFont\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxNativeFontInfo::SetEncoding(wxFontEncoding encoding) */
PHP_METHOD(php_wxNativeFontInfo, SetEncoding)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNativeFontInfo::SetEncoding\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* current_object;
    wxphp_object_type current_object_type;
    wxNativeFontInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNativeFontInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNativeFontInfo::SetEncoding call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
                references = &((wxNativeFontInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long encoding0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&encoding0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &encoding0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxNativeFontInfo::SetEncoding((wxFontEncoding) encoding0)\n\n");
                #endif

                ((wxNativeFontInfo_php*)native_object)->SetEncoding((wxFontEncoding) encoding0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNativeFontInfo::SetEncoding\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxNativeFontInfo::SetFaceName(string facename) */
PHP_METHOD(php_wxNativeFontInfo, SetFaceName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNativeFontInfo::SetFaceName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* current_object;
    wxphp_object_type current_object_type;
    wxNativeFontInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNativeFontInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNativeFontInfo::SetFaceName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
                references = &((wxNativeFontInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* facename0;
    size_t facename_len0;
    bool overload0_called = false;

    //Parameters for overload 1
    zval* facenames1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&facename0, &facename_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &facename0, &facename_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'a' (&facenames1)\n");
        #endif

        char parse_parameters_string[] = "a";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &facenames1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxNativeFontInfo::SetFaceName(wxString(facename0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxNativeFontInfo_php*)native_object)->SetFaceName(wxString(facename0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        wxArrayString strings_array1_0;
        bool strings_continue1_0 = true;

        switch(arguments_received)
        {
            case 1:
            {
                int array_index1_0 = 0;
                zval* temp_array_value1_0 = 0;
                while(strings_continue1_0)
                {
                    if((temp_array_value1_0 = zend_hash_index_find(HASH_OF(facenames1), array_index1_0)) != NULL)
                    {
                        convert_to_string(temp_array_value1_0);
                        strings_array1_0.Add(wxString(Z_STRVAL_P(temp_array_value1_0), wxConvUTF8));
                        array_index1_0++;
                    }
                    else
                    {
                        strings_continue1_0 = false;
                    }
                }
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxNativeFontInfo::SetFaceName(strings_array1_0)\n\n");
                #endif

                ((wxNativeFontInfo_php*)native_object)->SetFaceName(strings_array1_0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNativeFontInfo::SetFaceName\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxNativeFontInfo::SetFamily(wxFontFamily family) */
PHP_METHOD(php_wxNativeFontInfo, SetFamily)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNativeFontInfo::SetFamily\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* current_object;
    wxphp_object_type current_object_type;
    wxNativeFontInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNativeFontInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNativeFontInfo::SetFamily call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
                references = &((wxNativeFontInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long family0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&family0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &family0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxNativeFontInfo::SetFamily((wxFontFamily) family0)\n\n");
                #endif

                ((wxNativeFontInfo_php*)native_object)->SetFamily((wxFontFamily) family0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNativeFontInfo::SetFamily\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxNativeFontInfo::SetPointSize(int pointsize) */
PHP_METHOD(php_wxNativeFontInfo, SetPointSize)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNativeFontInfo::SetPointSize\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* current_object;
    wxphp_object_type current_object_type;
    wxNativeFontInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNativeFontInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNativeFontInfo::SetPointSize call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
                references = &((wxNativeFontInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long pointsize0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&pointsize0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pointsize0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxNativeFontInfo::SetPointSize((int) pointsize0)\n\n");
                #endif

                ((wxNativeFontInfo_php*)native_object)->SetPointSize((int) pointsize0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNativeFontInfo::SetPointSize\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxNativeFontInfo::SetStyle(wxFontStyle style) */
PHP_METHOD(php_wxNativeFontInfo, SetStyle)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNativeFontInfo::SetStyle\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* current_object;
    wxphp_object_type current_object_type;
    wxNativeFontInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNativeFontInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNativeFontInfo::SetStyle call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
                references = &((wxNativeFontInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long style0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&style0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &style0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxNativeFontInfo::SetStyle((wxFontStyle) style0)\n\n");
                #endif

                ((wxNativeFontInfo_php*)native_object)->SetStyle((wxFontStyle) style0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNativeFontInfo::SetStyle\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxNativeFontInfo::SetUnderlined(bool underlined) */
PHP_METHOD(php_wxNativeFontInfo, SetUnderlined)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNativeFontInfo::SetUnderlined\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* current_object;
    wxphp_object_type current_object_type;
    wxNativeFontInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNativeFontInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNativeFontInfo::SetUnderlined call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
                references = &((wxNativeFontInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool underlined0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'b' (&underlined0)\n");
        #endif

        char parse_parameters_string[] = "b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &underlined0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxNativeFontInfo::SetUnderlined(underlined0)\n\n");
                #endif

                ((wxNativeFontInfo_php*)native_object)->SetUnderlined(underlined0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNativeFontInfo::SetUnderlined\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxNativeFontInfo::SetWeight(wxFontWeight weight) */
PHP_METHOD(php_wxNativeFontInfo, SetWeight)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNativeFontInfo::SetWeight\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* current_object;
    wxphp_object_type current_object_type;
    wxNativeFontInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNativeFontInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNativeFontInfo::SetWeight call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
                references = &((wxNativeFontInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long weight0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&weight0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &weight0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxNativeFontInfo::SetWeight((wxFontWeight) weight0)\n\n");
                #endif

                ((wxNativeFontInfo_php*)native_object)->SetWeight((wxFontWeight) weight0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNativeFontInfo::SetWeight\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxNativeFontInfo::ToString() */
PHP_METHOD(php_wxNativeFontInfo, ToString)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNativeFontInfo::ToString\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* current_object;
    wxphp_object_type current_object_type;
    wxNativeFontInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNativeFontInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNativeFontInfo::ToString call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
                references = &((wxNativeFontInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxNativeFontInfo::ToString().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxNativeFontInfo_php*)native_object)->ToString();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNativeFontInfo::ToString\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxNativeFontInfo::ToUserString() */
PHP_METHOD(php_wxNativeFontInfo, ToUserString)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNativeFontInfo::ToUserString\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNativeFontInfo* current_object;
    wxphp_object_type current_object_type;
    wxNativeFontInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNativeFontInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNativeFontInfo::ToUserString call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
                references = &((wxNativeFontInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxNativeFontInfo::ToUserString().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxNativeFontInfo_php*)native_object)->ToUserString();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNativeFontInfo::ToUserString\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxColourDatabase_free(void *object)
{
    zo_wxColourDatabase* custom_object = (zo_wxColourDatabase*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxColourDatabase_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxColourDatabase done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxColourDatabase_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxColourDatabase_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxColourDatabase* custom_object;

    custom_object = (zo_wxColourDatabase*) ecalloc(
        1,
        sizeof(zo_wxColourDatabase)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxColourDatabase_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXCOLOURDATABASE_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxColourDatabase::AddColour(string colourName, wxColour colour)
   Adds a colour to the database. */
PHP_METHOD(php_wxColourDatabase, AddColour)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxColourDatabase::AddColour\n");
    php_printf("===========================================\n");
    #endif

    zo_wxColourDatabase* current_object;
    wxphp_object_type current_object_type;
    wxColourDatabase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxColourDatabase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxColourDatabase::AddColour call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCOLOURDATABASE_TYPE){
                references = &((wxColourDatabase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* colourName0;
    size_t colourName_len0;
    zval* colour0;
    wxColour* object_pointer0_1 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sO' (&colourName0, &colourName_len0, &colour0, php_wxColour_entry)\n");
        #endif

        char parse_parameters_string[] = "sO";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &colourName0, &colourName_len0, &colour0, php_wxColour_entry ) == SUCCESS)
        {
            if(arguments_received >= 2){
                if(Z_TYPE_P(colour0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxColour_P(colour0)->object_type;
                    argument_native_object = (void*) Z_wxColour_P(colour0)->native_object;
                    object_pointer0_1 = (wxColour*) argument_native_object;
                    if (!object_pointer0_1 )
                    {
                        zend_error(E_ERROR, "Parameter 'colour' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(colour0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'colour' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxColourDatabase::AddColour(wxString(colourName0, wxConvUTF8), *(wxColour*) object_pointer0_1)\n\n");
                #endif

                ((wxColourDatabase_php*)native_object)->AddColour(wxString(colourName0, wxConvUTF8), *(wxColour*) object_pointer0_1);

                references->AddReference(colour0, "wxColourDatabase::AddColour at call 3 with 2 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxColourDatabase::AddColour\n"
        );
    }
}
/* }}} */

/* {{{ proto wxColour wxColourDatabase::Find(string colourName)
   Finds a colour given the name. */
PHP_METHOD(php_wxColourDatabase, Find)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxColourDatabase::Find\n");
    php_printf("===========================================\n");
    #endif

    zo_wxColourDatabase* current_object;
    wxphp_object_type current_object_type;
    wxColourDatabase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxColourDatabase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxColourDatabase::Find call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCOLOURDATABASE_TYPE){
                references = &((wxColourDatabase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* colourName0;
    size_t colourName_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&colourName0, &colourName_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &colourName0, &colourName_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxColourDatabase::Find(wxString(colourName0, wxConvUTF8)) to return new object\n\n");
                #endif

                wxColour value_to_return1;
                value_to_return1 = ((wxColourDatabase_php*)native_object)->Find(wxString(colourName0, wxConvUTF8));
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxColour));
                object_init_ex(return_value, php_wxColour_entry);
                ((wxColour_php*)ptr)->phpObj = *return_value;
                zo_wxColour* zo1 = Z_wxColour_P(return_value);
                zo1->native_object = (wxColour_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxColourDatabase::Find\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxColourDatabase::FindName(wxColour colour)
   Finds a colour name given the colour. */
PHP_METHOD(php_wxColourDatabase, FindName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxColourDatabase::FindName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxColourDatabase* current_object;
    wxphp_object_type current_object_type;
    wxColourDatabase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxColourDatabase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxColourDatabase::FindName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCOLOURDATABASE_TYPE){
                references = &((wxColourDatabase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* colour0;
    wxColour* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&colour0, php_wxColour_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &colour0, php_wxColour_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(colour0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxColour_P(colour0)->object_type;
                    argument_native_object = (void*) Z_wxColour_P(colour0)->native_object;
                    object_pointer0_0 = (wxColour*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'colour' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(colour0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'colour' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxColourDatabase::FindName(*(wxColour*) object_pointer0_0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = ((wxColourDatabase_php*)native_object)->FindName(*(wxColour*) object_pointer0_0);
                RETVAL_STRING(value_to_return1.ToUTF8().data());

                references->AddReference(colour0, "wxColourDatabase::FindName at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxColourDatabase::FindName\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxColourDatabase::wxColourDatabase()
   Constructs the colour database. */
PHP_METHOD(php_wxColourDatabase, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxColourDatabase::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxColourDatabase* current_object;
    wxColourDatabase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxColourDatabase_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxColourDatabase_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxColourDatabase::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGDIObject_free(void *object)
{
    zo_wxGDIObject* custom_object = (zo_wxGDIObject*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGDIObject_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxGDIObject done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxGDIObject_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGDIObject_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxGDIObject* custom_object;

    custom_object = (zo_wxGDIObject*) ecalloc(
        1,
        sizeof(zo_wxGDIObject)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxGDIObject_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGDIOBJECT_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

BEGIN_EXTERN_C()
void php_wxGraphicsRenderer_free(void *object)
{
    zo_wxGraphicsRenderer* custom_object = (zo_wxGraphicsRenderer*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGraphicsRenderer_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxGraphicsRenderer done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxGraphicsRenderer_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGraphicsRenderer_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxGraphicsRenderer* custom_object;

    custom_object = (zo_wxGraphicsRenderer*) ecalloc(
        1,
        sizeof(zo_wxGraphicsRenderer)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxGraphicsRenderer_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRAPHICSRENDERER_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

BEGIN_EXTERN_C()
void php_wxGraphicsMatrix_free(void *object)
{
    zo_wxGraphicsMatrix* custom_object = (zo_wxGraphicsMatrix*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGraphicsMatrix_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxGraphicsMatrix done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxGraphicsMatrix_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGraphicsMatrix_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxGraphicsMatrix* custom_object;

    custom_object = (zo_wxGraphicsMatrix*) ecalloc(
        1,
        sizeof(zo_wxGraphicsMatrix)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxGraphicsMatrix_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRAPHICSMATRIX_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

BEGIN_EXTERN_C()
void php_wxIcon_free(void *object)
{
    zo_wxIcon* custom_object = (zo_wxIcon*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxIcon_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxIcon done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxIcon_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxIcon_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxIcon* custom_object;

    custom_object = (zo_wxIcon*) ecalloc(
        1,
        sizeof(zo_wxIcon)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxIcon_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXICON_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxIcon::wxIcon()
   Default ctor. */
PHP_METHOD(php_wxIcon, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxIcon::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxIcon* current_object;
    wxIcon_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    zval* icon1;
    wxIcon* object_pointer1_0 = 0;
    bool overload1_called = false;

    //Parameters for overload 2
    char* name2;
    size_t name_len2;
    long type2;
    long desiredWidth2;
    long desiredHeight2;
    bool overload2_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&icon1, php_wxIcon_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &icon1, php_wxIcon_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(icon1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxIcon_P(icon1)->object_type;
                    argument_native_object = (void*) Z_wxIcon_P(icon1)->native_object;
                    object_pointer1_0 = (wxIcon*) argument_native_object;
                    if (!object_pointer1_0 )
                    {
                        goto overload2;
                    }
                }
                else if(Z_TYPE_P(icon1) != IS_NULL)
                {
                    goto overload2;
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received >= 1  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|lll' (&name2, &name_len2, &type2, &desiredWidth2, &desiredHeight2)\n");
        #endif

        char parse_parameters_string[] = "s|lll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name2, &name_len2, &type2, &desiredWidth2, &desiredHeight2 ) == SUCCESS)
        {
            overload2_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxIcon_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxIcon*) object_pointer1_0)\n");
                #endif

                native_object = new wxIcon_php(*(wxIcon*) object_pointer1_0);

                native_object->references.Initialize();
                ((wxIcon_php*) native_object)->references.AddReference(icon1, "wxIcon::wxIcon at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(name2, wxConvUTF8))\n");
                #endif

                native_object = new wxIcon_php(wxString(name2, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(name2, wxConvUTF8), (wxBitmapType) type2)\n");
                #endif

                native_object = new wxIcon_php(wxString(name2, wxConvUTF8), (wxBitmapType) type2);

                native_object->references.Initialize();
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(name2, wxConvUTF8), (wxBitmapType) type2, (int) desiredWidth2)\n");
                #endif

                native_object = new wxIcon_php(wxString(name2, wxConvUTF8), (wxBitmapType) type2, (int) desiredWidth2);

                native_object->references.Initialize();
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(name2, wxConvUTF8), (wxBitmapType) type2, (int) desiredWidth2, (int) desiredHeight2)\n");
                #endif

                native_object = new wxIcon_php(wxString(name2, wxConvUTF8), (wxBitmapType) type2, (int) desiredWidth2, (int) desiredHeight2);

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxIcon_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxIcon::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto bool wxIcon::LoadFile(string name, wxBitmapType type, int desiredWidth, int desiredHeight)
   Loads an icon from a file or resource. */
PHP_METHOD(php_wxIcon, LoadFile)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxIcon::LoadFile\n");
    php_printf("===========================================\n");
    #endif

    zo_wxIcon* current_object;
    wxphp_object_type current_object_type;
    wxIcon_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxIcon_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxIcon::LoadFile call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXICON_TYPE){
                references = &((wxIcon_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    long type0;
    bool overload0_called = false;

    //Parameters for overload 1
    char* name1;
    size_t name_len1;
    long type1;
    long desiredWidth1;
    long desiredHeight1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|l' (&name0, &name_len0, &type0)\n");
        #endif

        char parse_parameters_string[] = "s|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0, &type0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'slll' (&name1, &name_len1, &type1, &desiredWidth1, &desiredHeight1)\n");
        #endif

        char parse_parameters_string[] = "slll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name1, &name_len1, &type1, &desiredWidth1, &desiredHeight1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxIcon::LoadFile(wxString(name0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxIcon_php*)native_object)->LoadFile(wxString(name0, wxConvUTF8)));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxIcon::LoadFile(wxString(name0, wxConvUTF8), (wxBitmapType) type0))\n\n");
                #endif

                RETVAL_BOOL(((wxIcon_php*)native_object)->LoadFile(wxString(name0, wxConvUTF8), (wxBitmapType) type0));


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxIcon::LoadFile(wxString(name1, wxConvUTF8), (wxBitmapType) type1, (int) desiredWidth1, (int) desiredHeight1))\n\n");
                #endif

                RETVAL_BOOL(((wxIcon_php*)native_object)->LoadFile(wxString(name1, wxConvUTF8), (wxBitmapType) type1, (int) desiredWidth1, (int) desiredHeight1));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxIcon::LoadFile\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxIcon::IsOk()
   Returns true if icon data is present. */
PHP_METHOD(php_wxIcon, IsOk)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxIcon::IsOk\n");
    php_printf("===========================================\n");
    #endif

    zo_wxIcon* current_object;
    wxphp_object_type current_object_type;
    wxIcon_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxIcon_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxIcon::IsOk call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXICON_TYPE){
                references = &((wxIcon_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxIcon::IsOk())\n\n");
                #endif

                RETVAL_BOOL(((wxIcon_php*)native_object)->IsOk());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxIcon::IsOk\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxIcon::GetWidth()
   Gets the width of the icon in physical pixels. */
PHP_METHOD(php_wxIcon, GetWidth)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxIcon::GetWidth\n");
    php_printf("===========================================\n");
    #endif

    zo_wxIcon* current_object;
    wxphp_object_type current_object_type;
    wxIcon_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxIcon_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxIcon::GetWidth call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXICON_TYPE){
                references = &((wxIcon_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxIcon::GetWidth())\n\n");
                #endif

                RETVAL_LONG(((wxIcon_php*)native_object)->GetWidth());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxIcon::GetWidth\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxIcon::GetHeight()
   Gets the height of the icon in physical pixels. */
PHP_METHOD(php_wxIcon, GetHeight)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxIcon::GetHeight\n");
    php_printf("===========================================\n");
    #endif

    zo_wxIcon* current_object;
    wxphp_object_type current_object_type;
    wxIcon_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxIcon_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxIcon::GetHeight call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXICON_TYPE){
                references = &((wxIcon_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxIcon::GetHeight())\n\n");
                #endif

                RETVAL_LONG(((wxIcon_php*)native_object)->GetHeight());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxIcon::GetHeight\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxIcon::GetDepth()
   Gets the colour depth of the icon. */
PHP_METHOD(php_wxIcon, GetDepth)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxIcon::GetDepth\n");
    php_printf("===========================================\n");
    #endif

    zo_wxIcon* current_object;
    wxphp_object_type current_object_type;
    wxIcon_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxIcon_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxIcon::GetDepth call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXICON_TYPE){
                references = &((wxIcon_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxIcon::GetDepth())\n\n");
                #endif

                RETVAL_LONG(((wxIcon_php*)native_object)->GetDepth());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxIcon::GetDepth\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxIcon::CopyFromBitmap(wxBitmap bmp)
   Copies bmp bitmap to this icon. */
PHP_METHOD(php_wxIcon, CopyFromBitmap)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxIcon::CopyFromBitmap\n");
    php_printf("===========================================\n");
    #endif

    zo_wxIcon* current_object;
    wxphp_object_type current_object_type;
    wxIcon_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxIcon_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxIcon::CopyFromBitmap call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXICON_TYPE){
                references = &((wxIcon_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* bmp0;
    wxBitmap* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&bmp0, php_wxBitmap_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bmp0, php_wxBitmap_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bmp0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bmp0)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bmp0)->native_object;
                    object_pointer0_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'bmp' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(bmp0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'bmp' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxIcon::CopyFromBitmap(*(wxBitmap*) object_pointer0_0)\n\n");
                #endif

                ((wxIcon_php*)native_object)->CopyFromBitmap(*(wxBitmap*) object_pointer0_0);

                references->AddReference(bmp0, "wxIcon::CopyFromBitmap at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxIcon::CopyFromBitmap\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxIconBundle_free(void *object)
{
    zo_wxIconBundle* custom_object = (zo_wxIconBundle*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxIconBundle_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxIconBundle done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxIconBundle_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxIconBundle_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxIconBundle* custom_object;

    custom_object = (zo_wxIconBundle*) ecalloc(
        1,
        sizeof(zo_wxIconBundle)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxIconBundle_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXICONBUNDLE_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxIconBundle::wxIconBundle()
   Default ctor. */
PHP_METHOD(php_wxIconBundle, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxIconBundle::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxIconBundle* current_object;
    wxIconBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    char* file1;
    size_t file_len1;
    long type1;
    bool overload1_called = false;

    //Parameters for overload 2
    zval* stream2;
    wxInputStream* object_pointer2_0 = 0;
    long type2;
    bool overload2_called = false;

    //Parameters for overload 3
    zval* icon3;
    wxIcon* object_pointer3_0 = 0;
    bool overload3_called = false;

    //Parameters for overload 4
    zval* ic4;
    wxIconBundle* object_pointer4_0 = 0;
    bool overload4_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|l' (&file1, &file_len1, &type1)\n");
        #endif

        char parse_parameters_string[] = "s|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &file1, &file_len1, &type1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'o|l' (&stream2, &type2)\n");
        #endif

        char parse_parameters_string[] = "o|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &stream2, &type2 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(stream2) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxInputStream_P(stream2)->object_type;
                    argument_native_object = (void*) Z_wxInputStream_P(stream2)->native_object;
                    object_pointer2_0 = (wxInputStream*) argument_native_object;
                    if (!object_pointer2_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
                    {
                        goto overload3;
                    }
                }
                else if(Z_TYPE_P(stream2) != IS_NULL)
                {
                    goto overload3;
                }
            }

            overload2_called = true;
            already_called = true;
        }
    }

    //Overload 3
    overload3:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&icon3, php_wxIcon_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &icon3, php_wxIcon_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(icon3) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxIcon_P(icon3)->object_type;
                    argument_native_object = (void*) Z_wxIcon_P(icon3)->native_object;
                    object_pointer3_0 = (wxIcon*) argument_native_object;
                    if (!object_pointer3_0 )
                    {
                        goto overload4;
                    }
                }
                else if(Z_TYPE_P(icon3) != IS_NULL)
                {
                    goto overload4;
                }
            }

            overload3_called = true;
            already_called = true;
        }
    }

    //Overload 4
    overload4:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&ic4, php_wxIconBundle_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &ic4, php_wxIconBundle_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(ic4) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxIconBundle_P(ic4)->object_type;
                    argument_native_object = (void*) Z_wxIconBundle_P(ic4)->native_object;
                    object_pointer4_0 = (wxIconBundle*) argument_native_object;
                    if (!object_pointer4_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'ic' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(ic4) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'ic' not null, could not be retreived correctly.");
                }
            }

            overload4_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxIconBundle_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(file1, wxConvUTF8))\n");
                #endif

                native_object = new wxIconBundle_php(wxString(file1, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(file1, wxConvUTF8), (wxBitmapType) type1)\n");
                #endif

                native_object = new wxIconBundle_php(wxString(file1, wxConvUTF8), (wxBitmapType) type1);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxInputStream*) object_pointer2_0)\n");
                #endif

                native_object = new wxIconBundle_php(*(wxInputStream*) object_pointer2_0);

                native_object->references.Initialize();
                ((wxIconBundle_php*) native_object)->references.AddReference(stream2, "wxIconBundle::wxIconBundle at call 4 with 1 argument(s)");
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxInputStream*) object_pointer2_0, (wxBitmapType) type2)\n");
                #endif

                native_object = new wxIconBundle_php(*(wxInputStream*) object_pointer2_0, (wxBitmapType) type2);

                native_object->references.Initialize();
                ((wxIconBundle_php*) native_object)->references.AddReference(stream2, "wxIconBundle::wxIconBundle at call 4 with 2 argument(s)");
                break;
            }
        }
    }

    if(overload3_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxIcon*) object_pointer3_0)\n");
                #endif

                native_object = new wxIconBundle_php(*(wxIcon*) object_pointer3_0);

                native_object->references.Initialize();
                ((wxIconBundle_php*) native_object)->references.AddReference(icon3, "wxIconBundle::wxIconBundle at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    if(overload4_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxIconBundle*) object_pointer4_0)\n");
                #endif

                native_object = new wxIconBundle_php(*(wxIconBundle*) object_pointer4_0);

                native_object->references.Initialize();
                ((wxIconBundle_php*) native_object)->references.AddReference(ic4, "wxIconBundle::wxIconBundle at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxIconBundle_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxIconBundle::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto bool wxIconBundle::IsEmpty()
   Returns true if the bundle doesn't contain any icons, false otherwise (in which case a call to GetIcon() with default parameter should return a valid icon). */
PHP_METHOD(php_wxIconBundle, IsEmpty)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxIconBundle::IsEmpty\n");
    php_printf("===========================================\n");
    #endif

    zo_wxIconBundle* current_object;
    wxphp_object_type current_object_type;
    wxIconBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxIconBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxIconBundle::IsEmpty call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXICONBUNDLE_TYPE){
                references = &((wxIconBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxIconBundle::IsEmpty())\n\n");
                #endif

                RETVAL_BOOL(((wxIconBundle_php*)native_object)->IsEmpty());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxIconBundle::IsEmpty\n"
        );
    }
}
/* }}} */

/* {{{ proto wxIcon wxIconBundle::GetIconOfExactSize(wxSize size)
   Returns the icon with exactly the given size or wxNullIcon if this size is not available. */
PHP_METHOD(php_wxIconBundle, GetIconOfExactSize)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxIconBundle::GetIconOfExactSize\n");
    php_printf("===========================================\n");
    #endif

    zo_wxIconBundle* current_object;
    wxphp_object_type current_object_type;
    wxIconBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxIconBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxIconBundle::GetIconOfExactSize call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXICONBUNDLE_TYPE){
                references = &((wxIconBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* size0;
    wxSize* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&size0, php_wxSize_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &size0, php_wxSize_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(size0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(size0)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(size0)->native_object;
                    object_pointer0_0 = (wxSize*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(size0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxIconBundle::GetIconOfExactSize(*(wxSize*) object_pointer0_0) to return new object\n\n");
                #endif

                wxIcon value_to_return1;
                value_to_return1 = ((wxIconBundle_php*)native_object)->GetIconOfExactSize(*(wxSize*) object_pointer0_0);
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxIcon));
                object_init_ex(return_value, php_wxIcon_entry);
                ((wxIcon_php*)ptr)->phpObj = *return_value;
                zo_wxIcon* zo1 = Z_wxIcon_P(return_value);
                zo1->native_object = (wxIcon_php*) ptr;

                references->AddReference(size0, "wxIconBundle::GetIconOfExactSize at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxIconBundle::GetIconOfExactSize\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxIconBundle::GetIconCount()
   return the number of available icons */
PHP_METHOD(php_wxIconBundle, GetIconCount)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxIconBundle::GetIconCount\n");
    php_printf("===========================================\n");
    #endif

    zo_wxIconBundle* current_object;
    wxphp_object_type current_object_type;
    wxIconBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxIconBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxIconBundle::GetIconCount call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXICONBUNDLE_TYPE){
                references = &((wxIconBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxIconBundle::GetIconCount())\n\n");
                #endif

                RETVAL_LONG(((wxIconBundle_php*)native_object)->GetIconCount());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxIconBundle::GetIconCount\n"
        );
    }
}
/* }}} */

/* {{{ proto wxIcon wxIconBundle::GetIconByIndex(int n)
   return the icon at index (must be < GetIconCount()) */
PHP_METHOD(php_wxIconBundle, GetIconByIndex)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxIconBundle::GetIconByIndex\n");
    php_printf("===========================================\n");
    #endif

    zo_wxIconBundle* current_object;
    wxphp_object_type current_object_type;
    wxIconBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxIconBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxIconBundle::GetIconByIndex call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXICONBUNDLE_TYPE){
                references = &((wxIconBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long n0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&n0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &n0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxIconBundle::GetIconByIndex((size_t) n0) to return new object\n\n");
                #endif

                wxIcon value_to_return1;
                value_to_return1 = ((wxIconBundle_php*)native_object)->GetIconByIndex((size_t) n0);
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxIcon));
                object_init_ex(return_value, php_wxIcon_entry);
                ((wxIcon_php*)ptr)->phpObj = *return_value;
                zo_wxIcon* zo1 = Z_wxIcon_P(return_value);
                zo1->native_object = (wxIcon_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxIconBundle::GetIconByIndex\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxIconBundle::AddIcon(string file, wxBitmapType type)
   Adds all the icons contained in the file to the bundle; if the collection already contains icons with the same width and height, they are replaced by the new ones. */
PHP_METHOD(php_wxIconBundle, AddIcon)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxIconBundle::AddIcon\n");
    php_printf("===========================================\n");
    #endif

    zo_wxIconBundle* current_object;
    wxphp_object_type current_object_type;
    wxIconBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxIconBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxIconBundle::AddIcon call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXICONBUNDLE_TYPE){
                references = &((wxIconBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* file0;
    size_t file_len0;
    long type0;
    bool overload0_called = false;

    //Parameters for overload 1
    zval* stream1;
    wxInputStream* object_pointer1_0 = 0;
    long type1;
    bool overload1_called = false;

    //Parameters for overload 2
    zval* icon2;
    wxIcon* object_pointer2_0 = 0;
    bool overload2_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|l' (&file0, &file_len0, &type0)\n");
        #endif

        char parse_parameters_string[] = "s|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &file0, &file_len0, &type0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'o|l' (&stream1, &type1)\n");
        #endif

        char parse_parameters_string[] = "o|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &stream1, &type1 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(stream1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxInputStream_P(stream1)->object_type;
                    argument_native_object = (void*) Z_wxInputStream_P(stream1)->native_object;
                    object_pointer1_0 = (wxInputStream*) argument_native_object;
                    if (!object_pointer1_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
                    {
                        goto overload2;
                    }
                }
                else if(Z_TYPE_P(stream1) != IS_NULL)
                {
                    goto overload2;
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&icon2, php_wxIcon_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &icon2, php_wxIcon_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(icon2) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxIcon_P(icon2)->object_type;
                    argument_native_object = (void*) Z_wxIcon_P(icon2)->native_object;
                    object_pointer2_0 = (wxIcon*) argument_native_object;
                    if (!object_pointer2_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'icon' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(icon2) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'icon' not null, could not be retreived correctly.");
                }
            }

            overload2_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxIconBundle::AddIcon(wxString(file0, wxConvUTF8))\n\n");
                #endif

                ((wxIconBundle_php*)native_object)->AddIcon(wxString(file0, wxConvUTF8));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxIconBundle::AddIcon(wxString(file0, wxConvUTF8), (wxBitmapType) type0)\n\n");
                #endif

                ((wxIconBundle_php*)native_object)->AddIcon(wxString(file0, wxConvUTF8), (wxBitmapType) type0);


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxIconBundle::AddIcon(*(wxInputStream*) object_pointer1_0)\n\n");
                #endif

                ((wxIconBundle_php*)native_object)->AddIcon(*(wxInputStream*) object_pointer1_0);

                references->AddReference(stream1, "wxIconBundle::AddIcon at call 3 with 1 argument(s)");

                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxIconBundle::AddIcon(*(wxInputStream*) object_pointer1_0, (wxBitmapType) type1)\n\n");
                #endif

                ((wxIconBundle_php*)native_object)->AddIcon(*(wxInputStream*) object_pointer1_0, (wxBitmapType) type1);

                references->AddReference(stream1, "wxIconBundle::AddIcon at call 3 with 2 argument(s)");

                return;
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxIconBundle::AddIcon(*(wxIcon*) object_pointer2_0)\n\n");
                #endif

                ((wxIconBundle_php*)native_object)->AddIcon(*(wxIcon*) object_pointer2_0);

                references->AddReference(icon2, "wxIconBundle::AddIcon at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxIconBundle::AddIcon\n"
        );
    }
}
/* }}} */

/* {{{ proto wxIcon wxIconBundle::GetIcon(wxSize size, int flags)
   Returns the icon with the given size. */
PHP_METHOD(php_wxIconBundle, GetIcon)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxIconBundle::GetIcon\n");
    php_printf("===========================================\n");
    #endif

    zo_wxIconBundle* current_object;
    wxphp_object_type current_object_type;
    wxIconBundle_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxIconBundle_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxIconBundle::GetIcon call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXICONBUNDLE_TYPE){
                references = &((wxIconBundle_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* size0;
    wxSize* object_pointer0_0 = 0;
    long flags0;
    bool overload0_called = false;

    //Parameters for overload 1
    long size1;
    long flags1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O|l' (&size0, php_wxSize_entry, &flags0)\n");
        #endif

        char parse_parameters_string[] = "O|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &size0, php_wxSize_entry, &flags0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(size0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(size0)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(size0)->native_object;
                    object_pointer0_0 = (wxSize*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        goto overload1;
                    }
                }
                else if(Z_TYPE_P(size0) != IS_NULL)
                {
                    goto overload1;
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 0  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|ll' (&size1, &flags1)\n");
        #endif

        char parse_parameters_string[] = "|ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &size1, &flags1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxIconBundle::GetIcon(*(wxSize*) object_pointer0_0) to return new object\n\n");
                #endif

                wxIcon value_to_return1;
                value_to_return1 = ((wxIconBundle_php*)native_object)->GetIcon(*(wxSize*) object_pointer0_0);
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxIcon));
                object_init_ex(return_value, php_wxIcon_entry);
                ((wxIcon_php*)ptr)->phpObj = *return_value;
                zo_wxIcon* zo1 = Z_wxIcon_P(return_value);
                zo1->native_object = (wxIcon_php*) ptr;

                references->AddReference(size0, "wxIconBundle::GetIcon at call 3 with 1 argument(s)");

                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxIconBundle::GetIcon(*(wxSize*) object_pointer0_0, (int) flags0) to return new object\n\n");
                #endif

                wxIcon value_to_return2;
                value_to_return2 = ((wxIconBundle_php*)native_object)->GetIcon(*(wxSize*) object_pointer0_0, (int) flags0);
                ((wxRefCounter *) value_to_return2.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
                memcpy(ptr, (void*) &value_to_return2, sizeof(wxIcon));
                object_init_ex(return_value, php_wxIcon_entry);
                ((wxIcon_php*)ptr)->phpObj = *return_value;
                zo_wxIcon* zo2 = Z_wxIcon_P(return_value);
                zo2->native_object = (wxIcon_php*) ptr;

                references->AddReference(size0, "wxIconBundle::GetIcon at call 3 with 2 argument(s)");

                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxIconBundle::GetIcon() to return new object\n\n");
                #endif

                wxIcon value_to_return0;
                value_to_return0 = ((wxIconBundle_php*)native_object)->GetIcon();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxIcon));
                object_init_ex(return_value, php_wxIcon_entry);
                ((wxIcon_php*)ptr)->phpObj = *return_value;
                zo_wxIcon* zo0 = Z_wxIcon_P(return_value);
                zo0->native_object = (wxIcon_php*) ptr;


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxIconBundle::GetIcon((wxCoord) size1) to return new object\n\n");
                #endif

                wxIcon value_to_return1;
                value_to_return1 = ((wxIconBundle_php*)native_object)->GetIcon((wxCoord) size1);
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxIcon));
                object_init_ex(return_value, php_wxIcon_entry);
                ((wxIcon_php*)ptr)->phpObj = *return_value;
                zo_wxIcon* zo1 = Z_wxIcon_P(return_value);
                zo1->native_object = (wxIcon_php*) ptr;


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxIconBundle::GetIcon((wxCoord) size1, (int) flags1) to return new object\n\n");
                #endif

                wxIcon value_to_return2;
                value_to_return2 = ((wxIconBundle_php*)native_object)->GetIcon((wxCoord) size1, (int) flags1);
                ((wxRefCounter *) value_to_return2.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
                memcpy(ptr, (void*) &value_to_return2, sizeof(wxIcon));
                object_init_ex(return_value, php_wxIcon_entry);
                ((wxIcon_php*)ptr)->phpObj = *return_value;
                zo_wxIcon* zo2 = Z_wxIcon_P(return_value);
                zo2->native_object = (wxIcon_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxIconBundle::GetIcon\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxImageHandler_free(void *object)
{
    zo_wxImageHandler* custom_object = (zo_wxImageHandler*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxImageHandler_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxImageHandler done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxImageHandler_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxImageHandler_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxImageHandler* custom_object;

    custom_object = (zo_wxImageHandler*) ecalloc(
        1,
        sizeof(zo_wxImageHandler)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxImageHandler_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXIMAGEHANDLER_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto bool wxImageHandler::CanRead(wxInputStream &stream)
   Returns true if this handler supports the image format contained in the given stream. */
PHP_METHOD(php_wxImageHandler, CanRead)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageHandler::CanRead\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageHandler* current_object;
    wxphp_object_type current_object_type;
    wxImageHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageHandler::CanRead call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
                references = &((wxImageHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* stream0;
    wxInputStream* object_pointer0_0 = 0;
    bool overload0_called = false;

    //Parameters for overload 1
    char* filename1;
    size_t filename_len1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'o' (&stream0)\n");
        #endif

        char parse_parameters_string[] = "o";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &stream0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(stream0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxInputStream_P(stream0)->object_type;
                    argument_native_object = (void*) Z_wxInputStream_P(stream0)->native_object;
                    object_pointer0_0 = (wxInputStream*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
                    {
                        goto overload1;
                    }
                }
                else if(Z_TYPE_P(stream0) != IS_NULL)
                {
                    goto overload1;
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&filename1, &filename_len1)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &filename1, &filename_len1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImageHandler::CanRead(*(wxInputStream*) object_pointer0_0))\n\n");
                #endif

                if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
                {
                    RETVAL_BOOL(((wxImageHandler_php*)native_object)->CanRead(*(wxInputStream*) object_pointer0_0));
                }

                references->AddReference(stream0, "wxImageHandler::CanRead at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImageHandler::CanRead(wxString(filename1, wxConvUTF8)))\n\n");
                #endif

                if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
                {
                    RETVAL_BOOL(((wxImageHandler_php*)native_object)->CanRead(wxString(filename1, wxConvUTF8)));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageHandler::CanRead\n"
        );
    }
}
/* }}} */

/* {{{ proto array wxImageHandler::GetAltExtensions()
   Returns the other file extensions associated with this handler. */
PHP_METHOD(php_wxImageHandler, GetAltExtensions)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageHandler::GetAltExtensions\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageHandler* current_object;
    wxphp_object_type current_object_type;
    wxImageHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageHandler::GetAltExtensions call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
                references = &((wxImageHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImageHandler::GetAltExtensions() to return strings array\n\n");
                #endif

                wxArrayString value_to_return0;
                if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
                {
                    value_to_return0 = ((wxImageHandler_php*)native_object)->GetAltExtensions();
                }
                array_init(return_value);
                for(size_t i=0; i<value_to_return0.GetCount(); i++)
                {
                    add_next_index_string(return_value, value_to_return0[i].ToUTF8().data());
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageHandler::GetAltExtensions\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxImageHandler::GetExtension()
   Gets the preferred file extension associated with this handler. */
PHP_METHOD(php_wxImageHandler, GetExtension)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageHandler::GetExtension\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageHandler* current_object;
    wxphp_object_type current_object_type;
    wxImageHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageHandler::GetExtension call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
                references = &((wxImageHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxImageHandler::GetExtension().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
                {
                    value_to_return0 = ((wxImageHandler_php*)native_object)->GetExtension();
                }
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageHandler::GetExtension\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxImageHandler::GetImageCount(wxInputStream &stream)
   If the image file contains more than one image and the image handler is capable of retrieving these individually, this function will return the number of available images. */
PHP_METHOD(php_wxImageHandler, GetImageCount)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageHandler::GetImageCount\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageHandler* current_object;
    wxphp_object_type current_object_type;
    wxImageHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageHandler::GetImageCount call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
                references = &((wxImageHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* stream0;
    wxInputStream* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'o' (&stream0)\n");
        #endif

        char parse_parameters_string[] = "o";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &stream0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(stream0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxInputStream_P(stream0)->object_type;
                    argument_native_object = (void*) Z_wxInputStream_P(stream0)->native_object;
                    object_pointer0_0 = (wxInputStream*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'stream' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(stream0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'stream' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxImageHandler::GetImageCount(*(wxInputStream*) object_pointer0_0))\n\n");
                #endif

                if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
                {
                    RETVAL_LONG(((wxImageHandler_php*)native_object)->GetImageCount(*(wxInputStream*) object_pointer0_0));
                }

                references->AddReference(stream0, "wxImageHandler::GetImageCount at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageHandler::GetImageCount\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxImageHandler::GetMimeType()
   Gets the MIME type associated with this handler. */
PHP_METHOD(php_wxImageHandler, GetMimeType)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageHandler::GetMimeType\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageHandler* current_object;
    wxphp_object_type current_object_type;
    wxImageHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageHandler::GetMimeType call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
                references = &((wxImageHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxImageHandler::GetMimeType().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
                {
                    value_to_return0 = ((wxImageHandler_php*)native_object)->GetMimeType();
                }
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageHandler::GetMimeType\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxImageHandler::GetName()
   Gets the name of this handler. */
PHP_METHOD(php_wxImageHandler, GetName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageHandler::GetName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageHandler* current_object;
    wxphp_object_type current_object_type;
    wxImageHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageHandler::GetName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
                references = &((wxImageHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxImageHandler::GetName().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
                {
                    value_to_return0 = ((wxImageHandler_php*)native_object)->GetName();
                }
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageHandler::GetName\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmapType wxImageHandler::GetType()
   Gets the image type associated with this handler. */
PHP_METHOD(php_wxImageHandler, GetType)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageHandler::GetType\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageHandler* current_object;
    wxphp_object_type current_object_type;
    wxImageHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageHandler::GetType call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
                references = &((wxImageHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxImageHandler::GetType())\n\n");
                #endif

                if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
                {
                    RETVAL_LONG(((wxImageHandler_php*)native_object)->GetType());
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageHandler::GetType\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxImageHandler::LoadFile(wxImage &image, wxInputStream &stream, bool verbose, int index)
   Loads an image from a stream, putting the resulting data into image. */
PHP_METHOD(php_wxImageHandler, LoadFile)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageHandler::LoadFile\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageHandler* current_object;
    wxphp_object_type current_object_type;
    wxImageHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageHandler::LoadFile call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
                references = &((wxImageHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* image0;
    wxImage* object_pointer0_0 = 0;
    zval* stream0;
    wxInputStream* object_pointer0_1 = 0;
    bool verbose0;
    long index0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 2  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'zo|bl' (&image0, &stream0, &verbose0, &index0)\n");
        #endif

        char parse_parameters_string[] = "zo|bl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &image0, &stream0, &verbose0, &index0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(image0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxImage_P(image0)->object_type;
                    argument_native_object = (void*) Z_wxImage_P(image0)->native_object;
                    object_pointer0_0 = (wxImage*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXIMAGE_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'image' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(image0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'image' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 2){
                if(Z_TYPE_P(stream0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxInputStream_P(stream0)->object_type;
                    argument_native_object = (void*) Z_wxInputStream_P(stream0)->native_object;
                    object_pointer0_1 = (wxInputStream*) argument_native_object;
                    if (!object_pointer0_1 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'stream' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(stream0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'stream' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImageHandler::LoadFile((wxImage*) object_pointer0_0, *(wxInputStream*) object_pointer0_1))\n\n");
                #endif

                if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
                {
                    RETVAL_BOOL(((wxImageHandler_php*)native_object)->LoadFile((wxImage*) object_pointer0_0, *(wxInputStream*) object_pointer0_1));
                }

                references->AddReference(image0, "wxImageHandler::LoadFile at call 1 with 2 argument(s)");
                references->AddReference(stream0, "wxImageHandler::LoadFile at call 3 with 2 argument(s)");

                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImageHandler::LoadFile((wxImage*) object_pointer0_0, *(wxInputStream*) object_pointer0_1, verbose0))\n\n");
                #endif

                if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
                {
                    RETVAL_BOOL(((wxImageHandler_php*)native_object)->LoadFile((wxImage*) object_pointer0_0, *(wxInputStream*) object_pointer0_1, verbose0));
                }

                references->AddReference(image0, "wxImageHandler::LoadFile at call 1 with 3 argument(s)");
                references->AddReference(stream0, "wxImageHandler::LoadFile at call 3 with 3 argument(s)");

                return;
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImageHandler::LoadFile((wxImage*) object_pointer0_0, *(wxInputStream*) object_pointer0_1, verbose0, (int) index0))\n\n");
                #endif

                if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
                {
                    RETVAL_BOOL(((wxImageHandler_php*)native_object)->LoadFile((wxImage*) object_pointer0_0, *(wxInputStream*) object_pointer0_1, verbose0, (int) index0));
                }

                references->AddReference(image0, "wxImageHandler::LoadFile at call 1 with 4 argument(s)");
                references->AddReference(stream0, "wxImageHandler::LoadFile at call 3 with 4 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageHandler::LoadFile\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxImageHandler::SaveFile(wxImage &image, wxOutputStream &stream, bool verbose)
   Saves an image in the output stream. */
PHP_METHOD(php_wxImageHandler, SaveFile)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageHandler::SaveFile\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageHandler* current_object;
    wxphp_object_type current_object_type;
    wxImageHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageHandler::SaveFile call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
                references = &((wxImageHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* image0;
    wxImage* object_pointer0_0 = 0;
    zval* stream0;
    wxOutputStream* object_pointer0_1 = 0;
    bool verbose0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'zo|b' (&image0, &stream0, &verbose0)\n");
        #endif

        char parse_parameters_string[] = "zo|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &image0, &stream0, &verbose0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(image0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxImage_P(image0)->object_type;
                    argument_native_object = (void*) Z_wxImage_P(image0)->native_object;
                    object_pointer0_0 = (wxImage*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXIMAGE_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'image' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(image0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'image' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 2){
                if(Z_TYPE_P(stream0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxOutputStream_P(stream0)->object_type;
                    argument_native_object = (void*) Z_wxOutputStream_P(stream0)->native_object;
                    object_pointer0_1 = (wxOutputStream*) argument_native_object;
                    if (!object_pointer0_1 || (argument_type != PHP_WXOUTPUTSTREAM_TYPE && argument_type != PHP_WXFFILEOUTPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEOUTPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'stream' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(stream0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'stream' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImageHandler::SaveFile((wxImage*) object_pointer0_0, *(wxOutputStream*) object_pointer0_1))\n\n");
                #endif

                if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
                {
                    RETVAL_BOOL(((wxImageHandler_php*)native_object)->SaveFile((wxImage*) object_pointer0_0, *(wxOutputStream*) object_pointer0_1));
                }

                references->AddReference(image0, "wxImageHandler::SaveFile at call 1 with 2 argument(s)");
                references->AddReference(stream0, "wxImageHandler::SaveFile at call 3 with 2 argument(s)");

                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImageHandler::SaveFile((wxImage*) object_pointer0_0, *(wxOutputStream*) object_pointer0_1, verbose0))\n\n");
                #endif

                if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
                {
                    RETVAL_BOOL(((wxImageHandler_php*)native_object)->SaveFile((wxImage*) object_pointer0_0, *(wxOutputStream*) object_pointer0_1, verbose0));
                }

                references->AddReference(image0, "wxImageHandler::SaveFile at call 1 with 3 argument(s)");
                references->AddReference(stream0, "wxImageHandler::SaveFile at call 3 with 3 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageHandler::SaveFile\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImageHandler::SetAltExtensions(array extensions)
   Sets the alternative file extensions associated with this handler. */
PHP_METHOD(php_wxImageHandler, SetAltExtensions)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageHandler::SetAltExtensions\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageHandler* current_object;
    wxphp_object_type current_object_type;
    wxImageHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageHandler::SetAltExtensions call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
                references = &((wxImageHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* extensions0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'a' (&extensions0)\n");
        #endif

        char parse_parameters_string[] = "a";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &extensions0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        wxArrayString strings_array0_0;
        bool strings_continue0_0 = true;

        switch(arguments_received)
        {
            case 1:
            {
                int array_index0_0 = 0;
                zval* temp_array_value0_0 = 0;
                while(strings_continue0_0)
                {
                    if((temp_array_value0_0 = zend_hash_index_find(HASH_OF(extensions0), array_index0_0)) != NULL)
                    {
                        convert_to_string(temp_array_value0_0);
                        strings_array0_0.Add(wxString(Z_STRVAL_P(temp_array_value0_0), wxConvUTF8));
                        array_index0_0++;
                    }
                    else
                    {
                        strings_continue0_0 = false;
                    }
                }
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImageHandler::SetAltExtensions(strings_array0_0)\n\n");
                #endif

                if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
                {
                    ((wxImageHandler_php*)native_object)->SetAltExtensions(strings_array0_0);
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageHandler::SetAltExtensions\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImageHandler::SetExtension(string extension)
   Sets the preferred file extension associated with this handler. */
PHP_METHOD(php_wxImageHandler, SetExtension)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageHandler::SetExtension\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageHandler* current_object;
    wxphp_object_type current_object_type;
    wxImageHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageHandler::SetExtension call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
                references = &((wxImageHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* extension0;
    size_t extension_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&extension0, &extension_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &extension0, &extension_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImageHandler::SetExtension(wxString(extension0, wxConvUTF8))\n\n");
                #endif

                if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
                {
                    ((wxImageHandler_php*)native_object)->SetExtension(wxString(extension0, wxConvUTF8));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageHandler::SetExtension\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImageHandler::SetMimeType(string mimetype)
   Sets the handler MIME type. */
PHP_METHOD(php_wxImageHandler, SetMimeType)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageHandler::SetMimeType\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageHandler* current_object;
    wxphp_object_type current_object_type;
    wxImageHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageHandler::SetMimeType call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
                references = &((wxImageHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* mimetype0;
    size_t mimetype_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&mimetype0, &mimetype_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &mimetype0, &mimetype_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImageHandler::SetMimeType(wxString(mimetype0, wxConvUTF8))\n\n");
                #endif

                if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
                {
                    ((wxImageHandler_php*)native_object)->SetMimeType(wxString(mimetype0, wxConvUTF8));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageHandler::SetMimeType\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImageHandler::SetName(string name)
   Sets the handler name. */
PHP_METHOD(php_wxImageHandler, SetName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageHandler::SetName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageHandler* current_object;
    wxphp_object_type current_object_type;
    wxImageHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageHandler::SetName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
                references = &((wxImageHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImageHandler::SetName(wxString(name0, wxConvUTF8))\n\n");
                #endif

                if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
                {
                    ((wxImageHandler_php*)native_object)->SetName(wxString(name0, wxConvUTF8));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageHandler::SetName\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxImage_free(void *object)
{
    zo_wxImage* custom_object = (zo_wxImage*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxImage_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxImage done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxImage_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxImage_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxImage* custom_object;

    custom_object = (zo_wxImage*) ecalloc(
        1,
        sizeof(zo_wxImage)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxImage_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXIMAGE_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxImage::wxImage()
   Creates an empty wxImage object without an alpha channel. */
PHP_METHOD(php_wxImage, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    long width1;
    long height1;
    bool clear1;
    bool overload1_called = false;

    //Parameters for overload 2
    zval* sz2;
    wxSize* object_pointer2_0 = 0;
    bool clear2;
    bool overload2_called = false;

    //Parameters for overload 3
    long width3;
    long height3;
    long* data3;
    zval data3_ref;
    bool static_data3;
    bool overload3_called = false;

    //Parameters for overload 4
    zval* sz4;
    wxSize* object_pointer4_0 = 0;
    long* data4;
    zval data4_ref;
    bool static_data4;
    bool overload4_called = false;

    //Parameters for overload 5
    long width5;
    long height5;
    long* data5;
    zval data5_ref;
    long* alpha5;
    zval alpha5_ref;
    bool static_data5;
    bool overload5_called = false;

    //Parameters for overload 6
    zval* sz6;
    wxSize* object_pointer6_0 = 0;
    long* data6;
    zval data6_ref;
    long* alpha6;
    zval alpha6_ref;
    bool static_data6;
    bool overload6_called = false;

    //Parameters for overload 7
    char* name7;
    size_t name_len7;
    long type7;
    long index7;
    bool overload7_called = false;

    //Parameters for overload 8
    char* name8;
    size_t name_len8;
    char* mimetype8;
    size_t mimetype_len8;
    long index8;
    bool overload8_called = false;

    //Parameters for overload 9
    zval* stream9;
    wxInputStream* object_pointer9_0 = 0;
    long type9;
    long index9;
    bool overload9_called = false;

    //Parameters for overload 10
    zval* stream10;
    wxInputStream* object_pointer10_0 = 0;
    char* mimetype10;
    size_t mimetype_len10;
    long index10;
    bool overload10_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll|b' (&width1, &height1, &clear1)\n");
        #endif

        char parse_parameters_string[] = "ll|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &width1, &height1, &clear1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O|b' (&sz2, php_wxSize_entry, &clear2)\n");
        #endif

        char parse_parameters_string[] = "O|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &sz2, php_wxSize_entry, &clear2 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(sz2) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(sz2)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(sz2)->native_object;
                    object_pointer2_0 = (wxSize*) argument_native_object;
                    if (!object_pointer2_0 )
                    {
                        goto overload3;
                    }
                }
                else if(Z_TYPE_P(sz2) != IS_NULL)
                {
                    goto overload3;
                }
            }

            overload2_called = true;
            already_called = true;
        }
    }

    //Overload 3
    overload3:
    if(!already_called && arguments_received >= 3  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'lll|b' (&width3, &height3, data3, &static_data3)\n");
        #endif

        char parse_parameters_string[] = "lll|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &width3, &height3, data3, &static_data3 ) == SUCCESS)
        {
            overload3_called = true;
            already_called = true;

            char parse_references_string[] = "zzz|z";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, dummy, data3_ref, dummy );
        }
    }

    //Overload 4
    overload4:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'Ol|b' (&sz4, php_wxSize_entry, data4, &static_data4)\n");
        #endif

        char parse_parameters_string[] = "Ol|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &sz4, php_wxSize_entry, data4, &static_data4 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(sz4) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(sz4)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(sz4)->native_object;
                    object_pointer4_0 = (wxSize*) argument_native_object;
                    if (!object_pointer4_0 )
                    {
                        goto overload5;
                    }
                }
                else if(Z_TYPE_P(sz4) != IS_NULL)
                {
                    goto overload5;
                }
            }

            overload4_called = true;
            already_called = true;

            char parse_references_string[] = "zz|z";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, &dummy, data4_ref, dummy );
        }
    }

    //Overload 5
    overload5:
    if(!already_called && arguments_received >= 4  && arguments_received <= 5)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'llll|b' (&width5, &height5, data5, alpha5, &static_data5)\n");
        #endif

        char parse_parameters_string[] = "llll|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &width5, &height5, data5, alpha5, &static_data5 ) == SUCCESS)
        {
            overload5_called = true;
            already_called = true;

            char parse_references_string[] = "zzzz|z";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, dummy, data5_ref, alpha5_ref, dummy );
        }
    }

    //Overload 6
    overload6:
    if(!already_called && arguments_received >= 3  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'Oll|b' (&sz6, php_wxSize_entry, data6, alpha6, &static_data6)\n");
        #endif

        char parse_parameters_string[] = "Oll|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &sz6, php_wxSize_entry, data6, alpha6, &static_data6 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(sz6) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(sz6)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(sz6)->native_object;
                    object_pointer6_0 = (wxSize*) argument_native_object;
                    if (!object_pointer6_0 )
                    {
                        goto overload7;
                    }
                }
                else if(Z_TYPE_P(sz6) != IS_NULL)
                {
                    goto overload7;
                }
            }

            overload6_called = true;
            already_called = true;

            char parse_references_string[] = "zzz|z";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, &dummy, data6_ref, alpha6_ref, dummy );
        }
    }

    //Overload 7
    overload7:
    if(!already_called && arguments_received >= 1  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|ll' (&name7, &name_len7, &type7, &index7)\n");
        #endif

        char parse_parameters_string[] = "s|ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name7, &name_len7, &type7, &index7 ) == SUCCESS)
        {
            overload7_called = true;
            already_called = true;
        }
    }

    //Overload 8
    overload8:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ss|l' (&name8, &name_len8, &mimetype8, &mimetype_len8, &index8)\n");
        #endif

        char parse_parameters_string[] = "ss|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name8, &name_len8, &mimetype8, &mimetype_len8, &index8 ) == SUCCESS)
        {
            overload8_called = true;
            already_called = true;
        }
    }

    //Overload 9
    overload9:
    if(!already_called && arguments_received >= 1  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'o|ll' (&stream9, &type9, &index9)\n");
        #endif

        char parse_parameters_string[] = "o|ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &stream9, &type9, &index9 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(stream9) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxInputStream_P(stream9)->object_type;
                    argument_native_object = (void*) Z_wxInputStream_P(stream9)->native_object;
                    object_pointer9_0 = (wxInputStream*) argument_native_object;
                    if (!object_pointer9_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
                    {
                        goto overload10;
                    }
                }
                else if(Z_TYPE_P(stream9) != IS_NULL)
                {
                    goto overload10;
                }
            }

            overload9_called = true;
            already_called = true;
        }
    }

    //Overload 10
    overload10:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'os|l' (&stream10, &mimetype10, &mimetype_len10, &index10)\n");
        #endif

        char parse_parameters_string[] = "os|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &stream10, &mimetype10, &mimetype_len10, &index10 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(stream10) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxInputStream_P(stream10)->object_type;
                    argument_native_object = (void*) Z_wxInputStream_P(stream10)->native_object;
                    object_pointer10_0 = (wxInputStream*) argument_native_object;
                    if (!object_pointer10_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'stream' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(stream10) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'stream' not null, could not be retreived correctly.");
                }
            }

            overload10_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxImage_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) width1, (int) height1)\n");
                #endif

                native_object = new wxImage_php((int) width1, (int) height1);

                native_object->references.Initialize();
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) width1, (int) height1, clear1)\n");
                #endif

                native_object = new wxImage_php((int) width1, (int) height1, clear1);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxSize*) object_pointer2_0)\n");
                #endif

                native_object = new wxImage_php(*(wxSize*) object_pointer2_0);

                native_object->references.Initialize();
                ((wxImage_php*) native_object)->references.AddReference(sz2, "wxImage::wxImage at call 4 with 1 argument(s)");
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxSize*) object_pointer2_0, clear2)\n");
                #endif

                native_object = new wxImage_php(*(wxSize*) object_pointer2_0, clear2);

                native_object->references.Initialize();
                ((wxImage_php*) native_object)->references.AddReference(sz2, "wxImage::wxImage at call 4 with 2 argument(s)");
                break;
            }
        }
    }

    if(overload3_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) width3, (int) height3, (unsigned char*) data3)\n");
                #endif

                native_object = new wxImage_php((int) width3, (int) height3, (unsigned char*) data3);

                native_object->references.Initialize();
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) width3, (int) height3, (unsigned char*) data3, static_data3)\n");
                #endif

                native_object = new wxImage_php((int) width3, (int) height3, (unsigned char*) data3, static_data3);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload4_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxSize*) object_pointer4_0, (unsigned char*) data4)\n");
                #endif

                native_object = new wxImage_php(*(wxSize*) object_pointer4_0, (unsigned char*) data4);

                native_object->references.Initialize();
                ((wxImage_php*) native_object)->references.AddReference(sz4, "wxImage::wxImage at call 4 with 2 argument(s)");
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxSize*) object_pointer4_0, (unsigned char*) data4, static_data4)\n");
                #endif

                native_object = new wxImage_php(*(wxSize*) object_pointer4_0, (unsigned char*) data4, static_data4);

                native_object->references.Initialize();
                ((wxImage_php*) native_object)->references.AddReference(sz4, "wxImage::wxImage at call 4 with 3 argument(s)");
                break;
            }
        }
    }

    if(overload5_called)
    {
        switch(arguments_received)
        {
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) width5, (int) height5, (unsigned char*) data5, (unsigned char*) alpha5)\n");
                #endif

                native_object = new wxImage_php((int) width5, (int) height5, (unsigned char*) data5, (unsigned char*) alpha5);

                native_object->references.Initialize();
                break;
            }
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) width5, (int) height5, (unsigned char*) data5, (unsigned char*) alpha5, static_data5)\n");
                #endif

                native_object = new wxImage_php((int) width5, (int) height5, (unsigned char*) data5, (unsigned char*) alpha5, static_data5);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload6_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxSize*) object_pointer6_0, (unsigned char*) data6, (unsigned char*) alpha6)\n");
                #endif

                native_object = new wxImage_php(*(wxSize*) object_pointer6_0, (unsigned char*) data6, (unsigned char*) alpha6);

                native_object->references.Initialize();
                ((wxImage_php*) native_object)->references.AddReference(sz6, "wxImage::wxImage at call 4 with 3 argument(s)");
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxSize*) object_pointer6_0, (unsigned char*) data6, (unsigned char*) alpha6, static_data6)\n");
                #endif

                native_object = new wxImage_php(*(wxSize*) object_pointer6_0, (unsigned char*) data6, (unsigned char*) alpha6, static_data6);

                native_object->references.Initialize();
                ((wxImage_php*) native_object)->references.AddReference(sz6, "wxImage::wxImage at call 4 with 4 argument(s)");
                break;
            }
        }
    }

    if(overload7_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(name7, wxConvUTF8))\n");
                #endif

                native_object = new wxImage_php(wxString(name7, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(name7, wxConvUTF8), (wxBitmapType) type7)\n");
                #endif

                native_object = new wxImage_php(wxString(name7, wxConvUTF8), (wxBitmapType) type7);

                native_object->references.Initialize();
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(name7, wxConvUTF8), (wxBitmapType) type7, (int) index7)\n");
                #endif

                native_object = new wxImage_php(wxString(name7, wxConvUTF8), (wxBitmapType) type7, (int) index7);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload8_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(name8, wxConvUTF8), wxString(mimetype8, wxConvUTF8))\n");
                #endif

                native_object = new wxImage_php(wxString(name8, wxConvUTF8), wxString(mimetype8, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(name8, wxConvUTF8), wxString(mimetype8, wxConvUTF8), (int) index8)\n");
                #endif

                native_object = new wxImage_php(wxString(name8, wxConvUTF8), wxString(mimetype8, wxConvUTF8), (int) index8);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload9_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxInputStream*) object_pointer9_0)\n");
                #endif

                native_object = new wxImage_php(*(wxInputStream*) object_pointer9_0);

                native_object->references.Initialize();
                ((wxImage_php*) native_object)->references.AddReference(stream9, "wxImage::wxImage at call 4 with 1 argument(s)");
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxInputStream*) object_pointer9_0, (wxBitmapType) type9)\n");
                #endif

                native_object = new wxImage_php(*(wxInputStream*) object_pointer9_0, (wxBitmapType) type9);

                native_object->references.Initialize();
                ((wxImage_php*) native_object)->references.AddReference(stream9, "wxImage::wxImage at call 4 with 2 argument(s)");
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxInputStream*) object_pointer9_0, (wxBitmapType) type9, (int) index9)\n");
                #endif

                native_object = new wxImage_php(*(wxInputStream*) object_pointer9_0, (wxBitmapType) type9, (int) index9);

                native_object->references.Initialize();
                ((wxImage_php*) native_object)->references.AddReference(stream9, "wxImage::wxImage at call 4 with 3 argument(s)");
                break;
            }
        }
    }

    if(overload10_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxInputStream*) object_pointer10_0, wxString(mimetype10, wxConvUTF8))\n");
                #endif

                native_object = new wxImage_php(*(wxInputStream*) object_pointer10_0, wxString(mimetype10, wxConvUTF8));

                native_object->references.Initialize();
                ((wxImage_php*) native_object)->references.AddReference(stream10, "wxImage::wxImage at call 4 with 2 argument(s)");
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxInputStream*) object_pointer10_0, wxString(mimetype10, wxConvUTF8), (int) index10)\n");
                #endif

                native_object = new wxImage_php(*(wxInputStream*) object_pointer10_0, wxString(mimetype10, wxConvUTF8), (int) index10);

                native_object->references.Initialize();
                ((wxImage_php*) native_object)->references.AddReference(stream10, "wxImage::wxImage at call 4 with 3 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxImage_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxImage::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto  wxImage::SetType(wxBitmapType type)
   Set the type of image returned by GetType(). */
PHP_METHOD(php_wxImage, SetType)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::SetType\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::SetType call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long type0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&type0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &type0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::SetType((wxBitmapType) type0)\n\n");
                #endif

                ((wxImage_php*)native_object)->SetType((wxBitmapType) type0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::SetType\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImage::SetRGB(int x, int y, int r, int g, int b)
   Set the color of the pixel at the given x and y coordinate. */
PHP_METHOD(php_wxImage, SetRGB)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::SetRGB\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::SetRGB call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long x0;
    long y0;
    long r0;
    long g0;
    long b0;
    bool overload0_called = false;

    //Parameters for overload 1
    zval* rect1;
    wxRect* object_pointer1_0 = 0;
    long red1;
    long green1;
    long blue1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 5)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'lllll' (&x0, &y0, &r0, &g0, &b0)\n");
        #endif

        char parse_parameters_string[] = "lllll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &x0, &y0, &r0, &g0, &b0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'Olll' (&rect1, php_wxRect_entry, &red1, &green1, &blue1)\n");
        #endif

        char parse_parameters_string[] = "Olll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &rect1, php_wxRect_entry, &red1, &green1, &blue1 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(rect1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxRect_P(rect1)->object_type;
                    argument_native_object = (void*) Z_wxRect_P(rect1)->native_object;
                    object_pointer1_0 = (wxRect*) argument_native_object;
                    if (!object_pointer1_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(rect1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::SetRGB((int) x0, (int) y0, (unsigned char) r0, (unsigned char) g0, (unsigned char) b0)\n\n");
                #endif

                ((wxImage_php*)native_object)->SetRGB((int) x0, (int) y0, (unsigned char) r0, (unsigned char) g0, (unsigned char) b0);


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::SetRGB(*(wxRect*) object_pointer1_0, (unsigned char) red1, (unsigned char) green1, (unsigned char) blue1)\n\n");
                #endif

                ((wxImage_php*)native_object)->SetRGB(*(wxRect*) object_pointer1_0, (unsigned char) red1, (unsigned char) green1, (unsigned char) blue1);

                references->AddReference(rect1, "wxImage::SetRGB at call 3 with 4 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::SetRGB\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImage::SetPalette(wxPalette palette)
   Associates a palette with the image. */
PHP_METHOD(php_wxImage, SetPalette)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::SetPalette\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::SetPalette call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* palette0;
    wxPalette* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&palette0, php_wxPalette_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &palette0, php_wxPalette_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(palette0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPalette_P(palette0)->object_type;
                    argument_native_object = (void*) Z_wxPalette_P(palette0)->native_object;
                    object_pointer0_0 = (wxPalette*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'palette' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(palette0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'palette' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::SetPalette(*(wxPalette*) object_pointer0_0)\n\n");
                #endif

                ((wxImage_php*)native_object)->SetPalette(*(wxPalette*) object_pointer0_0);

                references->AddReference(palette0, "wxImage::SetPalette at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::SetPalette\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImage::SetOption(string name, string value)
   Sets a user-defined option. */
PHP_METHOD(php_wxImage, SetOption)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::SetOption\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::SetOption call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    char* value0;
    size_t value_len0;
    bool overload0_called = false;

    //Parameters for overload 1
    char* name1;
    size_t name_len1;
    long value1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ss' (&name0, &name_len0, &value0, &value_len0)\n");
        #endif

        char parse_parameters_string[] = "ss";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0, &value0, &value_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sl' (&name1, &name_len1, &value1)\n");
        #endif

        char parse_parameters_string[] = "sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name1, &name_len1, &value1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::SetOption(wxString(name0, wxConvUTF8), wxString(value0, wxConvUTF8))\n\n");
                #endif

                ((wxImage_php*)native_object)->SetOption(wxString(name0, wxConvUTF8), wxString(value0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::SetOption(wxString(name1, wxConvUTF8), (int) value1)\n\n");
                #endif

                ((wxImage_php*)native_object)->SetOption(wxString(name1, wxConvUTF8), (int) value1);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::SetOption\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxImage::SetMaskFromImage(wxImage mask, int mr, int mg, int mb)
   Sets image's mask so that the pixels that have RGB value of mr,mg,mb in mask will be masked in the image. */
PHP_METHOD(php_wxImage, SetMaskFromImage)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::SetMaskFromImage\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::SetMaskFromImage call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* mask0;
    wxImage* object_pointer0_0 = 0;
    long mr0;
    long mg0;
    long mb0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'Olll' (&mask0, php_wxImage_entry, &mr0, &mg0, &mb0)\n");
        #endif

        char parse_parameters_string[] = "Olll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &mask0, php_wxImage_entry, &mr0, &mg0, &mb0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(mask0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxImage_P(mask0)->object_type;
                    argument_native_object = (void*) Z_wxImage_P(mask0)->native_object;
                    object_pointer0_0 = (wxImage*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'mask' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(mask0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'mask' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::SetMaskFromImage(*(wxImage*) object_pointer0_0, (unsigned char) mr0, (unsigned char) mg0, (unsigned char) mb0))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->SetMaskFromImage(*(wxImage*) object_pointer0_0, (unsigned char) mr0, (unsigned char) mg0, (unsigned char) mb0));

                references->AddReference(mask0, "wxImage::SetMaskFromImage at call 3 with 4 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::SetMaskFromImage\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImage::SetMaskColour(int red, int green, int blue)
   Sets the mask colour for this image (and tells the image to use the mask). */
PHP_METHOD(php_wxImage, SetMaskColour)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::SetMaskColour\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::SetMaskColour call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long red0;
    long green0;
    long blue0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'lll' (&red0, &green0, &blue0)\n");
        #endif

        char parse_parameters_string[] = "lll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &red0, &green0, &blue0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::SetMaskColour((unsigned char) red0, (unsigned char) green0, (unsigned char) blue0)\n\n");
                #endif

                ((wxImage_php*)native_object)->SetMaskColour((unsigned char) red0, (unsigned char) green0, (unsigned char) blue0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::SetMaskColour\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImage::SetMask(bool hasMask)
   Specifies whether there is a mask or not. */
PHP_METHOD(php_wxImage, SetMask)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::SetMask\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::SetMask call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool hasMask0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|b' (&hasMask0)\n");
        #endif

        char parse_parameters_string[] = "|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &hasMask0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::SetMask()\n\n");
                #endif

                ((wxImage_php*)native_object)->SetMask();


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::SetMask(hasMask0)\n\n");
                #endif

                ((wxImage_php*)native_object)->SetMask(hasMask0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::SetMask\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImage::SetData(int &data, int new_width, int new_height, bool static_data)
   This is an overloaded member function, provided for convenience.
   It differs from the above function only in what argument(s)
   it accepts. */
PHP_METHOD(php_wxImage, SetData)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::SetData\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::SetData call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* data0;
    size_t data0_len;
    long new_width0;
    long new_height0;
    bool static_data0;
    bool overload0_called = false;
    //Parameters for overload 1
    char* data1;
    size_t data1_len;
    bool static_data1;
    bool overload1_called = false;

    //Overload 0
    overload0:
    if(
        !already_called && arguments_received >= 3
        &&
        arguments_received <= 4
    )
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf(
            "Parsing parameters with 'sll|b' "
            "(data0, &new_width0, &new_height0, &static_data0)\n"
        );
        #endif

        char parse_parameters_string[] = "sll|b";
        if(
            zend_parse_parameters_ex(
                ZEND_PARSE_PARAMS_QUIET,
                arguments_received,
                parse_parameters_string,
                &data0,
                &data0_len,
                &new_width0,
                &new_height0,
                &static_data0
            ) == SUCCESS
        )
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(
        !already_called && arguments_received >= 1
        &&
        arguments_received <= 2
    )
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf(
            "Parsing parameters with 's|b' (data1, &static_data1)\n"
        );
        #endif

        char parse_parameters_string[] = "s|b";
        if(
            zend_parse_parameters_ex(
                ZEND_PARSE_PARAMS_QUIET,
                arguments_received,
                parse_parameters_string,
                &data1,
                &data1_len,
                &static_data1
            ) == SUCCESS
        )
        {
            overload1_called = true;
            already_called = true;
        }
    }

    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf(
                    "Executing wxImage::SetData("
                    "(unsigned char*) data0, (int) new_width0, "
                    "(int) new_height0"
                    ")\n\n"
                );
                #endif

                ((wxImage_php*)native_object)->SetData(
                    (unsigned char*) data0,
                    (int) new_width0,
                    (int) new_height0
                );

                return;
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf(
                    "Executing wxImage::SetData("
                    "(unsigned char*) data0, (int) new_width0, "
                    "(int) new_height0, static_data0"
                    ")\n\n"
                );
                #endif

                ((wxImage_php*)native_object)->SetData(
                    (unsigned char*) data0,
                    (int) new_width0,
                    (int) new_height0,
                    static_data0
                );

                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf(
                    "Executing wxImage::SetData("
                    "(unsigned char*) data1"
                    ")\n\n"
                );
                #endif

                ((wxImage_php*)native_object)->SetData(
                    (unsigned char*) data1
                );

                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf(
                    "Executing wxImage::SetData("
                    "(unsigned char*) data1, static_data1"
                    ")\n\n"
                );
                #endif

                ((wxImage_php*)native_object)->SetData(
                    (unsigned char*) data1,
                    static_data1
                );

                return;
                break;
            }
        }
    }

    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::SetData\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImage::SetAlpha(int &alpha, bool static_data)
   This function is similar to SetData() and has similar restrictions. */
PHP_METHOD(php_wxImage, SetAlpha)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::SetAlpha\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::SetAlpha call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long* alpha0;
    zval alpha0_ref;
    bool static_data0;
    bool overload0_called = false;

    //Parameters for overload 1
    long x1;
    long y1;
    long alpha1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|lb' (alpha0, &static_data0)\n");
        #endif

        char parse_parameters_string[] = "|lb";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, alpha0, &static_data0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;

            char parse_references_string[] = "|zz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, alpha0_ref, dummy );
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'lll' (&x1, &y1, &alpha1)\n");
        #endif

        char parse_parameters_string[] = "lll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &x1, &y1, &alpha1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::SetAlpha()\n\n");
                #endif

                ((wxImage_php*)native_object)->SetAlpha();


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::SetAlpha((unsigned char*) alpha0)\n\n");
                #endif

                ((wxImage_php*)native_object)->SetAlpha((unsigned char*) alpha0);

                size_t elements_returned0_0 = sizeof(alpha0)/sizeof(*alpha0);
                array_init(&alpha0_ref);
                for(size_t i=0; i<elements_returned0_0; i++)
                {
                    add_next_index_long(&alpha0_ref, alpha0[i]);
                }

                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::SetAlpha((unsigned char*) alpha0, static_data0)\n\n");
                #endif

                ((wxImage_php*)native_object)->SetAlpha((unsigned char*) alpha0, static_data0);

                size_t elements_returned0_0 = sizeof(alpha0)/sizeof(*alpha0);
                array_init(&alpha0_ref);
                for(size_t i=0; i<elements_returned0_0; i++)
                {
                    add_next_index_long(&alpha0_ref, alpha0[i]);
                }

                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::SetAlpha((int) x1, (int) y1, (unsigned char) alpha1)\n\n");
                #endif

                ((wxImage_php*)native_object)->SetAlpha((int) x1, (int) y1, (unsigned char) alpha1);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::SetAlpha\n"
        );
    }
}
/* }}} */

/* {{{ proto wxImage wxImage::Scale(int width, int height, wxImageResizeQuality quality)
   Returns a scaled version of the image. */
PHP_METHOD(php_wxImage, Scale)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::Scale\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::Scale call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long width0;
    long height0;
    long quality0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll|l' (&width0, &height0, &quality0)\n");
        #endif

        char parse_parameters_string[] = "ll|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &width0, &height0, &quality0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Scale((int) width0, (int) height0) to return new object\n\n");
                #endif

                wxImage value_to_return2;
                value_to_return2 = ((wxImage_php*)native_object)->Scale((int) width0, (int) height0);
                ((wxRefCounter *) value_to_return2.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return2, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo2 = Z_wxImage_P(return_value);
                zo2->native_object = (wxImage_php*) ptr;


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Scale((int) width0, (int) height0, (wxImageResizeQuality) quality0) to return new object\n\n");
                #endif

                wxImage value_to_return3;
                value_to_return3 = ((wxImage_php*)native_object)->Scale((int) width0, (int) height0, (wxImageResizeQuality) quality0);
                ((wxRefCounter *) value_to_return3.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return3, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo3 = Z_wxImage_P(return_value);
                zo3->native_object = (wxImage_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::Scale\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxImage::SaveFile(wxOutputStream &stream, string mimetype)
   Saves an image in the given stream. */
PHP_METHOD(php_wxImage, SaveFile)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::SaveFile\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::SaveFile call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* stream0;
    wxOutputStream* object_pointer0_0 = 0;
    char* mimetype0;
    size_t mimetype_len0;
    bool overload0_called = false;

    //Parameters for overload 1
    char* name1;
    size_t name_len1;
    long type1;
    bool overload1_called = false;

    //Parameters for overload 2
    char* name2;
    size_t name_len2;
    char* mimetype2;
    size_t mimetype_len2;
    bool overload2_called = false;

    //Parameters for overload 3
    char* name3;
    size_t name_len3;
    bool overload3_called = false;

    //Parameters for overload 4
    zval* stream4;
    wxOutputStream* object_pointer4_0 = 0;
    long type4;
    bool overload4_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'os' (&stream0, &mimetype0, &mimetype_len0)\n");
        #endif

        char parse_parameters_string[] = "os";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &stream0, &mimetype0, &mimetype_len0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(stream0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxOutputStream_P(stream0)->object_type;
                    argument_native_object = (void*) Z_wxOutputStream_P(stream0)->native_object;
                    object_pointer0_0 = (wxOutputStream*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXOUTPUTSTREAM_TYPE && argument_type != PHP_WXFFILEOUTPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEOUTPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
                    {
                        goto overload1;
                    }
                }
                else if(Z_TYPE_P(stream0) != IS_NULL)
                {
                    goto overload1;
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sl' (&name1, &name_len1, &type1)\n");
        #endif

        char parse_parameters_string[] = "sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name1, &name_len1, &type1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ss' (&name2, &name_len2, &mimetype2, &mimetype_len2)\n");
        #endif

        char parse_parameters_string[] = "ss";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name2, &name_len2, &mimetype2, &mimetype_len2 ) == SUCCESS)
        {
            overload2_called = true;
            already_called = true;
        }
    }

    //Overload 3
    overload3:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&name3, &name_len3)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name3, &name_len3 ) == SUCCESS)
        {
            overload3_called = true;
            already_called = true;
        }
    }

    //Overload 4
    overload4:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ol' (&stream4, &type4)\n");
        #endif

        char parse_parameters_string[] = "ol";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &stream4, &type4 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(stream4) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxOutputStream_P(stream4)->object_type;
                    argument_native_object = (void*) Z_wxOutputStream_P(stream4)->native_object;
                    object_pointer4_0 = (wxOutputStream*) argument_native_object;
                    if (!object_pointer4_0 || (argument_type != PHP_WXOUTPUTSTREAM_TYPE && argument_type != PHP_WXFFILEOUTPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEOUTPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'stream' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(stream4) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'stream' not null, could not be retreived correctly.");
                }
            }

            overload4_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::SaveFile(*(wxOutputStream*) object_pointer0_0, wxString(mimetype0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->SaveFile(*(wxOutputStream*) object_pointer0_0, wxString(mimetype0, wxConvUTF8)));

                references->AddReference(stream0, "wxImage::SaveFile at call 3 with 2 argument(s)");

                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::SaveFile(wxString(name1, wxConvUTF8), (wxBitmapType) type1))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->SaveFile(wxString(name1, wxConvUTF8), (wxBitmapType) type1));


                return;
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::SaveFile(wxString(name2, wxConvUTF8), wxString(mimetype2, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->SaveFile(wxString(name2, wxConvUTF8), wxString(mimetype2, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    if(overload3_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::SaveFile(wxString(name3, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->SaveFile(wxString(name3, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    if(overload4_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::SaveFile(*(wxOutputStream*) object_pointer4_0, (wxBitmapType) type4))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->SaveFile(*(wxOutputStream*) object_pointer4_0, (wxBitmapType) type4));

                references->AddReference(stream4, "wxImage::SaveFile at call 3 with 2 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::SaveFile\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImage::RotateHue(float angle)
   Rotates the hue of each pixel in the image by angle, which is a double in the range [-1.0..+1.0], where -1.0 corresponds to -360 degrees and +1.0 corresponds to +360 degrees. */
PHP_METHOD(php_wxImage, RotateHue)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::RotateHue\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::RotateHue call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    double angle0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'd' (&angle0)\n");
        #endif

        char parse_parameters_string[] = "d";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &angle0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::RotateHue(angle0)\n\n");
                #endif

                ((wxImage_php*)native_object)->RotateHue(angle0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::RotateHue\n"
        );
    }
}
/* }}} */

/* {{{ proto wxImage wxImage::Rotate90(bool clockwise)
   Returns a copy of the image rotated 90 degrees in the direction indicated by clockwise. */
PHP_METHOD(php_wxImage, Rotate90)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::Rotate90\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::Rotate90 call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool clockwise0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|b' (&clockwise0)\n");
        #endif

        char parse_parameters_string[] = "|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &clockwise0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Rotate90() to return new object\n\n");
                #endif

                wxImage value_to_return0;
                value_to_return0 = ((wxImage_php*)native_object)->Rotate90();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo0 = Z_wxImage_P(return_value);
                zo0->native_object = (wxImage_php*) ptr;


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Rotate90(clockwise0) to return new object\n\n");
                #endif

                wxImage value_to_return1;
                value_to_return1 = ((wxImage_php*)native_object)->Rotate90(clockwise0);
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo1 = Z_wxImage_P(return_value);
                zo1->native_object = (wxImage_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::Rotate90\n"
        );
    }
}
/* }}} */

/* {{{ proto wxImage wxImage::Rotate180()
   Returns a copy of the image rotated by 180 degrees. */
PHP_METHOD(php_wxImage, Rotate180)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::Rotate180\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::Rotate180 call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Rotate180() to return new object\n\n");
                #endif

                wxImage value_to_return0;
                value_to_return0 = ((wxImage_php*)native_object)->Rotate180();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo0 = Z_wxImage_P(return_value);
                zo0->native_object = (wxImage_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::Rotate180\n"
        );
    }
}
/* }}} */

/* {{{ proto wxImage wxImage::Rotate(float angle, wxPoint rotationCentre, bool interpolating, wxPoint &offsetAfterRotation)
   Rotates the image about the given point, by angle radians. */
PHP_METHOD(php_wxImage, Rotate)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::Rotate\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::Rotate call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    double angle0;
    zval* rotationCentre0;
    wxPoint* object_pointer0_1 = 0;
    bool interpolating0;
    zval* offsetAfterRotation0;
    wxPoint* object_pointer0_3 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 2  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'dO|bz' (&angle0, &rotationCentre0, php_wxPoint_entry, &interpolating0, &offsetAfterRotation0)\n");
        #endif

        char parse_parameters_string[] = "dO|bz";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &angle0, &rotationCentre0, php_wxPoint_entry, &interpolating0, &offsetAfterRotation0 ) == SUCCESS)
        {
            if(arguments_received >= 2){
                if(Z_TYPE_P(rotationCentre0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPoint_P(rotationCentre0)->object_type;
                    argument_native_object = (void*) Z_wxPoint_P(rotationCentre0)->native_object;
                    object_pointer0_1 = (wxPoint*) argument_native_object;
                    if (!object_pointer0_1 )
                    {
                        zend_error(E_ERROR, "Parameter 'rotationCentre' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(rotationCentre0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'rotationCentre' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 4){
                if(Z_TYPE_P(offsetAfterRotation0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPoint_P(offsetAfterRotation0)->object_type;
                    argument_native_object = (void*) Z_wxPoint_P(offsetAfterRotation0)->native_object;
                    object_pointer0_3 = (wxPoint*) argument_native_object;
                    if (!object_pointer0_3 || (argument_type != PHP_WXPOINT_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'offsetAfterRotation' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(offsetAfterRotation0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'offsetAfterRotation' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Rotate(angle0, *(wxPoint*) object_pointer0_1) to return new object\n\n");
                #endif

                wxImage value_to_return2;
                value_to_return2 = ((wxImage_php*)native_object)->Rotate(angle0, *(wxPoint*) object_pointer0_1);
                ((wxRefCounter *) value_to_return2.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return2, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo2 = Z_wxImage_P(return_value);
                zo2->native_object = (wxImage_php*) ptr;

                references->AddReference(rotationCentre0, "wxImage::Rotate at call 3 with 2 argument(s)");

                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Rotate(angle0, *(wxPoint*) object_pointer0_1, interpolating0) to return new object\n\n");
                #endif

                wxImage value_to_return3;
                value_to_return3 = ((wxImage_php*)native_object)->Rotate(angle0, *(wxPoint*) object_pointer0_1, interpolating0);
                ((wxRefCounter *) value_to_return3.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return3, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo3 = Z_wxImage_P(return_value);
                zo3->native_object = (wxImage_php*) ptr;

                references->AddReference(rotationCentre0, "wxImage::Rotate at call 3 with 3 argument(s)");

                return;
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Rotate(angle0, *(wxPoint*) object_pointer0_1, interpolating0, (wxPoint*) object_pointer0_3) to return new object\n\n");
                #endif

                wxImage value_to_return4;
                value_to_return4 = ((wxImage_php*)native_object)->Rotate(angle0, *(wxPoint*) object_pointer0_1, interpolating0, (wxPoint*) object_pointer0_3);
                ((wxRefCounter *) value_to_return4.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return4, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo4 = Z_wxImage_P(return_value);
                zo4->native_object = (wxImage_php*) ptr;

                references->AddReference(rotationCentre0, "wxImage::Rotate at call 3 with 4 argument(s)");
                references->AddReference(offsetAfterRotation0, "wxImage::Rotate at call 1 with 4 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::Rotate\n"
        );
    }
}
/* }}} */

/* {{{ proto wxImage wxImage::Resize(wxSize size, wxPoint pos, int red, int green, int blue)
   Changes the size of the image in-place without scaling it by adding either a border with the given colour or cropping as necessary. */
PHP_METHOD(php_wxImage, Resize)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::Resize\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::Resize call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* size0;
    wxSize* object_pointer0_0 = 0;
    zval* pos0;
    wxPoint* object_pointer0_1 = 0;
    long red0;
    long green0;
    long blue0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 2  && arguments_received <= 5)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'OO|lll' (&size0, php_wxSize_entry, &pos0, php_wxPoint_entry, &red0, &green0, &blue0)\n");
        #endif

        char parse_parameters_string[] = "OO|lll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &size0, php_wxSize_entry, &pos0, php_wxPoint_entry, &red0, &green0, &blue0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(size0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(size0)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(size0)->native_object;
                    object_pointer0_0 = (wxSize*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(size0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 2){
                if(Z_TYPE_P(pos0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPoint_P(pos0)->object_type;
                    argument_native_object = (void*) Z_wxPoint_P(pos0)->native_object;
                    object_pointer0_1 = (wxPoint*) argument_native_object;
                    if (!object_pointer0_1 )
                    {
                        zend_error(E_ERROR, "Parameter 'pos' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(pos0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'pos' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Resize(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1) to return object reference\n\n");
                #endif

                wxImage_php* value_to_return2;
                value_to_return2 = (wxImage_php*) &((wxImage_php*)native_object)->Resize(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1);

                if(value_to_return2->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return2->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return2->phpObj);
                        zval_add_ref(&value_to_return2->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxImage_entry);
                    Z_wxImage_P(return_value)->native_object = (wxImage_php*) value_to_return2;
                }

                if((void*)value_to_return2 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxImage::Resize at call 6 with 2 argument(s)");
                }

                references->AddReference(size0, "wxImage::Resize at call 3 with 2 argument(s)");
                references->AddReference(pos0, "wxImage::Resize at call 3 with 2 argument(s)");

                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Resize(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0) to return object reference\n\n");
                #endif

                wxImage_php* value_to_return3;
                value_to_return3 = (wxImage_php*) &((wxImage_php*)native_object)->Resize(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0);

                if(value_to_return3->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return3->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return3->phpObj);
                        zval_add_ref(&value_to_return3->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxImage_entry);
                    Z_wxImage_P(return_value)->native_object = (wxImage_php*) value_to_return3;
                }

                if((void*)value_to_return3 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxImage::Resize at call 6 with 3 argument(s)");
                }

                references->AddReference(size0, "wxImage::Resize at call 3 with 3 argument(s)");
                references->AddReference(pos0, "wxImage::Resize at call 3 with 3 argument(s)");

                return;
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Resize(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0, (int) green0) to return object reference\n\n");
                #endif

                wxImage_php* value_to_return4;
                value_to_return4 = (wxImage_php*) &((wxImage_php*)native_object)->Resize(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0, (int) green0);

                if(value_to_return4->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return4->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return4->phpObj);
                        zval_add_ref(&value_to_return4->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxImage_entry);
                    Z_wxImage_P(return_value)->native_object = (wxImage_php*) value_to_return4;
                }

                if((void*)value_to_return4 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxImage::Resize at call 6 with 4 argument(s)");
                }

                references->AddReference(size0, "wxImage::Resize at call 3 with 4 argument(s)");
                references->AddReference(pos0, "wxImage::Resize at call 3 with 4 argument(s)");

                return;
                break;
            }
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Resize(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0, (int) green0, (int) blue0) to return object reference\n\n");
                #endif

                wxImage_php* value_to_return5;
                value_to_return5 = (wxImage_php*) &((wxImage_php*)native_object)->Resize(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0, (int) green0, (int) blue0);

                if(value_to_return5->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return5->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return5->phpObj);
                        zval_add_ref(&value_to_return5->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxImage_entry);
                    Z_wxImage_P(return_value)->native_object = (wxImage_php*) value_to_return5;
                }

                if((void*)value_to_return5 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxImage::Resize at call 6 with 5 argument(s)");
                }

                references->AddReference(size0, "wxImage::Resize at call 3 with 5 argument(s)");
                references->AddReference(pos0, "wxImage::Resize at call 3 with 5 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::Resize\n"
        );
    }
}
/* }}} */

/* {{{ proto wxImage wxImage::Rescale(int width, int height, wxImageResizeQuality quality)
   Changes the size of the image in-place by scaling it: after a call to this function,the image will have the given width and height. */
PHP_METHOD(php_wxImage, Rescale)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::Rescale\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::Rescale call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long width0;
    long height0;
    long quality0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll|l' (&width0, &height0, &quality0)\n");
        #endif

        char parse_parameters_string[] = "ll|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &width0, &height0, &quality0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Rescale((int) width0, (int) height0) to return object reference\n\n");
                #endif

                wxImage_php* value_to_return2;
                value_to_return2 = (wxImage_php*) &((wxImage_php*)native_object)->Rescale((int) width0, (int) height0);

                if(value_to_return2->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return2->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return2->phpObj);
                        zval_add_ref(&value_to_return2->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxImage_entry);
                    Z_wxImage_P(return_value)->native_object = (wxImage_php*) value_to_return2;
                }

                if((void*)value_to_return2 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxImage::Rescale at call 6 with 2 argument(s)");
                }


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Rescale((int) width0, (int) height0, (wxImageResizeQuality) quality0) to return object reference\n\n");
                #endif

                wxImage_php* value_to_return3;
                value_to_return3 = (wxImage_php*) &((wxImage_php*)native_object)->Rescale((int) width0, (int) height0, (wxImageResizeQuality) quality0);

                if(value_to_return3->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return3->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return3->phpObj);
                        zval_add_ref(&value_to_return3->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxImage_entry);
                    Z_wxImage_P(return_value)->native_object = (wxImage_php*) value_to_return3;
                }

                if((void*)value_to_return3 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxImage::Rescale at call 6 with 3 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::Rescale\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImage::Replace(int r1, int g1, int b1, int r2, int g2, int b2)
   Replaces the colour specified by r1,g1,b1 by the colour r2,g2,b2. */
PHP_METHOD(php_wxImage, Replace)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::Replace\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::Replace call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long r10;
    long g10;
    long b10;
    long r20;
    long g20;
    long b20;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 6)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'llllll' (&r10, &g10, &b10, &r20, &g20, &b20)\n");
        #endif

        char parse_parameters_string[] = "llllll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &r10, &g10, &b10, &r20, &g20, &b20 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 6:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Replace((unsigned char) r10, (unsigned char) g10, (unsigned char) b10, (unsigned char) r20, (unsigned char) g20, (unsigned char) b20)\n\n");
                #endif

                ((wxImage_php*)native_object)->Replace((unsigned char) r10, (unsigned char) g10, (unsigned char) b10, (unsigned char) r20, (unsigned char) g20, (unsigned char) b20);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::Replace\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxImage::RemoveHandler(string name)
   Finds the handler with the given name, and removes it. */
PHP_METHOD(php_wxImage, RemoveHandler)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::RemoveHandler\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::RemoveHandler call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxImage::RemoveHandler(wxString(name0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(wxImage::RemoveHandler(wxString(name0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::RemoveHandler\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImage::Paste(wxImage image, int x, int y, wxImageAlphaBlendMode alphaBlend)
   Copy the data of the given image to the specified position in this image. */
PHP_METHOD(php_wxImage, Paste)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::Paste\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::Paste call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* image0;
    wxImage* object_pointer0_0 = 0;
    long x0;
    long y0;
    long alphaBlend0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 3  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'Oll|l' (&image0, php_wxImage_entry, &x0, &y0, &alphaBlend0)\n");
        #endif

        char parse_parameters_string[] = "Oll|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &image0, php_wxImage_entry, &x0, &y0, &alphaBlend0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(image0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxImage_P(image0)->object_type;
                    argument_native_object = (void*) Z_wxImage_P(image0)->native_object;
                    object_pointer0_0 = (wxImage*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'image' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(image0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'image' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Paste(*(wxImage*) object_pointer0_0, (int) x0, (int) y0)\n\n");
                #endif

                ((wxImage_php*)native_object)->Paste(*(wxImage*) object_pointer0_0, (int) x0, (int) y0);

                references->AddReference(image0, "wxImage::Paste at call 3 with 3 argument(s)");

                return;
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Paste(*(wxImage*) object_pointer0_0, (int) x0, (int) y0, (wxImageAlphaBlendMode) alphaBlend0)\n\n");
                #endif

                ((wxImage_php*)native_object)->Paste(*(wxImage*) object_pointer0_0, (int) x0, (int) y0, (wxImageAlphaBlendMode) alphaBlend0);

                references->AddReference(image0, "wxImage::Paste at call 3 with 4 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::Paste\n"
        );
    }
}
/* }}} */

/* {{{ proto wxImage wxImage::Mirror(bool horizontally)
   Returns a mirrored copy of the image. */
PHP_METHOD(php_wxImage, Mirror)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::Mirror\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::Mirror call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool horizontally0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|b' (&horizontally0)\n");
        #endif

        char parse_parameters_string[] = "|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &horizontally0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Mirror() to return new object\n\n");
                #endif

                wxImage value_to_return0;
                value_to_return0 = ((wxImage_php*)native_object)->Mirror();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo0 = Z_wxImage_P(return_value);
                zo0->native_object = (wxImage_php*) ptr;


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Mirror(horizontally0) to return new object\n\n");
                #endif

                wxImage value_to_return1;
                value_to_return1 = ((wxImage_php*)native_object)->Mirror(horizontally0);
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo1 = Z_wxImage_P(return_value);
                zo1->native_object = (wxImage_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::Mirror\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxImage::LoadFile(wxInputStream &stream, wxBitmapType type, int index)
   Loads an image from an input stream. */
PHP_METHOD(php_wxImage, LoadFile)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::LoadFile\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::LoadFile call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* stream0;
    wxInputStream* object_pointer0_0 = 0;
    long type0;
    long index0;
    bool overload0_called = false;

    //Parameters for overload 1
    char* name1;
    size_t name_len1;
    long type1;
    long index1;
    bool overload1_called = false;

    //Parameters for overload 2
    char* name2;
    size_t name_len2;
    char* mimetype2;
    size_t mimetype_len2;
    long index2;
    bool overload2_called = false;

    //Parameters for overload 3
    zval* stream3;
    wxInputStream* object_pointer3_0 = 0;
    char* mimetype3;
    size_t mimetype_len3;
    long index3;
    bool overload3_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'o|ll' (&stream0, &type0, &index0)\n");
        #endif

        char parse_parameters_string[] = "o|ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &stream0, &type0, &index0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(stream0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxInputStream_P(stream0)->object_type;
                    argument_native_object = (void*) Z_wxInputStream_P(stream0)->native_object;
                    object_pointer0_0 = (wxInputStream*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
                    {
                        goto overload1;
                    }
                }
                else if(Z_TYPE_P(stream0) != IS_NULL)
                {
                    goto overload1;
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 1  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|ll' (&name1, &name_len1, &type1, &index1)\n");
        #endif

        char parse_parameters_string[] = "s|ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name1, &name_len1, &type1, &index1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ss|l' (&name2, &name_len2, &mimetype2, &mimetype_len2, &index2)\n");
        #endif

        char parse_parameters_string[] = "ss|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name2, &name_len2, &mimetype2, &mimetype_len2, &index2 ) == SUCCESS)
        {
            overload2_called = true;
            already_called = true;
        }
    }

    //Overload 3
    overload3:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'os|l' (&stream3, &mimetype3, &mimetype_len3, &index3)\n");
        #endif

        char parse_parameters_string[] = "os|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &stream3, &mimetype3, &mimetype_len3, &index3 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(stream3) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxInputStream_P(stream3)->object_type;
                    argument_native_object = (void*) Z_wxInputStream_P(stream3)->native_object;
                    object_pointer3_0 = (wxInputStream*) argument_native_object;
                    if (!object_pointer3_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'stream' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(stream3) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'stream' not null, could not be retreived correctly.");
                }
            }

            overload3_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::LoadFile(*(wxInputStream*) object_pointer0_0))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->LoadFile(*(wxInputStream*) object_pointer0_0));

                references->AddReference(stream0, "wxImage::LoadFile at call 3 with 1 argument(s)");

                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::LoadFile(*(wxInputStream*) object_pointer0_0, (wxBitmapType) type0))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->LoadFile(*(wxInputStream*) object_pointer0_0, (wxBitmapType) type0));

                references->AddReference(stream0, "wxImage::LoadFile at call 3 with 2 argument(s)");

                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::LoadFile(*(wxInputStream*) object_pointer0_0, (wxBitmapType) type0, (int) index0))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->LoadFile(*(wxInputStream*) object_pointer0_0, (wxBitmapType) type0, (int) index0));

                references->AddReference(stream0, "wxImage::LoadFile at call 3 with 3 argument(s)");

                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::LoadFile(wxString(name1, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->LoadFile(wxString(name1, wxConvUTF8)));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::LoadFile(wxString(name1, wxConvUTF8), (wxBitmapType) type1))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->LoadFile(wxString(name1, wxConvUTF8), (wxBitmapType) type1));


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::LoadFile(wxString(name1, wxConvUTF8), (wxBitmapType) type1, (int) index1))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->LoadFile(wxString(name1, wxConvUTF8), (wxBitmapType) type1, (int) index1));


                return;
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::LoadFile(wxString(name2, wxConvUTF8), wxString(mimetype2, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->LoadFile(wxString(name2, wxConvUTF8), wxString(mimetype2, wxConvUTF8)));


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::LoadFile(wxString(name2, wxConvUTF8), wxString(mimetype2, wxConvUTF8), (int) index2))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->LoadFile(wxString(name2, wxConvUTF8), wxString(mimetype2, wxConvUTF8), (int) index2));


                return;
                break;
            }
        }
    }

    if(overload3_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::LoadFile(*(wxInputStream*) object_pointer3_0, wxString(mimetype3, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->LoadFile(*(wxInputStream*) object_pointer3_0, wxString(mimetype3, wxConvUTF8)));

                references->AddReference(stream3, "wxImage::LoadFile at call 3 with 2 argument(s)");

                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::LoadFile(*(wxInputStream*) object_pointer3_0, wxString(mimetype3, wxConvUTF8), (int) index3))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->LoadFile(*(wxInputStream*) object_pointer3_0, wxString(mimetype3, wxConvUTF8), (int) index3));

                references->AddReference(stream3, "wxImage::LoadFile at call 3 with 3 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::LoadFile\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxImage::IsTransparent(int x, int y, int threshold)
   Returns true if the given pixel is transparent, i.e. either has the mask colour if this image has a mask or if this image has alpha channel and alpha value of this pixel is strictly less than threshold. */
PHP_METHOD(php_wxImage, IsTransparent)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::IsTransparent\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::IsTransparent call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long x0;
    long y0;
    long threshold0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll|l' (&x0, &y0, &threshold0)\n");
        #endif

        char parse_parameters_string[] = "ll|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &x0, &y0, &threshold0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::IsTransparent((int) x0, (int) y0))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->IsTransparent((int) x0, (int) y0));


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::IsTransparent((int) x0, (int) y0, (unsigned char) threshold0))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->IsTransparent((int) x0, (int) y0, (unsigned char) threshold0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::IsTransparent\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxImage::IsOk()
   Returns true if image data is present. */
PHP_METHOD(php_wxImage, IsOk)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::IsOk\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::IsOk call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::IsOk())\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->IsOk());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::IsOk\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImage::InsertHandler(wxImageHandler &handler)
   Adds a handler at the start of the static list of format handlers. */
PHP_METHOD(php_wxImage, InsertHandler)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::InsertHandler\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::InsertHandler call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* handler0;
    wxImageHandler* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&handler0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &handler0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(handler0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxImageHandler_P(handler0)->object_type;
                    argument_native_object = (void*) Z_wxImageHandler_P(handler0)->native_object;
                    object_pointer0_0 = (wxImageHandler*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXIMAGEHANDLER_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'handler' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(handler0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'handler' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxImage::InsertHandler((wxImageHandler*) object_pointer0_0)\n\n");
                #endif

                wxImage::InsertHandler((wxImageHandler*) object_pointer0_0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::InsertHandler\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImage::InitStandardHandlers()
   Internal use only. */
PHP_METHOD(php_wxImage, InitStandardHandlers)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::InitStandardHandlers\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::InitStandardHandlers call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxImage::InitStandardHandlers()\n\n");
                #endif

                wxImage::InitStandardHandlers();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::InitStandardHandlers\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImage::InitAlpha()
   Initializes the image alpha channel data. */
PHP_METHOD(php_wxImage, InitAlpha)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::InitAlpha\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::InitAlpha call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::InitAlpha()\n\n");
                #endif

                ((wxImage_php*)native_object)->InitAlpha();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::InitAlpha\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxImage::HasOption(string name)
   Returns true if the given option is present. */
PHP_METHOD(php_wxImage, HasOption)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::HasOption\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::HasOption call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::HasOption(wxString(name0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->HasOption(wxString(name0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::HasOption\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxImage::HasMask()
   Returns true if there is a mask active, false otherwise. */
PHP_METHOD(php_wxImage, HasMask)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::HasMask\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::HasMask call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::HasMask())\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->HasMask());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::HasMask\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxImage::HasAlpha()
   Returns true if this image has alpha channel, false otherwise. */
PHP_METHOD(php_wxImage, HasAlpha)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::HasAlpha\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::HasAlpha call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::HasAlpha())\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->HasAlpha());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::HasAlpha\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxImage::GetWidth()
   Gets the width of the image in pixels. */
PHP_METHOD(php_wxImage, GetWidth)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::GetWidth\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::GetWidth call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxImage::GetWidth())\n\n");
                #endif

                RETVAL_LONG(((wxImage_php*)native_object)->GetWidth());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::GetWidth\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmapType wxImage::GetType()
   Gets the type of image found by LoadFile() or specified with SaveFile(). */
PHP_METHOD(php_wxImage, GetType)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::GetType\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::GetType call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxImage::GetType())\n\n");
                #endif

                RETVAL_LONG(((wxImage_php*)native_object)->GetType());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::GetType\n"
        );
    }
}
/* }}} */

/* {{{ proto wxImage wxImage::GetSubImage(wxRect rect)
   Returns a sub image of the current one as long as the rect belongs entirely to the image. */
PHP_METHOD(php_wxImage, GetSubImage)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::GetSubImage\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::GetSubImage call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* rect0;
    wxRect* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&rect0, php_wxRect_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &rect0, php_wxRect_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(rect0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxRect_P(rect0)->object_type;
                    argument_native_object = (void*) Z_wxRect_P(rect0)->native_object;
                    object_pointer0_0 = (wxRect*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(rect0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::GetSubImage(*(wxRect*) object_pointer0_0) to return new object\n\n");
                #endif

                wxImage value_to_return1;
                value_to_return1 = ((wxImage_php*)native_object)->GetSubImage(*(wxRect*) object_pointer0_0);
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo1 = Z_wxImage_P(return_value);
                zo1->native_object = (wxImage_php*) ptr;

                references->AddReference(rect0, "wxImage::GetSubImage at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::GetSubImage\n"
        );
    }
}
/* }}} */

/* {{{ proto wxSize wxImage::GetSize()
   Returns the size of the image in pixels. */
PHP_METHOD(php_wxImage, GetSize)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::GetSize\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::GetSize call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::GetSize() to return new object\n\n");
                #endif

                wxSize value_to_return0;
                value_to_return0 = ((wxImage_php*)native_object)->GetSize();
                void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxSize));
                object_init_ex(return_value, php_wxSize_entry);
                ((wxSize_php*)ptr)->phpObj = *return_value;
                zo_wxSize* zo0 = Z_wxSize_P(return_value);
                zo0->native_object = (wxSize_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::GetSize\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxImage::GetRed(int x, int y)
   Returns the red intensity at the given coordinate. */
PHP_METHOD(php_wxImage, GetRed)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::GetRed\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::GetRed call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long x0;
    long y0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &x0, &y0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxImage::GetRed((int) x0, (int) y0))\n\n");
                #endif

                RETVAL_LONG(((wxImage_php*)native_object)->GetRed((int) x0, (int) y0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::GetRed\n"
        );
    }
}
/* }}} */

/* {{{ proto wxPalette wxImage::GetPalette()
   Returns the palette associated with the image. */
PHP_METHOD(php_wxImage, GetPalette)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::GetPalette\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::GetPalette call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::GetPalette() to return object reference\n\n");
                #endif

                wxPalette_php* value_to_return0;
                value_to_return0 = (wxPalette_php*) &((wxImage_php*)native_object)->GetPalette();

                if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxPalette_entry);
                    Z_wxPalette_P(return_value)->native_object = (wxPalette_php*) value_to_return0;
                }

                if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxImage::GetPalette at call 6 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::GetPalette\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxImage::GetOrFindMaskColour(int &r, int &g, int &b)
   Get the current mask colour or find a suitable unused colour that could be used as a mask colour. */
PHP_METHOD(php_wxImage, GetOrFindMaskColour)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::GetOrFindMaskColour\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::GetOrFindMaskColour call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long* r0;
    zval r0_ref;
    long* g0;
    zval g0_ref;
    long* b0;
    zval b0_ref;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'lll' (r0, g0, b0)\n");
        #endif

        char parse_parameters_string[] = "lll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, r0, g0, b0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;

            char parse_references_string[] = "zzz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, r0_ref, g0_ref, b0_ref );
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::GetOrFindMaskColour((unsigned char*) r0, (unsigned char*) g0, (unsigned char*) b0))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->GetOrFindMaskColour((unsigned char*) r0, (unsigned char*) g0, (unsigned char*) b0));

                size_t elements_returned0_0 = sizeof(r0)/sizeof(*r0);
                array_init(&r0_ref);
                for(size_t i=0; i<elements_returned0_0; i++)
                {
                    add_next_index_long(&r0_ref, r0[i]);
                }
                size_t elements_returned0_1 = sizeof(g0)/sizeof(*g0);
                array_init(&g0_ref);
                for(size_t i=0; i<elements_returned0_1; i++)
                {
                    add_next_index_long(&g0_ref, g0[i]);
                }
                size_t elements_returned0_2 = sizeof(b0)/sizeof(*b0);
                array_init(&b0_ref);
                for(size_t i=0; i<elements_returned0_2; i++)
                {
                    add_next_index_long(&b0_ref, b0[i]);
                }

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::GetOrFindMaskColour\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxImage::GetOptionInt(string name)
   Gets a user-defined integer-valued option. */
PHP_METHOD(php_wxImage, GetOptionInt)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::GetOptionInt\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::GetOptionInt call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxImage::GetOptionInt(wxString(name0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_LONG(((wxImage_php*)native_object)->GetOptionInt(wxString(name0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::GetOptionInt\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxImage::GetOption(string name)
   Gets a user-defined string-valued option. */
PHP_METHOD(php_wxImage, GetOption)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::GetOption\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::GetOption call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxImage::GetOption(wxString(name0, wxConvUTF8)).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = ((wxImage_php*)native_object)->GetOption(wxString(name0, wxConvUTF8));
                RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::GetOption\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxImage::GetMaskRed()
   Gets the red value of the mask colour. */
PHP_METHOD(php_wxImage, GetMaskRed)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::GetMaskRed\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::GetMaskRed call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxImage::GetMaskRed())\n\n");
                #endif

                RETVAL_LONG(((wxImage_php*)native_object)->GetMaskRed());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::GetMaskRed\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxImage::GetMaskGreen()
   Gets the green value of the mask colour. */
PHP_METHOD(php_wxImage, GetMaskGreen)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::GetMaskGreen\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::GetMaskGreen call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxImage::GetMaskGreen())\n\n");
                #endif

                RETVAL_LONG(((wxImage_php*)native_object)->GetMaskGreen());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::GetMaskGreen\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxImage::GetMaskBlue()
   Gets the blue value of the mask colour. */
PHP_METHOD(php_wxImage, GetMaskBlue)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::GetMaskBlue\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::GetMaskBlue call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxImage::GetMaskBlue())\n\n");
                #endif

                RETVAL_LONG(((wxImage_php*)native_object)->GetMaskBlue());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::GetMaskBlue\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxImage::GetImageExtWildcard()
   Iterates all registered wxImageHandler objects, and returns a string containing file extension masks suitable for passing to file open/save dialog boxes. */
PHP_METHOD(php_wxImage, GetImageExtWildcard)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::GetImageExtWildcard\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::GetImageExtWildcard call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxImage::GetImageExtWildcard().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = wxImage::GetImageExtWildcard();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::GetImageExtWildcard\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxImage::GetImageCount(string filename, wxBitmapType type)
   If the image file contains more than one image and the image handler is capable of retrieving these individually, this function will return the number of available images. */
PHP_METHOD(php_wxImage, GetImageCount)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::GetImageCount\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::GetImageCount call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* filename0;
    size_t filename_len0;
    long type0;
    bool overload0_called = false;

    //Parameters for overload 1
    zval* stream1;
    wxInputStream* object_pointer1_0 = 0;
    long type1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|l' (&filename0, &filename_len0, &type0)\n");
        #endif

        char parse_parameters_string[] = "s|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &filename0, &filename_len0, &type0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'o|l' (&stream1, &type1)\n");
        #endif

        char parse_parameters_string[] = "o|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &stream1, &type1 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(stream1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxInputStream_P(stream1)->object_type;
                    argument_native_object = (void*) Z_wxInputStream_P(stream1)->native_object;
                    object_pointer1_0 = (wxInputStream*) argument_native_object;
                    if (!object_pointer1_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'stream' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(stream1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'stream' not null, could not be retreived correctly.");
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_LONG(wxImage::GetImageCount(wxString(filename0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_LONG(wxImage::GetImageCount(wxString(filename0, wxConvUTF8)));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_LONG(wxImage::GetImageCount(wxString(filename0, wxConvUTF8), (wxBitmapType) type0))\n\n");
                #endif

                RETVAL_LONG(wxImage::GetImageCount(wxString(filename0, wxConvUTF8), (wxBitmapType) type0));


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_LONG(wxImage::GetImageCount(*(wxInputStream*) object_pointer1_0))\n\n");
                #endif

                RETVAL_LONG(wxImage::GetImageCount(*(wxInputStream*) object_pointer1_0));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_LONG(wxImage::GetImageCount(*(wxInputStream*) object_pointer1_0, (wxBitmapType) type1))\n\n");
                #endif

                RETVAL_LONG(wxImage::GetImageCount(*(wxInputStream*) object_pointer1_0, (wxBitmapType) type1));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::GetImageCount\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxImage::GetHeight()
   Gets the height of the image in pixels. */
PHP_METHOD(php_wxImage, GetHeight)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::GetHeight\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::GetHeight call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxImage::GetHeight())\n\n");
                #endif

                RETVAL_LONG(((wxImage_php*)native_object)->GetHeight());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::GetHeight\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxImage::GetGreen(int x, int y)
   Returns the green intensity at the given coordinate. */
PHP_METHOD(php_wxImage, GetGreen)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::GetGreen\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::GetGreen call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long x0;
    long y0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &x0, &y0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxImage::GetGreen((int) x0, (int) y0))\n\n");
                #endif

                RETVAL_LONG(((wxImage_php*)native_object)->GetGreen((int) x0, (int) y0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::GetGreen\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxImage::GetData()
   Returns the image data as an array. */
PHP_METHOD(php_wxImage, GetData)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::GetData\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::GetData call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf(
                    "Executing RETURN_STRING(wxImage::GetData())\n\n"
                );
                #endif

                size_t bytes_count = ((wxImage_php*)native_object)->GetWidth()
                    * ((wxImage_php*)native_object)->GetHeight()
                    * 3
                ;

                unsigned char* value_to_return0;
                value_to_return0 = (unsigned char*) emalloc(bytes_count);

                memcpy(
                    value_to_return0,
                    ((wxImage_php*)native_object)->GetData(),
                    bytes_count
                );

                RETVAL_STRINGL(
                    (char*) value_to_return0,
                    bytes_count
                );

                return;
                break;
            }
        }
    }

    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::GetData\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxImage::GetBlue(int x, int y)
   Returns the blue intensity at the given coordinate. */
PHP_METHOD(php_wxImage, GetBlue)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::GetBlue\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::GetBlue call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long x0;
    long y0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &x0, &y0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxImage::GetBlue((int) x0, (int) y0))\n\n");
                #endif

                RETVAL_LONG(((wxImage_php*)native_object)->GetBlue((int) x0, (int) y0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::GetBlue\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxImage::GetAlpha()
   Returns pointer to the array storing the alpha values for this image. */
PHP_METHOD(php_wxImage, GetAlpha)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::GetAlpha\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::GetAlpha call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    long x1;
    long y1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (&x1, &y1)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &x1, &y1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxImage::GetAlpha())\n\n");
                #endif

                RETVAL_LONG(*(((wxImage_php*)native_object)->GetAlpha()));


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxImage::GetAlpha((int) x1, (int) y1))\n\n");
                #endif

                RETVAL_LONG(((wxImage_php*)native_object)->GetAlpha((int) x1, (int) y1));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::GetAlpha\n"
        );
    }
}
/* }}} */

/* {{{ proto wxImageHandler wxImage::FindHandlerMime(string mimetype)
   Finds the handler associated with the given MIME type. */
PHP_METHOD(php_wxImage, FindHandlerMime)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::FindHandlerMime\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::FindHandlerMime call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* mimetype0;
    size_t mimetype_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&mimetype0, &mimetype_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &mimetype0, &mimetype_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxImage::FindHandlerMime(wxString(mimetype0, wxConvUTF8)) to return object pointer\n\n");
                #endif

                wxImageHandler_php* value_to_return1;
                value_to_return1 = (wxImageHandler_php*) wxImage::FindHandlerMime(wxString(mimetype0, wxConvUTF8));
                if(value_to_return1 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return1->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return1->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return1->phpObj);
                        zval_add_ref(&value_to_return1->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxImageHandler_entry);
                    Z_wxImageHandler_P(return_value)->native_object = (wxImageHandler_php*) value_to_return1;
                }



                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::FindHandlerMime\n"
        );
    }
}
/* }}} */

/* {{{ proto wxImageHandler wxImage::FindHandler(string name)
   Finds the handler with the given name. */
PHP_METHOD(php_wxImage, FindHandler)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::FindHandler\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::FindHandler call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    bool overload0_called = false;

    //Parameters for overload 1
    char* extension1;
    size_t extension_len1;
    long imageType1;
    bool overload1_called = false;

    //Parameters for overload 2
    long imageType2;
    bool overload2_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sl' (&extension1, &extension_len1, &imageType1)\n");
        #endif

        char parse_parameters_string[] = "sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &extension1, &extension_len1, &imageType1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&imageType2)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &imageType2 ) == SUCCESS)
        {
            overload2_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxImage::FindHandler(wxString(name0, wxConvUTF8)) to return object pointer\n\n");
                #endif

                wxImageHandler_php* value_to_return1;
                value_to_return1 = (wxImageHandler_php*) wxImage::FindHandler(wxString(name0, wxConvUTF8));
                if(value_to_return1 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return1->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return1->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return1->phpObj);
                        zval_add_ref(&value_to_return1->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxImageHandler_entry);
                    Z_wxImageHandler_P(return_value)->native_object = (wxImageHandler_php*) value_to_return1;
                }



                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxImage::FindHandler(wxString(extension1, wxConvUTF8), (wxBitmapType) imageType1) to return object pointer\n\n");
                #endif

                wxImageHandler_php* value_to_return2;
                value_to_return2 = (wxImageHandler_php*) wxImage::FindHandler(wxString(extension1, wxConvUTF8), (wxBitmapType) imageType1);
                if(value_to_return2 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return2->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return2->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return2->phpObj);
                        zval_add_ref(&value_to_return2->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxImageHandler_entry);
                    Z_wxImageHandler_P(return_value)->native_object = (wxImageHandler_php*) value_to_return2;
                }



                return;
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxImage::FindHandler((wxBitmapType) imageType2) to return object pointer\n\n");
                #endif

                wxImageHandler_php* value_to_return1;
                value_to_return1 = (wxImageHandler_php*) wxImage::FindHandler((wxBitmapType) imageType2);
                if(value_to_return1 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return1->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return1->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return1->phpObj);
                        zval_add_ref(&value_to_return1->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxImageHandler_entry);
                    Z_wxImageHandler_P(return_value)->native_object = (wxImageHandler_php*) value_to_return1;
                }



                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::FindHandler\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxImage::FindFirstUnusedColour(int &r, int &g, int &b, int startR, int startG, int startB)
   Finds the first colour that is never used in the image. */
PHP_METHOD(php_wxImage, FindFirstUnusedColour)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::FindFirstUnusedColour\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::FindFirstUnusedColour call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long* r0;
    zval r0_ref;
    long* g0;
    zval g0_ref;
    long* b0;
    zval b0_ref;
    long startR0;
    long startG0;
    long startB0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 3  && arguments_received <= 6)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'lll|lll' (r0, g0, b0, &startR0, &startG0, &startB0)\n");
        #endif

        char parse_parameters_string[] = "lll|lll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, r0, g0, b0, &startR0, &startG0, &startB0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;

            char parse_references_string[] = "zzz|zzz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, r0_ref, g0_ref, b0_ref, dummy, dummy, dummy );
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::FindFirstUnusedColour((unsigned char*) r0, (unsigned char*) g0, (unsigned char*) b0))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->FindFirstUnusedColour((unsigned char*) r0, (unsigned char*) g0, (unsigned char*) b0));

                size_t elements_returned0_0 = sizeof(r0)/sizeof(*r0);
                array_init(&r0_ref);
                for(size_t i=0; i<elements_returned0_0; i++)
                {
                    add_next_index_long(&r0_ref, r0[i]);
                }
                size_t elements_returned0_1 = sizeof(g0)/sizeof(*g0);
                array_init(&g0_ref);
                for(size_t i=0; i<elements_returned0_1; i++)
                {
                    add_next_index_long(&g0_ref, g0[i]);
                }
                size_t elements_returned0_2 = sizeof(b0)/sizeof(*b0);
                array_init(&b0_ref);
                for(size_t i=0; i<elements_returned0_2; i++)
                {
                    add_next_index_long(&b0_ref, b0[i]);
                }

                return;
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::FindFirstUnusedColour((unsigned char*) r0, (unsigned char*) g0, (unsigned char*) b0, (unsigned char) startR0))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->FindFirstUnusedColour((unsigned char*) r0, (unsigned char*) g0, (unsigned char*) b0, (unsigned char) startR0));

                size_t elements_returned0_0 = sizeof(r0)/sizeof(*r0);
                array_init(&r0_ref);
                for(size_t i=0; i<elements_returned0_0; i++)
                {
                    add_next_index_long(&r0_ref, r0[i]);
                }
                size_t elements_returned0_1 = sizeof(g0)/sizeof(*g0);
                array_init(&g0_ref);
                for(size_t i=0; i<elements_returned0_1; i++)
                {
                    add_next_index_long(&g0_ref, g0[i]);
                }
                size_t elements_returned0_2 = sizeof(b0)/sizeof(*b0);
                array_init(&b0_ref);
                for(size_t i=0; i<elements_returned0_2; i++)
                {
                    add_next_index_long(&b0_ref, b0[i]);
                }

                return;
                break;
            }
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::FindFirstUnusedColour((unsigned char*) r0, (unsigned char*) g0, (unsigned char*) b0, (unsigned char) startR0, (unsigned char) startG0))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->FindFirstUnusedColour((unsigned char*) r0, (unsigned char*) g0, (unsigned char*) b0, (unsigned char) startR0, (unsigned char) startG0));

                size_t elements_returned0_0 = sizeof(r0)/sizeof(*r0);
                array_init(&r0_ref);
                for(size_t i=0; i<elements_returned0_0; i++)
                {
                    add_next_index_long(&r0_ref, r0[i]);
                }
                size_t elements_returned0_1 = sizeof(g0)/sizeof(*g0);
                array_init(&g0_ref);
                for(size_t i=0; i<elements_returned0_1; i++)
                {
                    add_next_index_long(&g0_ref, g0[i]);
                }
                size_t elements_returned0_2 = sizeof(b0)/sizeof(*b0);
                array_init(&b0_ref);
                for(size_t i=0; i<elements_returned0_2; i++)
                {
                    add_next_index_long(&b0_ref, b0[i]);
                }

                return;
                break;
            }
            case 6:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::FindFirstUnusedColour((unsigned char*) r0, (unsigned char*) g0, (unsigned char*) b0, (unsigned char) startR0, (unsigned char) startG0, (unsigned char) startB0))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->FindFirstUnusedColour((unsigned char*) r0, (unsigned char*) g0, (unsigned char*) b0, (unsigned char) startR0, (unsigned char) startG0, (unsigned char) startB0));

                size_t elements_returned0_0 = sizeof(r0)/sizeof(*r0);
                array_init(&r0_ref);
                for(size_t i=0; i<elements_returned0_0; i++)
                {
                    add_next_index_long(&r0_ref, r0[i]);
                }
                size_t elements_returned0_1 = sizeof(g0)/sizeof(*g0);
                array_init(&g0_ref);
                for(size_t i=0; i<elements_returned0_1; i++)
                {
                    add_next_index_long(&g0_ref, g0[i]);
                }
                size_t elements_returned0_2 = sizeof(b0)/sizeof(*b0);
                array_init(&b0_ref);
                for(size_t i=0; i<elements_returned0_2; i++)
                {
                    add_next_index_long(&b0_ref, b0[i]);
                }

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::FindFirstUnusedColour\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImage::Destroy()
   Destroys the image data. */
PHP_METHOD(php_wxImage, Destroy)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::Destroy\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::Destroy call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Destroy()\n\n");
                #endif

                ((wxImage_php*)native_object)->Destroy();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::Destroy\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxImage::Create(int width, int height, bool clear)
   Creates a fresh image. */
PHP_METHOD(php_wxImage, Create)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::Create\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::Create call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long width0;
    long height0;
    bool clear0;
    bool overload0_called = false;

    //Parameters for overload 1
    zval* sz1;
    wxSize* object_pointer1_0 = 0;
    bool clear1;
    bool overload1_called = false;

    //Parameters for overload 2
    long width2;
    long height2;
    long* data2;
    zval data2_ref;
    bool static_data2;
    bool overload2_called = false;

    //Parameters for overload 3
    zval* sz3;
    wxSize* object_pointer3_0 = 0;
    long* data3;
    zval data3_ref;
    bool static_data3;
    bool overload3_called = false;

    //Parameters for overload 4
    long width4;
    long height4;
    long* data4;
    zval data4_ref;
    long* alpha4;
    zval alpha4_ref;
    bool static_data4;
    bool overload4_called = false;

    //Parameters for overload 5
    zval* sz5;
    wxSize* object_pointer5_0 = 0;
    long* data5;
    zval data5_ref;
    long* alpha5;
    zval alpha5_ref;
    bool static_data5;
    bool overload5_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll|b' (&width0, &height0, &clear0)\n");
        #endif

        char parse_parameters_string[] = "ll|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &width0, &height0, &clear0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O|b' (&sz1, php_wxSize_entry, &clear1)\n");
        #endif

        char parse_parameters_string[] = "O|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &sz1, php_wxSize_entry, &clear1 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(sz1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(sz1)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(sz1)->native_object;
                    object_pointer1_0 = (wxSize*) argument_native_object;
                    if (!object_pointer1_0 )
                    {
                        goto overload2;
                    }
                }
                else if(Z_TYPE_P(sz1) != IS_NULL)
                {
                    goto overload2;
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received >= 3  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'lll|b' (&width2, &height2, data2, &static_data2)\n");
        #endif

        char parse_parameters_string[] = "lll|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &width2, &height2, data2, &static_data2 ) == SUCCESS)
        {
            overload2_called = true;
            already_called = true;

            char parse_references_string[] = "zzz|z";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, dummy, data2_ref, dummy );
        }
    }

    //Overload 3
    overload3:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'Ol|b' (&sz3, php_wxSize_entry, data3, &static_data3)\n");
        #endif

        char parse_parameters_string[] = "Ol|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &sz3, php_wxSize_entry, data3, &static_data3 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(sz3) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(sz3)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(sz3)->native_object;
                    object_pointer3_0 = (wxSize*) argument_native_object;
                    if (!object_pointer3_0 )
                    {
                        goto overload4;
                    }
                }
                else if(Z_TYPE_P(sz3) != IS_NULL)
                {
                    goto overload4;
                }
            }

            overload3_called = true;
            already_called = true;

            char parse_references_string[] = "zz|z";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, &dummy, data3_ref, dummy );
        }
    }

    //Overload 4
    overload4:
    if(!already_called && arguments_received >= 4  && arguments_received <= 5)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'llll|b' (&width4, &height4, data4, alpha4, &static_data4)\n");
        #endif

        char parse_parameters_string[] = "llll|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &width4, &height4, data4, alpha4, &static_data4 ) == SUCCESS)
        {
            overload4_called = true;
            already_called = true;

            char parse_references_string[] = "zzzz|z";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, dummy, data4_ref, alpha4_ref, dummy );
        }
    }

    //Overload 5
    overload5:
    if(!already_called && arguments_received >= 3  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'Oll|b' (&sz5, php_wxSize_entry, data5, alpha5, &static_data5)\n");
        #endif

        char parse_parameters_string[] = "Oll|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &sz5, php_wxSize_entry, data5, alpha5, &static_data5 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(sz5) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(sz5)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(sz5)->native_object;
                    object_pointer5_0 = (wxSize*) argument_native_object;
                    if (!object_pointer5_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'sz' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(sz5) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'sz' not null, could not be retreived correctly.");
                }
            }

            overload5_called = true;
            already_called = true;

            char parse_references_string[] = "zzz|z";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, &dummy, data5_ref, alpha5_ref, dummy );
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::Create((int) width0, (int) height0))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->Create((int) width0, (int) height0));


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::Create((int) width0, (int) height0, clear0))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->Create((int) width0, (int) height0, clear0));


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::Create(*(wxSize*) object_pointer1_0))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->Create(*(wxSize*) object_pointer1_0));

                references->AddReference(sz1, "wxImage::Create at call 3 with 1 argument(s)");

                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::Create(*(wxSize*) object_pointer1_0, clear1))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->Create(*(wxSize*) object_pointer1_0, clear1));

                references->AddReference(sz1, "wxImage::Create at call 3 with 2 argument(s)");

                return;
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::Create((int) width2, (int) height2, (unsigned char*) data2))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->Create((int) width2, (int) height2, (unsigned char*) data2));

                size_t elements_returned2_2 = sizeof(data2)/sizeof(*data2);
                array_init(&data2_ref);
                for(size_t i=0; i<elements_returned2_2; i++)
                {
                    add_next_index_long(&data2_ref, data2[i]);
                }

                return;
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::Create((int) width2, (int) height2, (unsigned char*) data2, static_data2))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->Create((int) width2, (int) height2, (unsigned char*) data2, static_data2));

                size_t elements_returned2_2 = sizeof(data2)/sizeof(*data2);
                array_init(&data2_ref);
                for(size_t i=0; i<elements_returned2_2; i++)
                {
                    add_next_index_long(&data2_ref, data2[i]);
                }

                return;
                break;
            }
        }
    }

    if(overload3_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::Create(*(wxSize*) object_pointer3_0, (unsigned char*) data3))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->Create(*(wxSize*) object_pointer3_0, (unsigned char*) data3));

                references->AddReference(sz3, "wxImage::Create at call 3 with 2 argument(s)");
                size_t elements_returned3_1 = sizeof(data3)/sizeof(*data3);
                array_init(&data3_ref);
                for(size_t i=0; i<elements_returned3_1; i++)
                {
                    add_next_index_long(&data3_ref, data3[i]);
                }

                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::Create(*(wxSize*) object_pointer3_0, (unsigned char*) data3, static_data3))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->Create(*(wxSize*) object_pointer3_0, (unsigned char*) data3, static_data3));

                references->AddReference(sz3, "wxImage::Create at call 3 with 3 argument(s)");
                size_t elements_returned3_1 = sizeof(data3)/sizeof(*data3);
                array_init(&data3_ref);
                for(size_t i=0; i<elements_returned3_1; i++)
                {
                    add_next_index_long(&data3_ref, data3[i]);
                }

                return;
                break;
            }
        }
    }

    if(overload4_called)
    {
        switch(arguments_received)
        {
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::Create((int) width4, (int) height4, (unsigned char*) data4, (unsigned char*) alpha4))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->Create((int) width4, (int) height4, (unsigned char*) data4, (unsigned char*) alpha4));

                size_t elements_returned4_2 = sizeof(data4)/sizeof(*data4);
                array_init(&data4_ref);
                for(size_t i=0; i<elements_returned4_2; i++)
                {
                    add_next_index_long(&data4_ref, data4[i]);
                }
                size_t elements_returned4_3 = sizeof(alpha4)/sizeof(*alpha4);
                array_init(&alpha4_ref);
                for(size_t i=0; i<elements_returned4_3; i++)
                {
                    add_next_index_long(&alpha4_ref, alpha4[i]);
                }

                return;
                break;
            }
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::Create((int) width4, (int) height4, (unsigned char*) data4, (unsigned char*) alpha4, static_data4))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->Create((int) width4, (int) height4, (unsigned char*) data4, (unsigned char*) alpha4, static_data4));

                size_t elements_returned4_2 = sizeof(data4)/sizeof(*data4);
                array_init(&data4_ref);
                for(size_t i=0; i<elements_returned4_2; i++)
                {
                    add_next_index_long(&data4_ref, data4[i]);
                }
                size_t elements_returned4_3 = sizeof(alpha4)/sizeof(*alpha4);
                array_init(&alpha4_ref);
                for(size_t i=0; i<elements_returned4_3; i++)
                {
                    add_next_index_long(&alpha4_ref, alpha4[i]);
                }

                return;
                break;
            }
        }
    }

    if(overload5_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::Create(*(wxSize*) object_pointer5_0, (unsigned char*) data5, (unsigned char*) alpha5))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->Create(*(wxSize*) object_pointer5_0, (unsigned char*) data5, (unsigned char*) alpha5));

                references->AddReference(sz5, "wxImage::Create at call 3 with 3 argument(s)");
                size_t elements_returned5_1 = sizeof(data5)/sizeof(*data5);
                array_init(&data5_ref);
                for(size_t i=0; i<elements_returned5_1; i++)
                {
                    add_next_index_long(&data5_ref, data5[i]);
                }
                size_t elements_returned5_2 = sizeof(alpha5)/sizeof(*alpha5);
                array_init(&alpha5_ref);
                for(size_t i=0; i<elements_returned5_2; i++)
                {
                    add_next_index_long(&alpha5_ref, alpha5[i]);
                }

                return;
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::Create(*(wxSize*) object_pointer5_0, (unsigned char*) data5, (unsigned char*) alpha5, static_data5))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->Create(*(wxSize*) object_pointer5_0, (unsigned char*) data5, (unsigned char*) alpha5, static_data5));

                references->AddReference(sz5, "wxImage::Create at call 3 with 4 argument(s)");
                size_t elements_returned5_1 = sizeof(data5)/sizeof(*data5);
                array_init(&data5_ref);
                for(size_t i=0; i<elements_returned5_1; i++)
                {
                    add_next_index_long(&data5_ref, data5[i]);
                }
                size_t elements_returned5_2 = sizeof(alpha5)/sizeof(*alpha5);
                array_init(&alpha5_ref);
                for(size_t i=0; i<elements_returned5_2; i++)
                {
                    add_next_index_long(&alpha5_ref, alpha5[i]);
                }

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::Create\n"
        );
    }
}
/* }}} */

/* {{{ proto wxImage wxImage::Copy()
   Returns an identical copy of this image. */
PHP_METHOD(php_wxImage, Copy)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::Copy\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::Copy call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Copy() to return new object\n\n");
                #endif

                wxImage value_to_return0;
                value_to_return0 = ((wxImage_php*)native_object)->Copy();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo0 = Z_wxImage_P(return_value);
                zo0->native_object = (wxImage_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::Copy\n"
        );
    }
}
/* }}} */

/* {{{ proto wxImage wxImage::ConvertToMono(int r, int g, int b)
   Returns monochromatic version of the image. */
PHP_METHOD(php_wxImage, ConvertToMono)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::ConvertToMono\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::ConvertToMono call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long r0;
    long g0;
    long b0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'lll' (&r0, &g0, &b0)\n");
        #endif

        char parse_parameters_string[] = "lll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &r0, &g0, &b0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::ConvertToMono((unsigned char) r0, (unsigned char) g0, (unsigned char) b0) to return new object\n\n");
                #endif

                wxImage value_to_return3;
                value_to_return3 = ((wxImage_php*)native_object)->ConvertToMono((unsigned char) r0, (unsigned char) g0, (unsigned char) b0);
                ((wxRefCounter *) value_to_return3.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return3, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo3 = Z_wxImage_P(return_value);
                zo3->native_object = (wxImage_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::ConvertToMono\n"
        );
    }
}
/* }}} */

/* {{{ proto wxImage wxImage::ConvertToGreyscale(float weight_r, float weight_g, float weight_b)
   Returns a greyscale version of the image. */
PHP_METHOD(php_wxImage, ConvertToGreyscale)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::ConvertToGreyscale\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::ConvertToGreyscale call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    double weight_r0;
    double weight_g0;
    double weight_b0;
    bool overload0_called = false;

    //Parameters for overload 1
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ddd' (&weight_r0, &weight_g0, &weight_b0)\n");
        #endif

        char parse_parameters_string[] = "ddd";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &weight_r0, &weight_g0, &weight_b0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload1_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::ConvertToGreyscale(weight_r0, weight_g0, weight_b0) to return new object\n\n");
                #endif

                wxImage value_to_return3;
                value_to_return3 = ((wxImage_php*)native_object)->ConvertToGreyscale(weight_r0, weight_g0, weight_b0);
                ((wxRefCounter *) value_to_return3.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return3, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo3 = Z_wxImage_P(return_value);
                zo3->native_object = (wxImage_php*) ptr;


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::ConvertToGreyscale() to return new object\n\n");
                #endif

                wxImage value_to_return0;
                value_to_return0 = ((wxImage_php*)native_object)->ConvertToGreyscale();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo0 = Z_wxImage_P(return_value);
                zo0->native_object = (wxImage_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::ConvertToGreyscale\n"
        );
    }
}
/* }}} */

/* {{{ proto wxImage wxImage::ConvertToDisabled(int brightness)
   Returns disabled (dimmed) version of the image. */
PHP_METHOD(php_wxImage, ConvertToDisabled)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::ConvertToDisabled\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::ConvertToDisabled call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long brightness0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&brightness0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &brightness0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::ConvertToDisabled() to return new object\n\n");
                #endif

                wxImage value_to_return0;
                value_to_return0 = ((wxImage_php*)native_object)->ConvertToDisabled();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo0 = Z_wxImage_P(return_value);
                zo0->native_object = (wxImage_php*) ptr;


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::ConvertToDisabled((unsigned char) brightness0) to return new object\n\n");
                #endif

                wxImage value_to_return1;
                value_to_return1 = ((wxImage_php*)native_object)->ConvertToDisabled((unsigned char) brightness0);
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo1 = Z_wxImage_P(return_value);
                zo1->native_object = (wxImage_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::ConvertToDisabled\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxImage::ConvertAlphaToMask(int threshold)
   If the image has alpha channel, this method converts it to mask. */
PHP_METHOD(php_wxImage, ConvertAlphaToMask)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::ConvertAlphaToMask\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::ConvertAlphaToMask call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long threshold0;
    bool overload0_called = false;

    //Parameters for overload 1
    long mr1;
    long mg1;
    long mb1;
    long threshold1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&threshold0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &threshold0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 3  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'lll|l' (&mr1, &mg1, &mb1, &threshold1)\n");
        #endif

        char parse_parameters_string[] = "lll|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &mr1, &mg1, &mb1, &threshold1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::ConvertAlphaToMask())\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->ConvertAlphaToMask());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::ConvertAlphaToMask((unsigned char) threshold0))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->ConvertAlphaToMask((unsigned char) threshold0));


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::ConvertAlphaToMask((unsigned char) mr1, (unsigned char) mg1, (unsigned char) mb1))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->ConvertAlphaToMask((unsigned char) mr1, (unsigned char) mg1, (unsigned char) mb1));


                return;
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImage::ConvertAlphaToMask((unsigned char) mr1, (unsigned char) mg1, (unsigned char) mb1, (unsigned char) threshold1))\n\n");
                #endif

                RETVAL_BOOL(((wxImage_php*)native_object)->ConvertAlphaToMask((unsigned char) mr1, (unsigned char) mg1, (unsigned char) mb1, (unsigned char) threshold1));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::ConvertAlphaToMask\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImage::ClearAlpha()
   Removes the alpha channel from the image. */
PHP_METHOD(php_wxImage, ClearAlpha)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::ClearAlpha\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::ClearAlpha call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::ClearAlpha()\n\n");
                #endif

                ((wxImage_php*)native_object)->ClearAlpha();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::ClearAlpha\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImage::Clear(int value)
   Initialize the image data with zeroes (the default) or with the byte value given as value. */
PHP_METHOD(php_wxImage, Clear)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::Clear\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::Clear call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long value0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&value0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &value0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Clear()\n\n");
                #endif

                ((wxImage_php*)native_object)->Clear();


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Clear((unsigned char) value0)\n\n");
                #endif

                ((wxImage_php*)native_object)->Clear((unsigned char) value0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::Clear\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImage::CleanUpHandlers()
   Deletes all image handlers. */
PHP_METHOD(php_wxImage, CleanUpHandlers)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::CleanUpHandlers\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::CleanUpHandlers call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxImage::CleanUpHandlers()\n\n");
                #endif

                wxImage::CleanUpHandlers();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::CleanUpHandlers\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxImage::CanRead(string filename)
   Returns true if at least one of the available image handlers can read the file with the given name. */
PHP_METHOD(php_wxImage, CanRead)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::CanRead\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::CanRead call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* filename0;
    size_t filename_len0;
    bool overload0_called = false;

    //Parameters for overload 1
    zval* stream1;
    wxInputStream* object_pointer1_0 = 0;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&filename0, &filename_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &filename0, &filename_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'o' (&stream1)\n");
        #endif

        char parse_parameters_string[] = "o";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &stream1 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(stream1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxInputStream_P(stream1)->object_type;
                    argument_native_object = (void*) Z_wxInputStream_P(stream1)->native_object;
                    object_pointer1_0 = (wxInputStream*) argument_native_object;
                    if (!object_pointer1_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'stream' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(stream1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'stream' not null, could not be retreived correctly.");
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxImage::CanRead(wxString(filename0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(wxImage::CanRead(wxString(filename0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxImage::CanRead(*(wxInputStream*) object_pointer1_0))\n\n");
                #endif

                RETVAL_BOOL(wxImage::CanRead(*(wxInputStream*) object_pointer1_0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::CanRead\n"
        );
    }
}
/* }}} */

/* {{{ proto wxImage wxImage::BlurVertical(int blurRadius)
   Blurs the image in the vertical direction only. */
PHP_METHOD(php_wxImage, BlurVertical)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::BlurVertical\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::BlurVertical call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long blurRadius0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&blurRadius0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &blurRadius0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::BlurVertical((int) blurRadius0) to return new object\n\n");
                #endif

                wxImage value_to_return1;
                value_to_return1 = ((wxImage_php*)native_object)->BlurVertical((int) blurRadius0);
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo1 = Z_wxImage_P(return_value);
                zo1->native_object = (wxImage_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::BlurVertical\n"
        );
    }
}
/* }}} */

/* {{{ proto wxImage wxImage::BlurHorizontal(int blurRadius)
   Blurs the image in the horizontal direction only. */
PHP_METHOD(php_wxImage, BlurHorizontal)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::BlurHorizontal\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::BlurHorizontal call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long blurRadius0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&blurRadius0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &blurRadius0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::BlurHorizontal((int) blurRadius0) to return new object\n\n");
                #endif

                wxImage value_to_return1;
                value_to_return1 = ((wxImage_php*)native_object)->BlurHorizontal((int) blurRadius0);
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo1 = Z_wxImage_P(return_value);
                zo1->native_object = (wxImage_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::BlurHorizontal\n"
        );
    }
}
/* }}} */

/* {{{ proto wxImage wxImage::Blur(int blurRadius)
   Blurs the image in both horizontal and vertical directions by the specified pixel blurRadius. */
PHP_METHOD(php_wxImage, Blur)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::Blur\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::Blur call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long blurRadius0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&blurRadius0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &blurRadius0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Blur((int) blurRadius0) to return new object\n\n");
                #endif

                wxImage value_to_return1;
                value_to_return1 = ((wxImage_php*)native_object)->Blur((int) blurRadius0);
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo1 = Z_wxImage_P(return_value);
                zo1->native_object = (wxImage_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::Blur\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImage::AddHandler(wxImageHandler &handler)
   Register an image handler. */
PHP_METHOD(php_wxImage, AddHandler)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::AddHandler\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::AddHandler call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* handler0;
    wxImageHandler* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&handler0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &handler0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(handler0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxImageHandler_P(handler0)->object_type;
                    argument_native_object = (void*) Z_wxImageHandler_P(handler0)->native_object;
                    object_pointer0_0 = (wxImageHandler*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXIMAGEHANDLER_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'handler' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(handler0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'handler' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxImage::AddHandler((wxImageHandler*) object_pointer0_0)\n\n");
                #endif

                wxImage::AddHandler((wxImageHandler*) object_pointer0_0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::AddHandler\n"
        );
    }
}
/* }}} */

/* {{{ proto wxImage wxImage::Size(wxSize size, wxPoint pos, int red, int green, int blue)
   Returns a resized version of this image without scaling it by adding either a border with the given colour or cropping as necessary. */
PHP_METHOD(php_wxImage, Size)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImage::Size\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImage* current_object;
    wxphp_object_type current_object_type;
    wxImage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImage::Size call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGE_TYPE){
                references = &((wxImage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* size0;
    wxSize* object_pointer0_0 = 0;
    zval* pos0;
    wxPoint* object_pointer0_1 = 0;
    long red0;
    long green0;
    long blue0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 2  && arguments_received <= 5)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'OO|lll' (&size0, php_wxSize_entry, &pos0, php_wxPoint_entry, &red0, &green0, &blue0)\n");
        #endif

        char parse_parameters_string[] = "OO|lll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &size0, php_wxSize_entry, &pos0, php_wxPoint_entry, &red0, &green0, &blue0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(size0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(size0)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(size0)->native_object;
                    object_pointer0_0 = (wxSize*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(size0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 2){
                if(Z_TYPE_P(pos0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPoint_P(pos0)->object_type;
                    argument_native_object = (void*) Z_wxPoint_P(pos0)->native_object;
                    object_pointer0_1 = (wxPoint*) argument_native_object;
                    if (!object_pointer0_1 )
                    {
                        zend_error(E_ERROR, "Parameter 'pos' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(pos0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'pos' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Size(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1) to return new object\n\n");
                #endif

                wxImage value_to_return2;
                value_to_return2 = ((wxImage_php*)native_object)->Size(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1);
                ((wxRefCounter *) value_to_return2.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return2, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo2 = Z_wxImage_P(return_value);
                zo2->native_object = (wxImage_php*) ptr;

                references->AddReference(size0, "wxImage::Size at call 3 with 2 argument(s)");
                references->AddReference(pos0, "wxImage::Size at call 3 with 2 argument(s)");

                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Size(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0) to return new object\n\n");
                #endif

                wxImage value_to_return3;
                value_to_return3 = ((wxImage_php*)native_object)->Size(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0);
                ((wxRefCounter *) value_to_return3.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return3, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo3 = Z_wxImage_P(return_value);
                zo3->native_object = (wxImage_php*) ptr;

                references->AddReference(size0, "wxImage::Size at call 3 with 3 argument(s)");
                references->AddReference(pos0, "wxImage::Size at call 3 with 3 argument(s)");

                return;
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Size(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0, (int) green0) to return new object\n\n");
                #endif

                wxImage value_to_return4;
                value_to_return4 = ((wxImage_php*)native_object)->Size(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0, (int) green0);
                ((wxRefCounter *) value_to_return4.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return4, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo4 = Z_wxImage_P(return_value);
                zo4->native_object = (wxImage_php*) ptr;

                references->AddReference(size0, "wxImage::Size at call 3 with 4 argument(s)");
                references->AddReference(pos0, "wxImage::Size at call 3 with 4 argument(s)");

                return;
                break;
            }
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImage::Size(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0, (int) green0, (int) blue0) to return new object\n\n");
                #endif

                wxImage value_to_return5;
                value_to_return5 = ((wxImage_php*)native_object)->Size(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0, (int) green0, (int) blue0);
                ((wxRefCounter *) value_to_return5.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
                memcpy(ptr, (void*) &value_to_return5, sizeof(wxImage));
                object_init_ex(return_value, php_wxImage_entry);
                ((wxImage_php*)ptr)->phpObj = *return_value;
                zo_wxImage* zo5 = Z_wxImage_P(return_value);
                zo5->native_object = (wxImage_php*) ptr;

                references->AddReference(size0, "wxImage::Size at call 3 with 5 argument(s)");
                references->AddReference(pos0, "wxImage::Size at call 3 with 5 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImage::Size\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxImageList_free(void *object)
{
    zo_wxImageList* custom_object = (zo_wxImageList*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxImageList_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxImageList done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxImageList_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxImageList_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxImageList* custom_object;

    custom_object = (zo_wxImageList*) ecalloc(
        1,
        sizeof(zo_wxImageList)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxImageList_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXIMAGELIST_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto int wxImageList::Add(wxBitmap bitmap, wxBitmap mask)
   Adds a new image or images using a bitmap and optional mask bitmap. */
PHP_METHOD(php_wxImageList, Add)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageList::Add\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageList* current_object;
    wxphp_object_type current_object_type;
    wxImageList_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageList_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageList::Add call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGELIST_TYPE){
                references = &((wxImageList_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* bitmap0;
    wxBitmap* object_pointer0_0 = 0;
    zval* mask0;
    wxBitmap* object_pointer0_1 = 0;
    bool overload0_called = false;

    //Parameters for overload 1
    zval* bitmap1;
    wxBitmap* object_pointer1_0 = 0;
    zval* maskColour1;
    wxColour* object_pointer1_1 = 0;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O|O' (&bitmap0, php_wxBitmap_entry, &mask0, php_wxBitmap_entry)\n");
        #endif

        char parse_parameters_string[] = "O|O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap0, php_wxBitmap_entry, &mask0, php_wxBitmap_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap0)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap0)->native_object;
                    object_pointer0_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        goto overload1;
                    }
                }
                else if(Z_TYPE_P(bitmap0) != IS_NULL)
                {
                    goto overload1;
                }
            }

            if(arguments_received >= 2){
                if(Z_TYPE_P(mask0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(mask0)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(mask0)->native_object;
                    object_pointer0_1 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_1 )
                    {
                        goto overload1;
                    }
                }
                else if(Z_TYPE_P(mask0) != IS_NULL)
                {
                    goto overload1;
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'OO' (&bitmap1, php_wxBitmap_entry, &maskColour1, php_wxColour_entry)\n");
        #endif

        char parse_parameters_string[] = "OO";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap1, php_wxBitmap_entry, &maskColour1, php_wxColour_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap1)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap1)->native_object;
                    object_pointer1_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer1_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(bitmap1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 2){
                if(Z_TYPE_P(maskColour1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxColour_P(maskColour1)->object_type;
                    argument_native_object = (void*) Z_wxColour_P(maskColour1)->native_object;
                    object_pointer1_1 = (wxColour*) argument_native_object;
                    if (!object_pointer1_1 )
                    {
                        zend_error(E_ERROR, "Parameter 'maskColour' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(maskColour1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'maskColour' not null, could not be retreived correctly.");
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxImageList::Add(*(wxBitmap*) object_pointer0_0))\n\n");
                #endif

                RETVAL_LONG(((wxImageList_php*)native_object)->Add(*(wxBitmap*) object_pointer0_0));

                references->AddReference(bitmap0, "wxImageList::Add at call 3 with 1 argument(s)");

                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxImageList::Add(*(wxBitmap*) object_pointer0_0, *(wxBitmap*) object_pointer0_1))\n\n");
                #endif

                RETVAL_LONG(((wxImageList_php*)native_object)->Add(*(wxBitmap*) object_pointer0_0, *(wxBitmap*) object_pointer0_1));

                references->AddReference(bitmap0, "wxImageList::Add at call 3 with 2 argument(s)");
                references->AddReference(mask0, "wxImageList::Add at call 3 with 2 argument(s)");

                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxImageList::Add(*(wxBitmap*) object_pointer1_0, *(wxColour*) object_pointer1_1))\n\n");
                #endif

                RETVAL_LONG(((wxImageList_php*)native_object)->Add(*(wxBitmap*) object_pointer1_0, *(wxColour*) object_pointer1_1));

                references->AddReference(bitmap1, "wxImageList::Add at call 3 with 2 argument(s)");
                references->AddReference(maskColour1, "wxImageList::Add at call 3 with 2 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageList::Add\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxImageList::Create(int width, int height, bool mask, int initialCount)
   Initializes the list. */
PHP_METHOD(php_wxImageList, Create)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageList::Create\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageList* current_object;
    wxphp_object_type current_object_type;
    wxImageList_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageList_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageList::Create call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGELIST_TYPE){
                references = &((wxImageList_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long width0;
    long height0;
    bool mask0;
    long initialCount0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 2  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll|bl' (&width0, &height0, &mask0, &initialCount0)\n");
        #endif

        char parse_parameters_string[] = "ll|bl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &width0, &height0, &mask0, &initialCount0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImageList::Create((int) width0, (int) height0))\n\n");
                #endif

                RETVAL_BOOL(((wxImageList_php*)native_object)->Create((int) width0, (int) height0));


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImageList::Create((int) width0, (int) height0, mask0))\n\n");
                #endif

                RETVAL_BOOL(((wxImageList_php*)native_object)->Create((int) width0, (int) height0, mask0));


                return;
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImageList::Create((int) width0, (int) height0, mask0, (int) initialCount0))\n\n");
                #endif

                RETVAL_BOOL(((wxImageList_php*)native_object)->Create((int) width0, (int) height0, mask0, (int) initialCount0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageList::Create\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmap wxImageList::GetBitmap(int index)
   Returns the bitmap corresponding to the given index. */
PHP_METHOD(php_wxImageList, GetBitmap)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageList::GetBitmap\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageList* current_object;
    wxphp_object_type current_object_type;
    wxImageList_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageList_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageList::GetBitmap call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGELIST_TYPE){
                references = &((wxImageList_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long index0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&index0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &index0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImageList::GetBitmap((int) index0) to return new object\n\n");
                #endif

                wxBitmap value_to_return1;
                value_to_return1 = ((wxImageList_php*)native_object)->GetBitmap((int) index0);
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxBitmap));
                object_init_ex(return_value, php_wxBitmap_entry);
                ((wxBitmap_php*)ptr)->phpObj = *return_value;
                zo_wxBitmap* zo1 = Z_wxBitmap_P(return_value);
                zo1->native_object = (wxBitmap_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageList::GetBitmap\n"
        );
    }
}
/* }}} */

/* {{{ proto wxIcon wxImageList::GetIcon(int index)
   Returns the icon corresponding to the given index. */
PHP_METHOD(php_wxImageList, GetIcon)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageList::GetIcon\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageList* current_object;
    wxphp_object_type current_object_type;
    wxImageList_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageList_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageList::GetIcon call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGELIST_TYPE){
                references = &((wxImageList_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long index0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&index0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &index0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImageList::GetIcon((int) index0) to return new object\n\n");
                #endif

                wxIcon value_to_return1;
                value_to_return1 = ((wxImageList_php*)native_object)->GetIcon((int) index0);
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxIcon));
                object_init_ex(return_value, php_wxIcon_entry);
                ((wxIcon_php*)ptr)->phpObj = *return_value;
                zo_wxIcon* zo1 = Z_wxIcon_P(return_value);
                zo1->native_object = (wxIcon_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageList::GetIcon\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxImageList::GetImageCount()
   Returns the number of images in the list. */
PHP_METHOD(php_wxImageList, GetImageCount)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageList::GetImageCount\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageList* current_object;
    wxphp_object_type current_object_type;
    wxImageList_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageList_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageList::GetImageCount call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGELIST_TYPE){
                references = &((wxImageList_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxImageList::GetImageCount())\n\n");
                #endif

                RETVAL_LONG(((wxImageList_php*)native_object)->GetImageCount());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageList::GetImageCount\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxImageList::GetSize(int index, int &width, int &height)
   Retrieves the size of the images in the list. */
PHP_METHOD(php_wxImageList, GetSize)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageList::GetSize\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageList* current_object;
    wxphp_object_type current_object_type;
    wxImageList_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageList_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageList::GetSize call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGELIST_TYPE){
                references = &((wxImageList_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long index0;
    long width0;
    zval width0_ref;
    long height0;
    zval height0_ref;
    bool overload0_called = false;

    //Parameters for overload 1
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'lll' (&index0, &width0, &height0)\n");
        #endif

        char parse_parameters_string[] = "lll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &index0, &width0, &height0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;

            char parse_references_string[] = "zzz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, width0_ref, height0_ref );
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload1_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImageList::GetSize((int) index0, (int&) width0, (int&) height0))\n\n");
                #endif

                RETVAL_BOOL(((wxImageList_php*)native_object)->GetSize((int) index0, (int&) width0, (int&) height0));

                ZVAL_LONG(&width0_ref, width0);
                ZVAL_LONG(&height0_ref, height0);

                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxImageList::GetSize() to return new object\n\n");
                #endif

                wxSize value_to_return0;
                value_to_return0 = ((wxImageList_php*)native_object)->GetSize();
                void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxSize));
                object_init_ex(return_value, php_wxSize_entry);
                ((wxSize_php*)ptr)->phpObj = *return_value;
                zo_wxSize* zo0 = Z_wxSize_P(return_value);
                zo0->native_object = (wxSize_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageList::GetSize\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxImageList::Remove(int index)
   Removes the image at the given position. */
PHP_METHOD(php_wxImageList, Remove)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageList::Remove\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageList* current_object;
    wxphp_object_type current_object_type;
    wxImageList_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageList_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageList::Remove call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGELIST_TYPE){
                references = &((wxImageList_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long index0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&index0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &index0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImageList::Remove((int) index0))\n\n");
                #endif

                RETVAL_BOOL(((wxImageList_php*)native_object)->Remove((int) index0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageList::Remove\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxImageList::RemoveAll()
   Removes all the images in the list. */
PHP_METHOD(php_wxImageList, RemoveAll)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageList::RemoveAll\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageList* current_object;
    wxphp_object_type current_object_type;
    wxImageList_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageList_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageList::RemoveAll call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGELIST_TYPE){
                references = &((wxImageList_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImageList::RemoveAll())\n\n");
                #endif

                RETVAL_BOOL(((wxImageList_php*)native_object)->RemoveAll());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageList::RemoveAll\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxImageList::Replace(int index, wxBitmap bitmap, wxBitmap mask)
   Replaces the existing image with the new image. */
PHP_METHOD(php_wxImageList, Replace)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageList::Replace\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageList* current_object;
    wxphp_object_type current_object_type;
    wxImageList_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageList_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageList::Replace call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGELIST_TYPE){
                references = &((wxImageList_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long index0;
    zval* bitmap0;
    wxBitmap* object_pointer0_1 = 0;
    zval* mask0;
    wxBitmap* object_pointer0_2 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'lO|O' (&index0, &bitmap0, php_wxBitmap_entry, &mask0, php_wxBitmap_entry)\n");
        #endif

        char parse_parameters_string[] = "lO|O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &index0, &bitmap0, php_wxBitmap_entry, &mask0, php_wxBitmap_entry ) == SUCCESS)
        {
            if(arguments_received >= 2){
                if(Z_TYPE_P(bitmap0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap0)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap0)->native_object;
                    object_pointer0_1 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_1 )
                    {
                        zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(bitmap0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 3){
                if(Z_TYPE_P(mask0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(mask0)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(mask0)->native_object;
                    object_pointer0_2 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_2 )
                    {
                        zend_error(E_ERROR, "Parameter 'mask' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(mask0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'mask' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImageList::Replace((int) index0, *(wxBitmap*) object_pointer0_1))\n\n");
                #endif

                RETVAL_BOOL(((wxImageList_php*)native_object)->Replace((int) index0, *(wxBitmap*) object_pointer0_1));

                references->AddReference(bitmap0, "wxImageList::Replace at call 3 with 2 argument(s)");

                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImageList::Replace((int) index0, *(wxBitmap*) object_pointer0_1, *(wxBitmap*) object_pointer0_2))\n\n");
                #endif

                RETVAL_BOOL(((wxImageList_php*)native_object)->Replace((int) index0, *(wxBitmap*) object_pointer0_1, *(wxBitmap*) object_pointer0_2));

                references->AddReference(bitmap0, "wxImageList::Replace at call 3 with 3 argument(s)");
                references->AddReference(mask0, "wxImageList::Replace at call 3 with 3 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageList::Replace\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxImageList::wxImageList()
   Default ctor. */
PHP_METHOD(php_wxImageList, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageList::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageList* current_object;
    wxImageList_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    long width1;
    long height1;
    bool mask1;
    long initialCount1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 2  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll|bl' (&width1, &height1, &mask1, &initialCount1)\n");
        #endif

        char parse_parameters_string[] = "ll|bl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &width1, &height1, &mask1, &initialCount1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxImageList_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) width1, (int) height1)\n");
                #endif

                native_object = new wxImageList_php((int) width1, (int) height1);

                native_object->references.Initialize();
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) width1, (int) height1, mask1)\n");
                #endif

                native_object = new wxImageList_php((int) width1, (int) height1, mask1);

                native_object->references.Initialize();
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) width1, (int) height1, mask1, (int) initialCount1)\n");
                #endif

                native_object = new wxImageList_php((int) width1, (int) height1, mask1, (int) initialCount1);

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxImageList_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxImageList::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto bool wxImageList::Draw(int index, wxDC &dc, int x, int y, int flags, bool solidBackground)
   Draws a specified image onto a device context. */
PHP_METHOD(php_wxImageList, Draw)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxImageList::Draw\n");
    php_printf("===========================================\n");
    #endif

    zo_wxImageList* current_object;
    wxphp_object_type current_object_type;
    wxImageList_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxImageList_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxImageList::Draw call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXIMAGELIST_TYPE){
                references = &((wxImageList_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long index0;
    zval* dc0;
    wxDC* object_pointer0_1 = 0;
    long x0;
    long y0;
    long flags0;
    bool solidBackground0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 4  && arguments_received <= 6)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'loll|lb' (&index0, &dc0, &x0, &y0, &flags0, &solidBackground0)\n");
        #endif

        char parse_parameters_string[] = "loll|lb";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &index0, &dc0, &x0, &y0, &flags0, &solidBackground0 ) == SUCCESS)
        {
            if(arguments_received >= 2){
                if(Z_TYPE_P(dc0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxDC_P(dc0)->object_type;
                    argument_native_object = (void*) Z_wxDC_P(dc0)->native_object;
                    object_pointer0_1 = (wxDC*) argument_native_object;
                    if (!object_pointer0_1 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(dc0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImageList::Draw((int) index0, *(wxDC*) object_pointer0_1, (int) x0, (int) y0))\n\n");
                #endif

                RETVAL_BOOL(((wxImageList_php*)native_object)->Draw((int) index0, *(wxDC*) object_pointer0_1, (int) x0, (int) y0));

                references->AddReference(dc0, "wxImageList::Draw at call 3 with 4 argument(s)");

                return;
                break;
            }
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImageList::Draw((int) index0, *(wxDC*) object_pointer0_1, (int) x0, (int) y0, (int) flags0))\n\n");
                #endif

                RETVAL_BOOL(((wxImageList_php*)native_object)->Draw((int) index0, *(wxDC*) object_pointer0_1, (int) x0, (int) y0, (int) flags0));

                references->AddReference(dc0, "wxImageList::Draw at call 3 with 5 argument(s)");

                return;
                break;
            }
            case 6:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxImageList::Draw((int) index0, *(wxDC*) object_pointer0_1, (int) x0, (int) y0, (int) flags0, solidBackground0))\n\n");
                #endif

                RETVAL_BOOL(((wxImageList_php*)native_object)->Draw((int) index0, *(wxDC*) object_pointer0_1, (int) x0, (int) y0, (int) flags0, solidBackground0));

                references->AddReference(dc0, "wxImageList::Draw at call 3 with 6 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxImageList::Draw\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxPalette_free(void *object)
{
    zo_wxPalette* custom_object = (zo_wxPalette*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxPalette_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxPalette done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxPalette_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxPalette_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxPalette* custom_object;

    custom_object = (zo_wxPalette*) ecalloc(
        1,
        sizeof(zo_wxPalette)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxPalette_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXPALETTE_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxPalette::wxPalette()
   Default constructor. */
PHP_METHOD(php_wxPalette, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPalette::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPalette* current_object;
    wxPalette_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    zval* palette1;
    wxPalette* object_pointer1_0 = 0;
    bool overload1_called = false;

    //Parameters for overload 2
    long n2;
    zval* red2;
    zval* green2;
    zval* blue2;
    bool overload2_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&palette1, php_wxPalette_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &palette1, php_wxPalette_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(palette1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPalette_P(palette1)->object_type;
                    argument_native_object = (void*) Z_wxPalette_P(palette1)->native_object;
                    object_pointer1_0 = (wxPalette*) argument_native_object;
                    if (!object_pointer1_0 )
                    {
                        goto overload2;
                    }
                }
                else if(Z_TYPE_P(palette1) != IS_NULL)
                {
                    goto overload2;
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'laaa' (&n2, &red2, &green2, &blue2)\n");
        #endif

        char parse_parameters_string[] = "laaa";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &n2, &red2, &green2, &blue2 ) == SUCCESS)
        {
            overload2_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxPalette_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxPalette*) object_pointer1_0)\n");
                #endif

                native_object = new wxPalette_php(*(wxPalette*) object_pointer1_0);

                native_object->references.Initialize();
                ((wxPalette_php*) native_object)->references.AddReference(palette1, "wxPalette::wxPalette at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    if(overload2_called)
    {
        int array_count2_1 = 1;
        HashTable* arr_hash2_1;
        if(arguments_received > 1)
        {
            arr_hash2_1 = Z_ARRVAL_P(red2);
            array_count2_1 = zend_hash_num_elements(arr_hash2_1);
        }
        unsigned char* integers_array2_1 = new unsigned char[array_count2_1];
        bool integers_continue2_1 = true;

        int array_count2_2 = 1;
        HashTable* arr_hash2_2;
        if(arguments_received > 2)
        {
            arr_hash2_2 = Z_ARRVAL_P(green2);
            array_count2_2 = zend_hash_num_elements(arr_hash2_2);
        }
        unsigned char* integers_array2_2 = new unsigned char[array_count2_2];
        bool integers_continue2_2 = true;

        int array_count2_3 = 1;
        HashTable* arr_hash2_3;
        if(arguments_received > 3)
        {
            arr_hash2_3 = Z_ARRVAL_P(blue2);
            array_count2_3 = zend_hash_num_elements(arr_hash2_3);
        }
        unsigned char* integers_array2_3 = new unsigned char[array_count2_3];
        bool integers_continue2_3 = true;

        switch(arguments_received)
        {
            case 4:
            {
                int array_index2_1 = 0;
                zval* temp_array_value2_1 = 0;
                while(integers_continue2_1)
                {
                    if((temp_array_value2_1 = zend_hash_index_find(HASH_OF(red2), array_index2_1)) != NULL)
                    {
                        convert_to_long_ex(temp_array_value2_1);
                        integers_array2_1[array_index2_1] = (unsigned char) Z_LVAL_P(temp_array_value2_1);
                        array_index2_1++;
                    }
                    else
                    {
                        integers_continue2_1 = false;
                    }
                }
                int array_index2_2 = 0;
                zval* temp_array_value2_2 = 0;
                while(integers_continue2_2)
                {
                    if((temp_array_value2_2 = zend_hash_index_find(HASH_OF(green2), array_index2_2)) != NULL)
                    {
                        convert_to_long_ex(temp_array_value2_2);
                        integers_array2_2[array_index2_2] = (unsigned char) Z_LVAL_P(temp_array_value2_2);
                        array_index2_2++;
                    }
                    else
                    {
                        integers_continue2_2 = false;
                    }
                }
                int array_index2_3 = 0;
                zval* temp_array_value2_3 = 0;
                while(integers_continue2_3)
                {
                    if((temp_array_value2_3 = zend_hash_index_find(HASH_OF(blue2), array_index2_3)) != NULL)
                    {
                        convert_to_long_ex(temp_array_value2_3);
                        integers_array2_3[array_index2_3] = (unsigned char) Z_LVAL_P(temp_array_value2_3);
                        array_index2_3++;
                    }
                    else
                    {
                        integers_continue2_3 = false;
                    }
                }
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) n2, (const unsigned char*) integers_array2_1, (const unsigned char*) integers_array2_2, (const unsigned char*) integers_array2_3)\n");
                #endif

                native_object = new wxPalette_php((int) n2, (const unsigned char*) integers_array2_1, (const unsigned char*) integers_array2_2, (const unsigned char*) integers_array2_3);

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxPalette_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxPalette::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto bool wxPalette::IsOk()
   Returns true if palette data is present. */
PHP_METHOD(php_wxPalette, IsOk)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPalette::IsOk\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPalette* current_object;
    wxphp_object_type current_object_type;
    wxPalette_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPalette_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPalette::IsOk call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPALETTE_TYPE){
                references = &((wxPalette_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxPalette::IsOk())\n\n");
                #endif

                RETVAL_BOOL(((wxPalette_php*)native_object)->IsOk());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPalette::IsOk\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxPalette::GetPixel(int red, int green, int blue)
   Returns a pixel value (index into the palette) for the given RGB values. */
PHP_METHOD(php_wxPalette, GetPixel)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPalette::GetPixel\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPalette* current_object;
    wxphp_object_type current_object_type;
    wxPalette_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPalette_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPalette::GetPixel call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPALETTE_TYPE){
                references = &((wxPalette_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long red0;
    long green0;
    long blue0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'lll' (&red0, &green0, &blue0)\n");
        #endif

        char parse_parameters_string[] = "lll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &red0, &green0, &blue0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPalette::GetPixel((unsigned char) red0, (unsigned char) green0, (unsigned char) blue0))\n\n");
                #endif

                RETVAL_LONG(((wxPalette_php*)native_object)->GetPixel((unsigned char) red0, (unsigned char) green0, (unsigned char) blue0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPalette::GetPixel\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxPalette::GetColoursCount()
   Returns number of entries in palette. */
PHP_METHOD(php_wxPalette, GetColoursCount)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPalette::GetColoursCount\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPalette* current_object;
    wxphp_object_type current_object_type;
    wxPalette_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPalette_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPalette::GetColoursCount call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPALETTE_TYPE){
                references = &((wxPalette_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPalette::GetColoursCount())\n\n");
                #endif

                RETVAL_LONG(((wxPalette_php*)native_object)->GetColoursCount());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPalette::GetColoursCount\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxPalette::Create(int n, array red, array green, array blue)
   Creates a palette from arrays of size n, one for each red, blue or green component. */
PHP_METHOD(php_wxPalette, Create)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPalette::Create\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPalette* current_object;
    wxphp_object_type current_object_type;
    wxPalette_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPalette_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPalette::Create call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPALETTE_TYPE){
                references = &((wxPalette_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long n0;
    zval* red0;
    zval* green0;
    zval* blue0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'laaa' (&n0, &red0, &green0, &blue0)\n");
        #endif

        char parse_parameters_string[] = "laaa";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &n0, &red0, &green0, &blue0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        int array_count0_1 = 1;
        HashTable* arr_hash0_1;
        if(arguments_received > 1)
        {
            arr_hash0_1 = Z_ARRVAL_P(red0);
            array_count0_1 = zend_hash_num_elements(arr_hash0_1);
        }
        unsigned char* integers_array0_1 = new unsigned char[array_count0_1];
        bool integers_continue0_1 = true;

        int array_count0_2 = 1;
        HashTable* arr_hash0_2;
        if(arguments_received > 2)
        {
            arr_hash0_2 = Z_ARRVAL_P(green0);
            array_count0_2 = zend_hash_num_elements(arr_hash0_2);
        }
        unsigned char* integers_array0_2 = new unsigned char[array_count0_2];
        bool integers_continue0_2 = true;

        int array_count0_3 = 1;
        HashTable* arr_hash0_3;
        if(arguments_received > 3)
        {
            arr_hash0_3 = Z_ARRVAL_P(blue0);
            array_count0_3 = zend_hash_num_elements(arr_hash0_3);
        }
        unsigned char* integers_array0_3 = new unsigned char[array_count0_3];
        bool integers_continue0_3 = true;

        switch(arguments_received)
        {
            case 4:
            {
                int array_index0_1 = 0;
                zval* temp_array_value0_1 = 0;
                while(integers_continue0_1)
                {
                    if((temp_array_value0_1 = zend_hash_index_find(HASH_OF(red0), array_index0_1)) != NULL)
                    {
                        convert_to_long_ex(temp_array_value0_1);
                        integers_array0_1[array_index0_1] = (unsigned char) Z_LVAL_P(temp_array_value0_1);
                        array_index0_1++;
                    }
                    else
                    {
                        integers_continue0_1 = false;
                    }
                }
                int array_index0_2 = 0;
                zval* temp_array_value0_2 = 0;
                while(integers_continue0_2)
                {
                    if((temp_array_value0_2 = zend_hash_index_find(HASH_OF(green0), array_index0_2)) != NULL)
                    {
                        convert_to_long_ex(temp_array_value0_2);
                        integers_array0_2[array_index0_2] = (unsigned char) Z_LVAL_P(temp_array_value0_2);
                        array_index0_2++;
                    }
                    else
                    {
                        integers_continue0_2 = false;
                    }
                }
                int array_index0_3 = 0;
                zval* temp_array_value0_3 = 0;
                while(integers_continue0_3)
                {
                    if((temp_array_value0_3 = zend_hash_index_find(HASH_OF(blue0), array_index0_3)) != NULL)
                    {
                        convert_to_long_ex(temp_array_value0_3);
                        integers_array0_3[array_index0_3] = (unsigned char) Z_LVAL_P(temp_array_value0_3);
                        array_index0_3++;
                    }
                    else
                    {
                        integers_continue0_3 = false;
                    }
                }
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxPalette::Create((int) n0, (const unsigned char*) integers_array0_1, (const unsigned char*) integers_array0_2, (const unsigned char*) integers_array0_3))\n\n");
                #endif

                RETVAL_BOOL(((wxPalette_php*)native_object)->Create((int) n0, (const unsigned char*) integers_array0_1, (const unsigned char*) integers_array0_2, (const unsigned char*) integers_array0_3));

                delete[] integers_array0_1;
                delete[] integers_array0_2;
                delete[] integers_array0_3;

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPalette::Create\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxPalette::GetRGB(int pixel, int &red, int &green, int &blue)
   Returns RGB values for a given palette index. */
PHP_METHOD(php_wxPalette, GetRGB)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPalette::GetRGB\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPalette* current_object;
    wxphp_object_type current_object_type;
    wxPalette_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPalette_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPalette::GetRGB call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPALETTE_TYPE){
                references = &((wxPalette_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long pixel0;
    long* red0;
    zval red0_ref;
    long* green0;
    zval green0_ref;
    long* blue0;
    zval blue0_ref;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'llll' (&pixel0, red0, green0, blue0)\n");
        #endif

        char parse_parameters_string[] = "llll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pixel0, red0, green0, blue0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;

            char parse_references_string[] = "zzzz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, red0_ref, green0_ref, blue0_ref );
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxPalette::GetRGB((int) pixel0, (unsigned char*) red0, (unsigned char*) green0, (unsigned char*) blue0))\n\n");
                #endif

                RETVAL_BOOL(((wxPalette_php*)native_object)->GetRGB((int) pixel0, (unsigned char*) red0, (unsigned char*) green0, (unsigned char*) blue0));

                size_t elements_returned0_1 = sizeof(red0)/sizeof(*red0);
                array_init(&red0_ref);
                for(size_t i=0; i<elements_returned0_1; i++)
                {
                    add_next_index_long(&red0_ref, red0[i]);
                }
                size_t elements_returned0_2 = sizeof(green0)/sizeof(*green0);
                array_init(&green0_ref);
                for(size_t i=0; i<elements_returned0_2; i++)
                {
                    add_next_index_long(&green0_ref, green0[i]);
                }
                size_t elements_returned0_3 = sizeof(blue0)/sizeof(*blue0);
                array_init(&blue0_ref);
                for(size_t i=0; i<elements_returned0_3; i++)
                {
                    add_next_index_long(&blue0_ref, blue0[i]);
                }

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPalette::GetRGB\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxPen_free(void *object)
{
    zo_wxPen* custom_object = (zo_wxPen*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxPen_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxPen done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxPen_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxPen_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxPen* custom_object;

    custom_object = (zo_wxPen*) ecalloc(
        1,
        sizeof(zo_wxPen)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxPen_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXPEN_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxPen::wxPen()
   Default constructor. */
PHP_METHOD(php_wxPen, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPen::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPen* current_object;
    wxPen_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    zval* colour1;
    wxColour* object_pointer1_0 = 0;
    long width1;
    long style1;
    bool overload1_called = false;

    //Parameters for overload 2
    zval* pen2;
    wxPen* object_pointer2_0 = 0;
    bool overload2_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 1  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O|ll' (&colour1, php_wxColour_entry, &width1, &style1)\n");
        #endif

        char parse_parameters_string[] = "O|ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &colour1, php_wxColour_entry, &width1, &style1 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(colour1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxColour_P(colour1)->object_type;
                    argument_native_object = (void*) Z_wxColour_P(colour1)->native_object;
                    object_pointer1_0 = (wxColour*) argument_native_object;
                    if (!object_pointer1_0 )
                    {
                        goto overload2;
                    }
                }
                else if(Z_TYPE_P(colour1) != IS_NULL)
                {
                    goto overload2;
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&pen2, php_wxPen_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pen2, php_wxPen_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(pen2) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPen_P(pen2)->object_type;
                    argument_native_object = (void*) Z_wxPen_P(pen2)->native_object;
                    object_pointer2_0 = (wxPen*) argument_native_object;
                    if (!object_pointer2_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'pen' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(pen2) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'pen' not null, could not be retreived correctly.");
                }
            }

            overload2_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxPen_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxColour*) object_pointer1_0)\n");
                #endif

                native_object = new wxPen_php(*(wxColour*) object_pointer1_0);

                native_object->references.Initialize();
                ((wxPen_php*) native_object)->references.AddReference(colour1, "wxPen::wxPen at call 4 with 1 argument(s)");
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxColour*) object_pointer1_0, (int) width1)\n");
                #endif

                native_object = new wxPen_php(*(wxColour*) object_pointer1_0, (int) width1);

                native_object->references.Initialize();
                ((wxPen_php*) native_object)->references.AddReference(colour1, "wxPen::wxPen at call 4 with 2 argument(s)");
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxColour*) object_pointer1_0, (int) width1, (wxPenStyle) style1)\n");
                #endif

                native_object = new wxPen_php(*(wxColour*) object_pointer1_0, (int) width1, (wxPenStyle) style1);

                native_object->references.Initialize();
                ((wxPen_php*) native_object)->references.AddReference(colour1, "wxPen::wxPen at call 4 with 3 argument(s)");
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxPen*) object_pointer2_0)\n");
                #endif

                native_object = new wxPen_php(*(wxPen*) object_pointer2_0);

                native_object->references.Initialize();
                ((wxPen_php*) native_object)->references.AddReference(pen2, "wxPen::wxPen at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxPen_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxPen::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto bool wxPen::IsTransparent()
   Returns true if the pen is transparent. */
PHP_METHOD(php_wxPen, IsTransparent)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPen::IsTransparent\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPen* current_object;
    wxphp_object_type current_object_type;
    wxPen_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPen_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPen::IsTransparent call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPEN_TYPE){
                references = &((wxPen_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxPen::IsTransparent())\n\n");
                #endif

                RETVAL_BOOL(((wxPen_php*)native_object)->IsTransparent());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPen::IsTransparent\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxPen::IsOk()
   Returns true if the pen is initialised. */
PHP_METHOD(php_wxPen, IsOk)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPen::IsOk\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPen* current_object;
    wxphp_object_type current_object_type;
    wxPen_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPen_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPen::IsOk call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPEN_TYPE){
                references = &((wxPen_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxPen::IsOk())\n\n");
                #endif

                RETVAL_BOOL(((wxPen_php*)native_object)->IsOk());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPen::IsOk\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxPen::IsNonTransparent()
   Returns true if the pen is a valid non-transparent pen. */
PHP_METHOD(php_wxPen, IsNonTransparent)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPen::IsNonTransparent\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPen* current_object;
    wxphp_object_type current_object_type;
    wxPen_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPen_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPen::IsNonTransparent call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPEN_TYPE){
                references = &((wxPen_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxPen::IsNonTransparent())\n\n");
                #endif

                RETVAL_BOOL(((wxPen_php*)native_object)->IsNonTransparent());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPen::IsNonTransparent\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxPen::GetWidth()
   Returns the pen width. */
PHP_METHOD(php_wxPen, GetWidth)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPen::GetWidth\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPen* current_object;
    wxphp_object_type current_object_type;
    wxPen_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPen_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPen::GetWidth call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPEN_TYPE){
                references = &((wxPen_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPen::GetWidth())\n\n");
                #endif

                RETVAL_LONG(((wxPen_php*)native_object)->GetWidth());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPen::GetWidth\n"
        );
    }
}
/* }}} */

/* {{{ proto wxPenStyle wxPen::GetStyle()
   Returns the pen style. */
PHP_METHOD(php_wxPen, GetStyle)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPen::GetStyle\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPen* current_object;
    wxphp_object_type current_object_type;
    wxPen_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPen_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPen::GetStyle call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPEN_TYPE){
                references = &((wxPen_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPen::GetStyle())\n\n");
                #endif

                RETVAL_LONG(((wxPen_php*)native_object)->GetStyle());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPen::GetStyle\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmap wxPen::GetStipple()
   Gets a pointer to the stipple bitmap. */
PHP_METHOD(php_wxPen, GetStipple)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPen::GetStipple\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPen* current_object;
    wxphp_object_type current_object_type;
    wxPen_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPen_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPen::GetStipple call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPEN_TYPE){
                references = &((wxPen_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPen::GetStipple() to return object pointer\n\n");
                #endif

                wxBitmap_php* value_to_return0;
                value_to_return0 = (wxBitmap_php*) ((wxPen_php*)native_object)->GetStipple();

                if(value_to_return0 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxBitmap_entry);
                    Z_wxBitmap_P(return_value)->native_object = (wxBitmap_php*) value_to_return0;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxPen::GetStipple at call 5 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPen::GetStipple\n"
        );
    }
}
/* }}} */

/* {{{ proto wxPenJoin wxPen::GetJoin()
   Returns the pen join style, which may be one of wxJOIN_BEVEL, wxJOIN_ROUND and wxJOIN_MITER. */
PHP_METHOD(php_wxPen, GetJoin)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPen::GetJoin\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPen* current_object;
    wxphp_object_type current_object_type;
    wxPen_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPen_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPen::GetJoin call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPEN_TYPE){
                references = &((wxPen_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPen::GetJoin())\n\n");
                #endif

                RETVAL_LONG(((wxPen_php*)native_object)->GetJoin());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPen::GetJoin\n"
        );
    }
}
/* }}} */

/* {{{ proto wxColour wxPen::GetColour()
   Returns a reference to the pen colour. */
PHP_METHOD(php_wxPen, GetColour)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPen::GetColour\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPen* current_object;
    wxphp_object_type current_object_type;
    wxPen_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPen_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPen::GetColour call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPEN_TYPE){
                references = &((wxPen_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPen::GetColour() to return new object\n\n");
                #endif

                wxColour value_to_return0;
                value_to_return0 = ((wxPen_php*)native_object)->GetColour();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxColour));
                object_init_ex(return_value, php_wxColour_entry);
                ((wxColour_php*)ptr)->phpObj = *return_value;
                zo_wxColour* zo0 = Z_wxColour_P(return_value);
                zo0->native_object = (wxColour_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPen::GetColour\n"
        );
    }
}
/* }}} */

/* {{{ proto wxPenCap wxPen::GetCap()
   Returns the pen cap style, which may be one of wxCAP_ROUND, wxCAP_PROJECTING and wxCAP_BUTT. */
PHP_METHOD(php_wxPen, GetCap)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPen::GetCap\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPen* current_object;
    wxphp_object_type current_object_type;
    wxPen_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPen_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPen::GetCap call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPEN_TYPE){
                references = &((wxPen_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPen::GetCap())\n\n");
                #endif

                RETVAL_LONG(((wxPen_php*)native_object)->GetCap());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPen::GetCap\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPen::SetColour(wxColour &colour)
   The pen's colour is changed to the given colour. */
PHP_METHOD(php_wxPen, SetColour)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPen::SetColour\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPen* current_object;
    wxphp_object_type current_object_type;
    wxPen_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPen_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPen::SetColour call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPEN_TYPE){
                references = &((wxPen_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* colour0;
    wxColour* object_pointer0_0 = 0;
    bool overload0_called = false;

    //Parameters for overload 1
    long red1;
    long green1;
    long blue1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&colour0, php_wxColour_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &colour0, php_wxColour_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(colour0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxColour_P(colour0)->object_type;
                    argument_native_object = (void*) Z_wxColour_P(colour0)->native_object;
                    object_pointer0_0 = (wxColour*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        goto overload1;
                    }
                }
                else if(Z_TYPE_P(colour0) != IS_NULL)
                {
                    goto overload1;
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'lll' (&red1, &green1, &blue1)\n");
        #endif

        char parse_parameters_string[] = "lll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &red1, &green1, &blue1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPen::SetColour(*(wxColour*) object_pointer0_0)\n\n");
                #endif

                ((wxPen_php*)native_object)->SetColour(*(wxColour*) object_pointer0_0);

                references->AddReference(colour0, "wxPen::SetColour at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPen::SetColour((unsigned char) red1, (unsigned char) green1, (unsigned char) blue1)\n\n");
                #endif

                ((wxPen_php*)native_object)->SetColour((unsigned char) red1, (unsigned char) green1, (unsigned char) blue1);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPen::SetColour\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPen::SetJoin(wxPenJoin join_style)
   Sets the pen join style, which may be one of wxJOIN_BEVEL, wxJOIN_ROUND and wxJOIN_MITER. */
PHP_METHOD(php_wxPen, SetJoin)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPen::SetJoin\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPen* current_object;
    wxphp_object_type current_object_type;
    wxPen_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPen_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPen::SetJoin call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPEN_TYPE){
                references = &((wxPen_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long join_style0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&join_style0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &join_style0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPen::SetJoin((wxPenJoin) join_style0)\n\n");
                #endif

                ((wxPen_php*)native_object)->SetJoin((wxPenJoin) join_style0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPen::SetJoin\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPen::SetStipple(wxBitmap stipple)
   Sets the bitmap for stippling. */
PHP_METHOD(php_wxPen, SetStipple)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPen::SetStipple\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPen* current_object;
    wxphp_object_type current_object_type;
    wxPen_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPen_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPen::SetStipple call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPEN_TYPE){
                references = &((wxPen_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* stipple0;
    wxBitmap* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&stipple0, php_wxBitmap_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &stipple0, php_wxBitmap_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(stipple0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(stipple0)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(stipple0)->native_object;
                    object_pointer0_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'stipple' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(stipple0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'stipple' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPen::SetStipple(*(wxBitmap*) object_pointer0_0)\n\n");
                #endif

                ((wxPen_php*)native_object)->SetStipple(*(wxBitmap*) object_pointer0_0);

                references->AddReference(stipple0, "wxPen::SetStipple at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPen::SetStipple\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPen::SetStyle(wxPenStyle style)
   Set the pen style. */
PHP_METHOD(php_wxPen, SetStyle)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPen::SetStyle\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPen* current_object;
    wxphp_object_type current_object_type;
    wxPen_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPen_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPen::SetStyle call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPEN_TYPE){
                references = &((wxPen_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long style0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&style0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &style0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPen::SetStyle((wxPenStyle) style0)\n\n");
                #endif

                ((wxPen_php*)native_object)->SetStyle((wxPenStyle) style0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPen::SetStyle\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPen::SetWidth(int width)
   Sets the pen width. */
PHP_METHOD(php_wxPen, SetWidth)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPen::SetWidth\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPen* current_object;
    wxphp_object_type current_object_type;
    wxPen_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPen_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPen::SetWidth call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPEN_TYPE){
                references = &((wxPen_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long width0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&width0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &width0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPen::SetWidth((int) width0)\n\n");
                #endif

                ((wxPen_php*)native_object)->SetWidth((int) width0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPen::SetWidth\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPen::SetCap(wxPenCap capStyle)
   Sets the pen cap style, which may be one of wxCAP_ROUND, wxCAP_PROJECTING and wxCAP_BUTT. */
PHP_METHOD(php_wxPen, SetCap)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPen::SetCap\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPen* current_object;
    wxphp_object_type current_object_type;
    wxPen_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPen_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPen::SetCap call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPEN_TYPE){
                references = &((wxPen_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long capStyle0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&capStyle0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &capStyle0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPen::SetCap((wxPenCap) capStyle0)\n\n");
                #endif

                ((wxPen_php*)native_object)->SetCap((wxPenCap) capStyle0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPen::SetCap\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxPenList_free(void *object)
{
    zo_wxPenList* custom_object = (zo_wxPenList*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxPenList_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxPenList done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxPenList_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxPenList_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxPenList* custom_object;

    custom_object = (zo_wxPenList*) ecalloc(
        1,
        sizeof(zo_wxPenList)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxPenList_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXPENLIST_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto wxPen wxPenList::FindOrCreatePen(wxColour colour, int width, wxPenStyle style)
   Finds a pen with the specified attributes and returns it, else creates a new pen, adds it to the pen list, and returns it. */
PHP_METHOD(php_wxPenList, FindOrCreatePen)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPenList::FindOrCreatePen\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPenList* current_object;
    wxphp_object_type current_object_type;
    wxPenList_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPenList_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPenList::FindOrCreatePen call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPENLIST_TYPE){
                references = &((wxPenList_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* colour0;
    wxColour* object_pointer0_0 = 0;
    long width0;
    long style0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O|ll' (&colour0, php_wxColour_entry, &width0, &style0)\n");
        #endif

        char parse_parameters_string[] = "O|ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &colour0, php_wxColour_entry, &width0, &style0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(colour0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxColour_P(colour0)->object_type;
                    argument_native_object = (void*) Z_wxColour_P(colour0)->native_object;
                    object_pointer0_0 = (wxColour*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'colour' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(colour0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'colour' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPenList::FindOrCreatePen(*(wxColour*) object_pointer0_0) to return object pointer\n\n");
                #endif

                wxPen_php* value_to_return1;
                value_to_return1 = (wxPen_php*) ((wxPenList_php*)native_object)->FindOrCreatePen(*(wxColour*) object_pointer0_0);

                if(value_to_return1 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return1->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return1->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return1->phpObj);
                        zval_add_ref(&value_to_return1->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxPen_entry);
                    Z_wxPen_P(return_value)->native_object = (wxPen_php*) value_to_return1;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return1 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxPenList::FindOrCreatePen at call 5 with 1 argument(s)");
                }

                references->AddReference(colour0, "wxPenList::FindOrCreatePen at call 3 with 1 argument(s)");

                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPenList::FindOrCreatePen(*(wxColour*) object_pointer0_0, (int) width0) to return object pointer\n\n");
                #endif

                wxPen_php* value_to_return2;
                value_to_return2 = (wxPen_php*) ((wxPenList_php*)native_object)->FindOrCreatePen(*(wxColour*) object_pointer0_0, (int) width0);

                if(value_to_return2 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return2->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return2->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return2->phpObj);
                        zval_add_ref(&value_to_return2->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxPen_entry);
                    Z_wxPen_P(return_value)->native_object = (wxPen_php*) value_to_return2;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return2 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxPenList::FindOrCreatePen at call 5 with 2 argument(s)");
                }

                references->AddReference(colour0, "wxPenList::FindOrCreatePen at call 3 with 2 argument(s)");

                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPenList::FindOrCreatePen(*(wxColour*) object_pointer0_0, (int) width0, (wxPenStyle) style0) to return object pointer\n\n");
                #endif

                wxPen_php* value_to_return3;
                value_to_return3 = (wxPen_php*) ((wxPenList_php*)native_object)->FindOrCreatePen(*(wxColour*) object_pointer0_0, (int) width0, (wxPenStyle) style0);

                if(value_to_return3 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return3->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return3->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return3->phpObj);
                        zval_add_ref(&value_to_return3->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxPen_entry);
                    Z_wxPen_P(return_value)->native_object = (wxPen_php*) value_to_return3;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return3 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxPenList::FindOrCreatePen at call 5 with 3 argument(s)");
                }

                references->AddReference(colour0, "wxPenList::FindOrCreatePen at call 3 with 3 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPenList::FindOrCreatePen\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPenList::wxPenList()
   Constructor. */
PHP_METHOD(php_wxPenList, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPenList::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPenList* current_object;
    wxPenList_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxPenList_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxPenList_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxPenList::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxRendererNative_free(void *object)
{
    zo_wxRendererNative* custom_object = (zo_wxRendererNative*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxRendererNative_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxRendererNative done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxRendererNative_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxRendererNative_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxRendererNative* custom_object;

    custom_object = (zo_wxRendererNative*) ecalloc(
        1,
        sizeof(zo_wxRendererNative)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxRendererNative_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXRENDERERNATIVE_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxRendererNative::DrawCheckBox(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw a check box. */
void wxRendererNative_php::DrawCheckBox(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxRendererNative::DrawCheckBox\n");
    php_printf("===========================================\n");
    #endif

    zval* params[4];
    zval arguments[4];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "DrawCheckBox");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    object_init_ex(&arguments[0], php_wxWindow_entry);
    Z_wxWindow_P(&arguments[0])->native_object = (wxWindow_php*) &win;
    object_init_ex(&arguments[1], php_wxDC_entry);
    Z_wxDC_P(&arguments[1])->native_object = (wxDC_php*) &dc;
    object_init_ex(&arguments[2], php_wxRect_entry);
    Z_wxRect_P(&arguments[2])->native_object = (wxRect_php*) &rect;
    ZVAL_LONG(&arguments[3], flags);
    
    for(int i=0; i<4; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "DrawCheckBox");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "DrawCheckBox",
            12,
            &function_return_value,
            4,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<4; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxRendererNative::DrawCheckBox'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return;

}
/* }}} */

/* {{{ proto  wxRendererNative::DrawChoice(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw a native wxChoice. */
void wxRendererNative_php::DrawChoice(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxRendererNative::DrawChoice\n");
    php_printf("===========================================\n");
    #endif

    zval* params[4];
    zval arguments[4];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "DrawChoice");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    object_init_ex(&arguments[0], php_wxWindow_entry);
    Z_wxWindow_P(&arguments[0])->native_object = (wxWindow_php*) &win;
    object_init_ex(&arguments[1], php_wxDC_entry);
    Z_wxDC_P(&arguments[1])->native_object = (wxDC_php*) &dc;
    object_init_ex(&arguments[2], php_wxRect_entry);
    Z_wxRect_P(&arguments[2])->native_object = (wxRect_php*) &rect;
    ZVAL_LONG(&arguments[3], flags);
    
    for(int i=0; i<4; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "DrawChoice");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "DrawChoice",
            10,
            &function_return_value,
            4,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<4; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxRendererNative::DrawChoice'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return;

}
/* }}} */

/* {{{ proto  wxRendererNative::DrawComboBox(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw a native wxComboBox. */
void wxRendererNative_php::DrawComboBox(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxRendererNative::DrawComboBox\n");
    php_printf("===========================================\n");
    #endif

    zval* params[4];
    zval arguments[4];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "DrawComboBox");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    object_init_ex(&arguments[0], php_wxWindow_entry);
    Z_wxWindow_P(&arguments[0])->native_object = (wxWindow_php*) &win;
    object_init_ex(&arguments[1], php_wxDC_entry);
    Z_wxDC_P(&arguments[1])->native_object = (wxDC_php*) &dc;
    object_init_ex(&arguments[2], php_wxRect_entry);
    Z_wxRect_P(&arguments[2])->native_object = (wxRect_php*) &rect;
    ZVAL_LONG(&arguments[3], flags);
    
    for(int i=0; i<4; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "DrawComboBox");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "DrawComboBox",
            12,
            &function_return_value,
            4,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<4; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxRendererNative::DrawComboBox'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return;

}
/* }}} */

/* {{{ proto  wxRendererNative::DrawComboBoxDropButton(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw a button like the one used by wxComboBox to show a drop down window. */
void wxRendererNative_php::DrawComboBoxDropButton(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxRendererNative::DrawComboBoxDropButton\n");
    php_printf("===========================================\n");
    #endif

    zval* params[4];
    zval arguments[4];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "DrawComboBoxDropButton");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    object_init_ex(&arguments[0], php_wxWindow_entry);
    Z_wxWindow_P(&arguments[0])->native_object = (wxWindow_php*) &win;
    object_init_ex(&arguments[1], php_wxDC_entry);
    Z_wxDC_P(&arguments[1])->native_object = (wxDC_php*) &dc;
    object_init_ex(&arguments[2], php_wxRect_entry);
    Z_wxRect_P(&arguments[2])->native_object = (wxRect_php*) &rect;
    ZVAL_LONG(&arguments[3], flags);
    
    for(int i=0; i<4; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "DrawComboBoxDropButton");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "DrawComboBoxDropButton",
            22,
            &function_return_value,
            4,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<4; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxRendererNative::DrawComboBoxDropButton'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return;

}
/* }}} */

/* {{{ proto  wxRendererNative::DrawDropArrow(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw a drop down arrow that is suitable for use outside a combo box. */
void wxRendererNative_php::DrawDropArrow(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxRendererNative::DrawDropArrow\n");
    php_printf("===========================================\n");
    #endif

    zval* params[4];
    zval arguments[4];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "DrawDropArrow");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    object_init_ex(&arguments[0], php_wxWindow_entry);
    Z_wxWindow_P(&arguments[0])->native_object = (wxWindow_php*) &win;
    object_init_ex(&arguments[1], php_wxDC_entry);
    Z_wxDC_P(&arguments[1])->native_object = (wxDC_php*) &dc;
    object_init_ex(&arguments[2], php_wxRect_entry);
    Z_wxRect_P(&arguments[2])->native_object = (wxRect_php*) &rect;
    ZVAL_LONG(&arguments[3], flags);
    
    for(int i=0; i<4; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "DrawDropArrow");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "DrawDropArrow",
            13,
            &function_return_value,
            4,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<4; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxRendererNative::DrawDropArrow'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return;

}
/* }}} */

/* {{{ proto  wxRendererNative::DrawFocusRect(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw a focus rectangle using the specified rectangle. */
void wxRendererNative_php::DrawFocusRect(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxRendererNative::DrawFocusRect\n");
    php_printf("===========================================\n");
    #endif

    zval* params[4];
    zval arguments[4];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "DrawFocusRect");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    object_init_ex(&arguments[0], php_wxWindow_entry);
    Z_wxWindow_P(&arguments[0])->native_object = (wxWindow_php*) &win;
    object_init_ex(&arguments[1], php_wxDC_entry);
    Z_wxDC_P(&arguments[1])->native_object = (wxDC_php*) &dc;
    object_init_ex(&arguments[2], php_wxRect_entry);
    Z_wxRect_P(&arguments[2])->native_object = (wxRect_php*) &rect;
    ZVAL_LONG(&arguments[3], flags);
    
    for(int i=0; i<4; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "DrawFocusRect");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "DrawFocusRect",
            13,
            &function_return_value,
            4,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<4; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxRendererNative::DrawFocusRect'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return;

}
/* }}} */

/* {{{ proto  wxRendererNative::DrawPushButton(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw a blank push button that looks very similar to wxButton. */
void wxRendererNative_php::DrawPushButton(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxRendererNative::DrawPushButton\n");
    php_printf("===========================================\n");
    #endif

    zval* params[4];
    zval arguments[4];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "DrawPushButton");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    object_init_ex(&arguments[0], php_wxWindow_entry);
    Z_wxWindow_P(&arguments[0])->native_object = (wxWindow_php*) &win;
    object_init_ex(&arguments[1], php_wxDC_entry);
    Z_wxDC_P(&arguments[1])->native_object = (wxDC_php*) &dc;
    object_init_ex(&arguments[2], php_wxRect_entry);
    Z_wxRect_P(&arguments[2])->native_object = (wxRect_php*) &rect;
    ZVAL_LONG(&arguments[3], flags);
    
    for(int i=0; i<4; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "DrawPushButton");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "DrawPushButton",
            14,
            &function_return_value,
            4,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<4; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxRendererNative::DrawPushButton'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return;

}
/* }}} */

/* {{{ proto  wxRendererNative::DrawItemSelectionRect(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw a selection rectangle underneath the text as used e.g. */
void wxRendererNative_php::DrawItemSelectionRect(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxRendererNative::DrawItemSelectionRect\n");
    php_printf("===========================================\n");
    #endif

    zval* params[4];
    zval arguments[4];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "DrawItemSelectionRect");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    object_init_ex(&arguments[0], php_wxWindow_entry);
    Z_wxWindow_P(&arguments[0])->native_object = (wxWindow_php*) &win;
    object_init_ex(&arguments[1], php_wxDC_entry);
    Z_wxDC_P(&arguments[1])->native_object = (wxDC_php*) &dc;
    object_init_ex(&arguments[2], php_wxRect_entry);
    Z_wxRect_P(&arguments[2])->native_object = (wxRect_php*) &rect;
    ZVAL_LONG(&arguments[3], flags);
    
    for(int i=0; i<4; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "DrawItemSelectionRect");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "DrawItemSelectionRect",
            21,
            &function_return_value,
            4,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<4; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxRendererNative::DrawItemSelectionRect'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return;

}
/* }}} */

/* {{{ proto  wxRendererNative::DrawRadioBitmap(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw a native wxRadioButton bitmap. */
void wxRendererNative_php::DrawRadioBitmap(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxRendererNative::DrawRadioBitmap\n");
    php_printf("===========================================\n");
    #endif

    zval* params[4];
    zval arguments[4];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "DrawRadioBitmap");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    object_init_ex(&arguments[0], php_wxWindow_entry);
    Z_wxWindow_P(&arguments[0])->native_object = (wxWindow_php*) &win;
    object_init_ex(&arguments[1], php_wxDC_entry);
    Z_wxDC_P(&arguments[1])->native_object = (wxDC_php*) &dc;
    object_init_ex(&arguments[2], php_wxRect_entry);
    Z_wxRect_P(&arguments[2])->native_object = (wxRect_php*) &rect;
    ZVAL_LONG(&arguments[3], flags);
    
    for(int i=0; i<4; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "DrawRadioBitmap");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "DrawRadioBitmap",
            15,
            &function_return_value,
            4,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<4; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxRendererNative::DrawRadioBitmap'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return;

}
/* }}} */

/* {{{ proto  wxRendererNative::DrawSplitterBorder(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw the border for sash window: this border must be such that the sash drawn by DrawSplitterSash() blends into it well. */
void wxRendererNative_php::DrawSplitterBorder(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxRendererNative::DrawSplitterBorder\n");
    php_printf("===========================================\n");
    #endif

    zval* params[4];
    zval arguments[4];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "DrawSplitterBorder");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    object_init_ex(&arguments[0], php_wxWindow_entry);
    Z_wxWindow_P(&arguments[0])->native_object = (wxWindow_php*) &win;
    object_init_ex(&arguments[1], php_wxDC_entry);
    Z_wxDC_P(&arguments[1])->native_object = (wxDC_php*) &dc;
    object_init_ex(&arguments[2], php_wxRect_entry);
    Z_wxRect_P(&arguments[2])->native_object = (wxRect_php*) &rect;
    ZVAL_LONG(&arguments[3], flags);
    
    for(int i=0; i<4; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "DrawSplitterBorder");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "DrawSplitterBorder",
            18,
            &function_return_value,
            4,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<4; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxRendererNative::DrawSplitterBorder'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return;

}
/* }}} */

/* {{{ proto  wxRendererNative::DrawSplitterSash(wxWindow &win, wxDC &dc, wxSize size, int position, wxOrientation orient, int flags)
   Draw a sash. */
void wxRendererNative_php::DrawSplitterSash(wxWindow* win, wxDC& dc, const wxSize& size, wxCoord position, wxOrientation orient, int flags)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxRendererNative::DrawSplitterSash\n");
    php_printf("===========================================\n");
    #endif

    zval* params[6];
    zval arguments[6];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "DrawSplitterSash");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    object_init_ex(&arguments[0], php_wxWindow_entry);
    Z_wxWindow_P(&arguments[0])->native_object = (wxWindow_php*) &win;
    object_init_ex(&arguments[1], php_wxDC_entry);
    Z_wxDC_P(&arguments[1])->native_object = (wxDC_php*) &dc;
    object_init_ex(&arguments[2], php_wxSize_entry);
    Z_wxSize_P(&arguments[2])->native_object = (wxSize_php*) &size;
    ZVAL_LONG(&arguments[3], position);
    ZVAL_LONG(&arguments[4], orient);
    ZVAL_LONG(&arguments[5], flags);
    
    for(int i=0; i<6; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "DrawSplitterSash");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "DrawSplitterSash",
            16,
            &function_return_value,
            6,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<6; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxRendererNative::DrawSplitterSash'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return;

}
/* }}} */

/* {{{ proto  wxRendererNative::DrawTextCtrl(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw a native wxTextCtrl frame. */
void wxRendererNative_php::DrawTextCtrl(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxRendererNative::DrawTextCtrl\n");
    php_printf("===========================================\n");
    #endif

    zval* params[4];
    zval arguments[4];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "DrawTextCtrl");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    object_init_ex(&arguments[0], php_wxWindow_entry);
    Z_wxWindow_P(&arguments[0])->native_object = (wxWindow_php*) &win;
    object_init_ex(&arguments[1], php_wxDC_entry);
    Z_wxDC_P(&arguments[1])->native_object = (wxDC_php*) &dc;
    object_init_ex(&arguments[2], php_wxRect_entry);
    Z_wxRect_P(&arguments[2])->native_object = (wxRect_php*) &rect;
    ZVAL_LONG(&arguments[3], flags);
    
    for(int i=0; i<4; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "DrawTextCtrl");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "DrawTextCtrl",
            12,
            &function_return_value,
            4,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<4; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxRendererNative::DrawTextCtrl'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return;

}
/* }}} */

/* {{{ proto  wxRendererNative::DrawTreeItemButton(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw the expanded/collapsed icon for a tree control item. */
void wxRendererNative_php::DrawTreeItemButton(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxRendererNative::DrawTreeItemButton\n");
    php_printf("===========================================\n");
    #endif

    zval* params[4];
    zval arguments[4];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "DrawTreeItemButton");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    object_init_ex(&arguments[0], php_wxWindow_entry);
    Z_wxWindow_P(&arguments[0])->native_object = (wxWindow_php*) &win;
    object_init_ex(&arguments[1], php_wxDC_entry);
    Z_wxDC_P(&arguments[1])->native_object = (wxDC_php*) &dc;
    object_init_ex(&arguments[2], php_wxRect_entry);
    Z_wxRect_P(&arguments[2])->native_object = (wxRect_php*) &rect;
    ZVAL_LONG(&arguments[3], flags);
    
    for(int i=0; i<4; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "DrawTreeItemButton");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "DrawTreeItemButton",
            18,
            &function_return_value,
            4,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<4; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxRendererNative::DrawTreeItemButton'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return;

}
/* }}} */

/* {{{ proto wxRendererNative wxRendererNative::Get()
   Return the currently used renderer. */
PHP_METHOD(php_wxRendererNative, Get)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxRendererNative::Get\n");
    php_printf("===========================================\n");
    #endif

    zo_wxRendererNative* current_object;
    wxphp_object_type current_object_type;
    wxRendererNative_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxRendererNative_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxRendererNative::Get call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXRENDERERNATIVE_TYPE){
                references = &((wxRendererNative_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxRendererNative::Get() to return object reference\n\n");
                #endif

                wxRendererNative_php* value_to_return0;
                value_to_return0 = (wxRendererNative_php*) &wxRendererNative::Get();
                if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxRendererNative_entry);
                    Z_wxRendererNative_P(return_value)->native_object = (wxRendererNative_php*) value_to_return0;
                }



                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxRendererNative::Get\n"
        );
    }
}
/* }}} */

/* {{{ proto wxSize wxRendererNative::GetCheckBoxSize(wxWindow &win, int flags)
   Returns the size of a check box. */
wxSize wxRendererNative_php::GetCheckBoxSize(wxWindow* win, int flags)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxRendererNative::GetCheckBoxSize\n");
    php_printf("===========================================\n");
    #endif

    zval* params[2];
    zval arguments[2];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "GetCheckBoxSize");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    object_init_ex(&arguments[0], php_wxWindow_entry);
    Z_wxWindow_P(&arguments[0])->native_object = (wxWindow_php*) &win;
    ZVAL_LONG(&arguments[1], flags);
    
    for(int i=0; i<2; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "GetCheckBoxSize");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "GetCheckBoxSize",
            15,
            &function_return_value,
            2,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<2; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxRendererNative::GetCheckBoxSize'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    if(Z_TYPE(function_return_value) == IS_OBJECT)
    {
        return_object = (void*) Z_wxSize_P(&function_return_value)->native_object;
    }

    //Threat it as a normal object on the calling function and not a php user space intiialized one
    Z_wxSize_P(&function_return_value)->is_user_initialized = 0;
    wxSize_php* var = (wxSize_php*) return_object;
    var->references.UnInitialize();

    return *(wxSize*) return_object;

}
/* }}} */

/* {{{ proto wxRendererNative wxRendererNative::GetDefault()
   Return the default (native) implementation for this platform  this is also the one used by default but this may be changed by calling Set() in which case the return value of this method may be different from the return value of Get(). */
PHP_METHOD(php_wxRendererNative, GetDefault)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxRendererNative::GetDefault\n");
    php_printf("===========================================\n");
    #endif

    zo_wxRendererNative* current_object;
    wxphp_object_type current_object_type;
    wxRendererNative_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxRendererNative_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxRendererNative::GetDefault call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXRENDERERNATIVE_TYPE){
                references = &((wxRendererNative_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxRendererNative::GetDefault() to return object reference\n\n");
                #endif

                wxRendererNative_php* value_to_return0;
                value_to_return0 = (wxRendererNative_php*) &wxRendererNative::GetDefault();
                if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxRendererNative_entry);
                    Z_wxRendererNative_P(return_value)->native_object = (wxRendererNative_php*) value_to_return0;
                }



                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxRendererNative::GetDefault\n"
        );
    }
}
/* }}} */

/* {{{ proto wxRendererNative wxRendererNative::GetGeneric()
   Return the generic implementation of the renderer. */
PHP_METHOD(php_wxRendererNative, GetGeneric)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxRendererNative::GetGeneric\n");
    php_printf("===========================================\n");
    #endif

    zo_wxRendererNative* current_object;
    wxphp_object_type current_object_type;
    wxRendererNative_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxRendererNative_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxRendererNative::GetGeneric call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXRENDERERNATIVE_TYPE){
                references = &((wxRendererNative_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxRendererNative::GetGeneric() to return object reference\n\n");
                #endif

                wxRendererNative_php* value_to_return0;
                value_to_return0 = (wxRendererNative_php*) &wxRendererNative::GetGeneric();
                if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxRendererNative_entry);
                    Z_wxRendererNative_P(return_value)->native_object = (wxRendererNative_php*) value_to_return0;
                }



                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxRendererNative::GetGeneric\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxRendererNative::GetHeaderButtonHeight(wxWindow &win)
   Returns the height of a header button, either a fixed platform height if available, or a generic height based on the win window's font. */
int wxRendererNative_php::GetHeaderButtonHeight(wxWindow* win)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxRendererNative::GetHeaderButtonHeight\n");
    php_printf("===========================================\n");
    #endif

    zval* params[1];
    zval arguments[1];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "GetHeaderButtonHeight");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    object_init_ex(&arguments[0], php_wxWindow_entry);
    Z_wxWindow_P(&arguments[0])->native_object = (wxWindow_php*) &win;
    
    for(int i=0; i<1; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "GetHeaderButtonHeight");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "GetHeaderButtonHeight",
            21,
            &function_return_value,
            1,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<1; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxRendererNative::GetHeaderButtonHeight'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return (int) Z_LVAL(function_return_value);

}
/* }}} */

/* {{{ proto int wxRendererNative::GetHeaderButtonMargin(wxWindow &win)
   Returns the horizontal margin on the left and right sides of header button's label. */
int wxRendererNative_php::GetHeaderButtonMargin(wxWindow* win)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxRendererNative::GetHeaderButtonMargin\n");
    php_printf("===========================================\n");
    #endif

    zval* params[1];
    zval arguments[1];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "GetHeaderButtonMargin");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    object_init_ex(&arguments[0], php_wxWindow_entry);
    Z_wxWindow_P(&arguments[0])->native_object = (wxWindow_php*) &win;
    
    for(int i=0; i<1; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "GetHeaderButtonMargin");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "GetHeaderButtonMargin",
            21,
            &function_return_value,
            1,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<1; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxRendererNative::GetHeaderButtonMargin'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return (int) Z_LVAL(function_return_value);

}
/* }}} */

/* {{{ proto wxRendererNative wxRendererNative::Load(string name)
   Load the renderer from the specified DLL, the returned pointer must be deleted by caller if not NULL when it is not used any more. */
PHP_METHOD(php_wxRendererNative, Load)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxRendererNative::Load\n");
    php_printf("===========================================\n");
    #endif

    zo_wxRendererNative* current_object;
    wxphp_object_type current_object_type;
    wxRendererNative_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxRendererNative_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxRendererNative::Load call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXRENDERERNATIVE_TYPE){
                references = &((wxRendererNative_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxRendererNative::Load(wxString(name0, wxConvUTF8)) to return object pointer\n\n");
                #endif

                wxRendererNative_php* value_to_return1;
                value_to_return1 = (wxRendererNative_php*) wxRendererNative::Load(wxString(name0, wxConvUTF8));
                if(value_to_return1 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return1->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return1->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return1->phpObj);
                        zval_add_ref(&value_to_return1->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxRendererNative_entry);
                    Z_wxRendererNative_P(return_value)->native_object = (wxRendererNative_php*) value_to_return1;
                }



                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxRendererNative::Load\n"
        );
    }
}
/* }}} */

/* {{{ proto wxRendererNative wxRendererNative::Set(wxRendererNative &renderer)
   Set the renderer to use, passing NULL reverts to using the default renderer (the global renderer must always exist). */
PHP_METHOD(php_wxRendererNative, Set)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxRendererNative::Set\n");
    php_printf("===========================================\n");
    #endif

    zo_wxRendererNative* current_object;
    wxphp_object_type current_object_type;
    wxRendererNative_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxRendererNative_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxRendererNative::Set call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXRENDERERNATIVE_TYPE){
                references = &((wxRendererNative_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* renderer0;
    wxRendererNative* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&renderer0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &renderer0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(renderer0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxRendererNative_P(renderer0)->object_type;
                    argument_native_object = (void*) Z_wxRendererNative_P(renderer0)->native_object;
                    object_pointer0_0 = (wxRendererNative*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXRENDERERNATIVE_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'renderer' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(renderer0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'renderer' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxRendererNative::Set((wxRendererNative*) object_pointer0_0) to return object pointer\n\n");
                #endif

                wxRendererNative_php* value_to_return1;
                value_to_return1 = (wxRendererNative_php*) wxRendererNative::Set((wxRendererNative*) object_pointer0_0);
                if(value_to_return1 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return1->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return1->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return1->phpObj);
                        zval_add_ref(&value_to_return1->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxRendererNative_entry);
                    Z_wxRendererNative_P(return_value)->native_object = (wxRendererNative_php*) value_to_return1;
                }



                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxRendererNative::Set\n"
        );
    }
}
/* }}} */

