/*
 * @author Mário Soares
 * @contributors Jefferson González
 * @contributors René Vögeli / Rangee GmbH
 * 
 * @license 
 * This file is part of wxPHP check the LICENSE file for information.
 * 
 * @note
 * This file was auto-generated by the wxPHP source maker
*/

#include "php_wxwidgets.h"
#include "appmanagement.h"
#include "cfg.h"
#include "bookctrl.h"
#include "dnd.h"
#include "cmndlg.h"
#include "containers.h"
#include "ctrl.h"
#include "data.h"
#include "dc.h"
#include "docview.h"
#include "events.h"
#include "file.h"
#include "gdi.h"
#include "grid.h"
#include "html.h"
#include "help.h"
#include "logging.h"
#include "managedwnd.h"
#include "menus.h"
#include "misc.h"
#include "miscwnd.h"
#include "media.h"
#include "net.h"
#include "pickers.h"
#include "printing.h"
#include "ribbon.h"
#include "richtext.h"
#include "rtti.h"
#include "stc.h"
#include "streams.h"
#include "threading.h"
#include "validator.h"
#include "vfs.h"
#include "aui.h"
#include "winlayout.h"
#include "xml.h"
#include "xrc.h"
#include "dvc.h"
#include "others.h"


BEGIN_EXTERN_C()
void php_wxFileSystem_free(zend_object *object)
{
    zo_wxFileSystem* custom_object = php_wxFileSystem_fetch_object(object);

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFileSystem_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxFileSystem done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
}

wxFileSystem_php::~wxFileSystem_php()
{
    if (zo) {
        zo->native_object = NULL;
    }
}

zend_object* php_wxFileSystem_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFileSystem_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystem* custom_object;

    custom_object = (zo_wxFileSystem*) ecalloc(
        1,
        sizeof(zo_wxFileSystem)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    memcpy(&wxphp_wxFileSystem_object_handlers, zend_get_std_object_handlers(), sizeof wxphp_wxFileSystem_object_handlers);
    wxphp_wxFileSystem_object_handlers.offset = XtOffsetOf(zo_wxFileSystem, zo);
    wxphp_wxFileSystem_object_handlers.free_obj = php_wxFileSystem_free;
    custom_object->zo.handlers = &wxphp_wxFileSystem_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFILESYSTEM_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxFileSystem::wxFileSystem()
   Constructor. */
PHP_METHOD(php_wxFileSystem, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystem::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystem* current_object;
    wxFileSystem_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxFileSystem_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxFileSystem_P(getThis());

        current_object->native_object = native_object;
        native_object->zo = current_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxFileSystem::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto wxFileName wxFileSystem::URLToFileName(string url)
   Converts URL into a well-formed filename. */
PHP_METHOD(php_wxFileSystem, URLToFileName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystem::URLToFileName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystem* current_object;
    wxphp_object_type current_object_type;
    wxFileSystem_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileSystem_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileSystem::URLToFileName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILESYSTEM_TYPE){
                references = &((wxFileSystem_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* url0;
    size_t url_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&url0, &url_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &url0, &url_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFileSystem::URLToFileName(wxString(url0, wxConvUTF8)) to return new object\n\n");
                #endif

                wxFileName value_to_return1;
                value_to_return1 = wxFileSystem::URLToFileName(wxString(url0, wxConvUTF8));
                void* ptr = safe_emalloc(1, sizeof(wxFileName_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxFileName));
                object_init_ex(return_value, php_wxFileName_entry);
                ((wxFileName_php*)ptr)->phpObj = *return_value;
                zo_wxFileName* zo1 = Z_wxFileName_P(return_value);
                zo1->native_object = (wxFileName_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileSystem::URLToFileName\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFSFile wxFileSystem::OpenFile(string location, int flags)
   Opens the file and returns a pointer to a wxFSFile object or NULL if failed. */
PHP_METHOD(php_wxFileSystem, OpenFile)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystem::OpenFile\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystem* current_object;
    wxphp_object_type current_object_type;
    wxFileSystem_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileSystem_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileSystem::OpenFile call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILESYSTEM_TYPE){
                references = &((wxFileSystem_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* location0;
    size_t location_len0;
    long flags0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|l' (&location0, &location_len0, &flags0)\n");
        #endif

        char parse_parameters_string[] = "s|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &location0, &location_len0, &flags0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileSystem::OpenFile(wxString(location0, wxConvUTF8)) to return object pointer\n\n");
                #endif

                wxFSFile_php* value_to_return1;
                value_to_return1 = (wxFSFile_php*) ((wxFileSystem_php*)native_object)->OpenFile(wxString(location0, wxConvUTF8));

                if(value_to_return1 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return1->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return1->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return1->phpObj);
                        zval_add_ref(&value_to_return1->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFSFile_entry);
                    Z_wxFSFile_P(return_value)->native_object = (wxFSFile_php*) value_to_return1;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return1 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxFileSystem::OpenFile at call 5 with 1 argument(s)");
                }


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileSystem::OpenFile(wxString(location0, wxConvUTF8), (int) flags0) to return object pointer\n\n");
                #endif

                wxFSFile_php* value_to_return2;
                value_to_return2 = (wxFSFile_php*) ((wxFileSystem_php*)native_object)->OpenFile(wxString(location0, wxConvUTF8), (int) flags0);

                if(value_to_return2 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return2->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return2->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return2->phpObj);
                        zval_add_ref(&value_to_return2->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFSFile_entry);
                    Z_wxFSFile_P(return_value)->native_object = (wxFSFile_php*) value_to_return2;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return2 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxFileSystem::OpenFile at call 5 with 2 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileSystem::OpenFile\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileSystem::HasHandlerForPath(string location)
   This static function returns true if there is a registered handler which can open the given location. */
PHP_METHOD(php_wxFileSystem, HasHandlerForPath)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystem::HasHandlerForPath\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystem* current_object;
    wxphp_object_type current_object_type;
    wxFileSystem_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileSystem_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileSystem::HasHandlerForPath call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILESYSTEM_TYPE){
                references = &((wxFileSystem_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* location0;
    size_t location_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&location0, &location_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &location0, &location_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxFileSystem::HasHandlerForPath(wxString(location0, wxConvUTF8)))\n\n");
                #endif

                WXPHP_RETVAL_BOOL(wxFileSystem::HasHandlerForPath(wxString(location0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileSystem::HasHandlerForPath\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileSystem::GetPath()
   Returns the actual path (set by wxFileSystem::ChangePathTo). */
PHP_METHOD(php_wxFileSystem, GetPath)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystem::GetPath\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystem* current_object;
    wxphp_object_type current_object_type;
    wxFileSystem_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileSystem_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileSystem::GetPath call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILESYSTEM_TYPE){
                references = &((wxFileSystem_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileSystem::GetPath().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxFileSystem_php*)native_object)->GetPath();
                WXPHP_RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileSystem::GetPath\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileSystem::FindNext()
   Returns the next filename that matches the parameters passed to FindFirst(). */
PHP_METHOD(php_wxFileSystem, FindNext)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystem::FindNext\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystem* current_object;
    wxphp_object_type current_object_type;
    wxFileSystem_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileSystem_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileSystem::FindNext call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILESYSTEM_TYPE){
                references = &((wxFileSystem_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileSystem::FindNext().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxFileSystem_php*)native_object)->FindNext();
                WXPHP_RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileSystem::FindNext\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileSystem::FindFirst(string wildcard, int flags)
   Works like wxFindFirstFile(). */
PHP_METHOD(php_wxFileSystem, FindFirst)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystem::FindFirst\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystem* current_object;
    wxphp_object_type current_object_type;
    wxFileSystem_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileSystem_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileSystem::FindFirst call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILESYSTEM_TYPE){
                references = &((wxFileSystem_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* wildcard0;
    size_t wildcard_len0;
    long flags0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|l' (&wildcard0, &wildcard_len0, &flags0)\n");
        #endif

        char parse_parameters_string[] = "s|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &wildcard0, &wildcard_len0, &flags0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileSystem::FindFirst(wxString(wildcard0, wxConvUTF8)).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = ((wxFileSystem_php*)native_object)->FindFirst(wxString(wildcard0, wxConvUTF8));
                WXPHP_RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileSystem::FindFirst(wxString(wildcard0, wxConvUTF8), (int) flags0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return2;
                value_to_return2 = ((wxFileSystem_php*)native_object)->FindFirst(wxString(wildcard0, wxConvUTF8), (int) flags0);
                WXPHP_RETVAL_STRING(value_to_return2.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileSystem::FindFirst\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileSystem::FindFileInPath(string &pStr, string path, string file)
   Looks for the file with the given name file in a colon or semi-colon (depending on the current platform) separated list of directories in path. */
PHP_METHOD(php_wxFileSystem, FindFileInPath)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystem::FindFileInPath\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystem* current_object;
    wxphp_object_type current_object_type;
    wxFileSystem_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileSystem_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileSystem::FindFileInPath call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILESYSTEM_TYPE){
                references = &((wxFileSystem_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* pStr0;
    size_t pStr_len0;
    zval pStr0_ref;
    char* path0;
    size_t path_len0;
    char* file0;
    size_t file_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sss' (&pStr0, &pStr_len0, &path0, &path_len0, &file0, &file_len0)\n");
        #endif

        char parse_parameters_string[] = "sss";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pStr0, &pStr_len0, &path0, &path_len0, &file0, &file_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;

            char parse_references_string[] = "zzz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, pStr0_ref, dummy, dummy );
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                wxString string_arg0_0 = wxString(pStr0, wxConvUTF8);
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileSystem::FindFileInPath(&string_arg0_0, wxString(path0, wxConvUTF8), wxString(file0, wxConvUTF8)))\n\n");
                #endif

                WXPHP_RETVAL_BOOL(((wxFileSystem_php*)native_object)->FindFileInPath(&string_arg0_0, wxString(path0, wxConvUTF8), wxString(file0, wxConvUTF8)));

                ZVAL_STRING(&pStr0_ref, string_arg0_0.ToUTF8().data());

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileSystem::FindFileInPath\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileSystem::FileNameToURL(wxFileName filename)
   Converts a wxFileName into an URL. */
PHP_METHOD(php_wxFileSystem, FileNameToURL)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystem::FileNameToURL\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystem* current_object;
    wxphp_object_type current_object_type;
    wxFileSystem_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileSystem_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileSystem::FileNameToURL call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILESYSTEM_TYPE){
                references = &((wxFileSystem_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* filename0;
    wxFileName* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&filename0, php_wxFileName_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &filename0, php_wxFileName_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(filename0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxFileName_P(filename0)->object_type;
                    argument_native_object = (void*) Z_wxFileName_P(filename0)->native_object;
                    object_pointer0_0 = (wxFileName*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'filename' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(filename0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'filename' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileSystem::FileNameToURL(*(wxFileName*) object_pointer0_0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = wxFileSystem::FileNameToURL(*(wxFileName*) object_pointer0_0);
                WXPHP_RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileSystem::FileNameToURL\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileSystem::ChangePathTo(string location, bool is_dir)
   Sets the current location. */
PHP_METHOD(php_wxFileSystem, ChangePathTo)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystem::ChangePathTo\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystem* current_object;
    wxphp_object_type current_object_type;
    wxFileSystem_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileSystem_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileSystem::ChangePathTo call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILESYSTEM_TYPE){
                references = &((wxFileSystem_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* location0;
    size_t location_len0;
    bool is_dir0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|b' (&location0, &location_len0, &is_dir0)\n");
        #endif

        char parse_parameters_string[] = "s|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &location0, &location_len0, &is_dir0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileSystem::ChangePathTo(wxString(location0, wxConvUTF8))\n\n");
                #endif

                ((wxFileSystem_php*)native_object)->ChangePathTo(wxString(location0, wxConvUTF8));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileSystem::ChangePathTo(wxString(location0, wxConvUTF8), is_dir0)\n\n");
                #endif

                ((wxFileSystem_php*)native_object)->ChangePathTo(wxString(location0, wxConvUTF8), is_dir0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileSystem::ChangePathTo\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileSystem::AddHandler(wxFileSystemHandler &handler)
   This static function adds new handler into the list of handlers (see wxFileSystemHandler) which provide access to virtual FS. */
PHP_METHOD(php_wxFileSystem, AddHandler)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystem::AddHandler\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystem* current_object;
    wxphp_object_type current_object_type;
    wxFileSystem_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileSystem_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileSystem::AddHandler call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILESYSTEM_TYPE){
                references = &((wxFileSystem_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* handler0;
    wxFileSystemHandler* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&handler0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &handler0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(handler0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxFileSystemHandler_P(handler0)->object_type;
                    argument_native_object = (void*) Z_wxFileSystemHandler_P(handler0)->native_object;
                    object_pointer0_0 = (wxFileSystemHandler*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXFILESYSTEMHANDLER_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'handler' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(handler0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'handler' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFileSystem::AddHandler((wxFileSystemHandler*) object_pointer0_0)\n\n");
                #endif

                wxFileSystem::AddHandler((wxFileSystemHandler*) object_pointer0_0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileSystem::AddHandler\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFileSystemHandler_free(zend_object *object)
{
    zo_wxFileSystemHandler* custom_object = php_wxFileSystemHandler_fetch_object(object);

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFileSystemHandler_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxFileSystemHandler done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
}

wxFileSystemHandler_php::~wxFileSystemHandler_php()
{
    if (zo) {
        zo->native_object = NULL;
    }
}

zend_object* php_wxFileSystemHandler_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFileSystemHandler_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystemHandler* custom_object;

    custom_object = (zo_wxFileSystemHandler*) ecalloc(
        1,
        sizeof(zo_wxFileSystemHandler)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    memcpy(&wxphp_wxFileSystemHandler_object_handlers, zend_get_std_object_handlers(), sizeof wxphp_wxFileSystemHandler_object_handlers);
    wxphp_wxFileSystemHandler_object_handlers.offset = XtOffsetOf(zo_wxFileSystemHandler, zo);
    wxphp_wxFileSystemHandler_object_handlers.free_obj = php_wxFileSystemHandler_free;
    custom_object->zo.handlers = &wxphp_wxFileSystemHandler_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFILESYSTEMHANDLER_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto bool wxFileSystemHandler::CanOpen(string location)
   Returns true if the handler is able to open this file. */
bool wxFileSystemHandler_php::CanOpen(const wxString& location)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxFileSystemHandler::CanOpen\n");
    php_printf("===========================================\n");
    #endif

    zval* params[1];
    zval arguments[1];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "CanOpen");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    ZVAL_STRING(&arguments[0], location.ToUTF8().data());
    
    for(int i=0; i<1; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "CanOpen");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "CanOpen",
            7,
            &function_return_value,
            1,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<1; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxFileSystemHandler::CanOpen'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return Z_TYPE(function_return_value) == IS_TRUE;

}
/* }}} */

/* {{{ proto string wxFileSystemHandler::FindFirst(string wildcard, int flags)
   Works like wxFindFirstFile(). */
PHP_METHOD(php_wxFileSystemHandler, FindFirst)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystemHandler::FindFirst\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystemHandler* current_object;
    wxphp_object_type current_object_type;
    wxFileSystemHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileSystemHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileSystemHandler::FindFirst call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILESYSTEMHANDLER_TYPE){
                references = &((wxFileSystemHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* wildcard0;
    size_t wildcard_len0;
    long flags0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|l' (&wildcard0, &wildcard_len0, &flags0)\n");
        #endif

        char parse_parameters_string[] = "s|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &wildcard0, &wildcard_len0, &flags0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileSystemHandler::FindFirst(wxString(wildcard0, wxConvUTF8)).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = ((wxFileSystemHandler_php*)native_object)->FindFirst(wxString(wildcard0, wxConvUTF8));
                WXPHP_RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileSystemHandler::FindFirst(wxString(wildcard0, wxConvUTF8), (int) flags0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return2;
                value_to_return2 = ((wxFileSystemHandler_php*)native_object)->FindFirst(wxString(wildcard0, wxConvUTF8), (int) flags0);
                WXPHP_RETVAL_STRING(value_to_return2.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileSystemHandler::FindFirst\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileSystemHandler::FindNext()
   Returns next filename that matches parameters passed to wxFileSystem::FindFirst. */
PHP_METHOD(php_wxFileSystemHandler, FindNext)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystemHandler::FindNext\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystemHandler* current_object;
    wxphp_object_type current_object_type;
    wxFileSystemHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileSystemHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileSystemHandler::FindNext call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILESYSTEMHANDLER_TYPE){
                references = &((wxFileSystemHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileSystemHandler::FindNext().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxFileSystemHandler_php*)native_object)->FindNext();
                WXPHP_RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileSystemHandler::FindNext\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileSystemHandler::GetMimeTypeFromExt(string location)
   Returns the MIME type based on extension of location. */
PHP_METHOD(php_wxFileSystemHandler, GetMimeTypeFromExt)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystemHandler::GetMimeTypeFromExt\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystemHandler* current_object;
    wxphp_object_type current_object_type;
    wxFileSystemHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileSystemHandler_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileSystemHandler::GetMimeTypeFromExt call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILESYSTEMHANDLER_TYPE){
                references = &((wxFileSystemHandler_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* location0;
    size_t location_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&location0, &location_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &location0, &location_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileSystemHandler::GetMimeTypeFromExt(wxString(location0, wxConvUTF8)).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = wxFileSystemHandler::GetMimeTypeFromExt(wxString(location0, wxConvUTF8));
                WXPHP_RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileSystemHandler::GetMimeTypeFromExt\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFSFile wxFileSystemHandler::OpenFile(wxFileSystem &fs, string location)
   Opens the file and returns wxFSFile pointer or NULL if failed. */
wxFSFile* wxFileSystemHandler_php::OpenFile(wxFileSystem& fs, const wxString& location)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxFileSystemHandler::OpenFile\n");
    php_printf("===========================================\n");
    #endif

    zval* params[2];
    zval arguments[2];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "OpenFile");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    object_init_ex(&arguments[0], php_wxFileSystem_entry);
    Z_wxFileSystem_P(&arguments[0])->native_object = (wxFileSystem_php*) &fs;
    ZVAL_STRING(&arguments[1], location.ToUTF8().data());
    
    for(int i=0; i<2; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "OpenFile");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "OpenFile",
            8,
            &function_return_value,
            2,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<2; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxFileSystemHandler::OpenFile'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    if(Z_TYPE(function_return_value) == IS_OBJECT)
    {
        return_object = (void*) Z_wxFSFile_P(&function_return_value)->native_object;
    }

    //Threat it as a normal object on the calling function and not a php user space intiialized one
    Z_wxFSFile_P(&function_return_value)->is_user_initialized = 0;
    wxFSFile_php* var = (wxFSFile_php*) return_object;
    var->references.UnInitialize();

    return (wxFSFile*) return_object;

}
/* }}} */

/* {{{ proto  wxFileSystemHandler::wxFileSystemHandler()
   Constructor. */
PHP_METHOD(php_wxFileSystemHandler, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystemHandler::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystemHandler* current_object;
    wxFileSystemHandler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxFileSystemHandler_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxFileSystemHandler_P(getThis());

        current_object->native_object = native_object;
        native_object->zo = current_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxFileSystemHandler::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

