/*
 * @author Mário Soares
 * @contributors Jefferson González
 * @contributors René Vögeli / Rangee GmbH
 * 
 * @license 
 * This file is part of wxPHP check the LICENSE file for information.
 * 
 * @note
 * This file was auto-generated by the wxPHP source maker
*/

#include "php_wxwidgets.h"
#include "appmanagement.h"
#include "aui.h"
#include "bookctrl.h"
#include "cfg.h"
#include "cmndlg.h"
#include "containers.h"
#include "ctrl.h"
#include "data.h"
#include "dc.h"
#include "dnd.h"
#include "docview.h"
#include "dvc.h"
#include "events.h"
#include "file.h"
#include "gdi.h"
#include "grid.h"
#include "help.h"
#include "html.h"
#include "logging.h"
#include "managedwnd.h"
#include "media.h"
#include "menus.h"
#include "misc.h"
#include "miscwnd.h"
#include "net.h"
#include "pickers.h"
#include "printing.h"
#include "ribbon.h"
#include "richtext.h"
#include "rtti.h"
#include "stc.h"
#include "streams.h"
#include "threading.h"
#include "validator.h"
#include "vfs.h"
#include "winlayout.h"
#include "xml.h"
#include "xrc.h"
#include "others.h"


BEGIN_EXTERN_C()
void php_wxScrolledWindow_free(void *object)
{
    zo_wxScrolledWindow* custom_object = (zo_wxScrolledWindow*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Obviate delete call for wxScrolledWindow on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n\n");
    #endif

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxScrolledWindow_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxScrolledWindow_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxScrolledWindow* custom_object;

    custom_object = (zo_wxScrolledWindow*) ecalloc(
        1,
        sizeof(zo_wxScrolledWindow)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxScrolledWindow_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXSCROLLEDWINDOW_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxScrolledWindow::wxScrolledWindow() */
PHP_METHOD(php_wxScrolledWindow, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxScrolledWindow::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxScrolledWindow* current_object;
    wxScrolledWindow_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    zval* parent1;
    wxWindow* object_pointer1_0 = 0;
    long winid1;
    zval* pos1;
    wxPoint* object_pointer1_2 = 0;
    zval* size1;
    wxSize* object_pointer1_3 = 0;
    long style1;
    char* name1;
    size_t name_len1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 1  && arguments_received <= 6)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z|lOOls' (&parent1, &winid1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
        #endif

        char parse_parameters_string[] = "z|lOOls";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &parent1, &winid1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(parent1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxWindow_P(parent1)->object_type;
                    argument_native_object = (void*) Z_wxWindow_P(parent1)->native_object;
                    object_pointer1_0 = (wxWindow*) argument_native_object;
                    if (!object_pointer1_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'parent' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(parent1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'parent' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 3){
                if(Z_TYPE_P(pos1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPoint_P(pos1)->object_type;
                    argument_native_object = (void*) Z_wxPoint_P(pos1)->native_object;
                    object_pointer1_2 = (wxPoint*) argument_native_object;
                    if (!object_pointer1_2 )
                    {
                        zend_error(E_ERROR, "Parameter 'pos' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(pos1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'pos' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 4){
                if(Z_TYPE_P(size1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(size1)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(size1)->native_object;
                    object_pointer1_3 = (wxSize*) argument_native_object;
                    if (!object_pointer1_3 )
                    {
                        zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(size1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxScrolledWindow_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
                #endif

                native_object = new wxScrolledWindow_php((wxWindow*) object_pointer1_0);

                native_object->references.Initialize();
                ((wxScrolledWindow_php*) native_object)->references.AddReference(parent1, "wxScrolledWindow::wxScrolledWindow at call 2 with 1 argument(s)");
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1)\n");
                #endif

                native_object = new wxScrolledWindow_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1);

                native_object->references.Initialize();
                ((wxScrolledWindow_php*) native_object)->references.AddReference(parent1, "wxScrolledWindow::wxScrolledWindow at call 2 with 2 argument(s)");
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2)\n");
                #endif

                native_object = new wxScrolledWindow_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2);

                native_object->references.Initialize();
                ((wxScrolledWindow_php*) native_object)->references.AddReference(parent1, "wxScrolledWindow::wxScrolledWindow at call 2 with 3 argument(s)");
                ((wxScrolledWindow_php*) native_object)->references.AddReference(pos1, "wxScrolledWindow::wxScrolledWindow at call 4 with 3 argument(s)");
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
                #endif

                native_object = new wxScrolledWindow_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

                native_object->references.Initialize();
                ((wxScrolledWindow_php*) native_object)->references.AddReference(parent1, "wxScrolledWindow::wxScrolledWindow at call 2 with 4 argument(s)");
                ((wxScrolledWindow_php*) native_object)->references.AddReference(pos1, "wxScrolledWindow::wxScrolledWindow at call 4 with 4 argument(s)");
                ((wxScrolledWindow_php*) native_object)->references.AddReference(size1, "wxScrolledWindow::wxScrolledWindow at call 4 with 4 argument(s)");
                break;
            }
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
                #endif

                native_object = new wxScrolledWindow_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

                native_object->references.Initialize();
                ((wxScrolledWindow_php*) native_object)->references.AddReference(parent1, "wxScrolledWindow::wxScrolledWindow at call 2 with 5 argument(s)");
                ((wxScrolledWindow_php*) native_object)->references.AddReference(pos1, "wxScrolledWindow::wxScrolledWindow at call 4 with 5 argument(s)");
                ((wxScrolledWindow_php*) native_object)->references.AddReference(size1, "wxScrolledWindow::wxScrolledWindow at call 4 with 5 argument(s)");
                break;
            }
            case 6:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8))\n");
                #endif

                native_object = new wxScrolledWindow_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8));

                native_object->references.Initialize();
                ((wxScrolledWindow_php*) native_object)->references.AddReference(parent1, "wxScrolledWindow::wxScrolledWindow at call 2 with 6 argument(s)");
                ((wxScrolledWindow_php*) native_object)->references.AddReference(pos1, "wxScrolledWindow::wxScrolledWindow at call 4 with 6 argument(s)");
                ((wxScrolledWindow_php*) native_object)->references.AddReference(size1, "wxScrolledWindow::wxScrolledWindow at call 4 with 6 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxScrolledWindow_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxScrolledWindow::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxRibbonButtonBarButtonBase_free(void *object)
{
    zo_wxRibbonButtonBarButtonBase* custom_object = (zo_wxRibbonButtonBarButtonBase*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxRibbonButtonBarButtonBase_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxRibbonButtonBarButtonBase done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxRibbonButtonBarButtonBase_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxRibbonButtonBarButtonBase_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxRibbonButtonBarButtonBase* custom_object;

    custom_object = (zo_wxRibbonButtonBarButtonBase*) ecalloc(
        1,
        sizeof(zo_wxRibbonButtonBarButtonBase)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxRibbonButtonBarButtonBase_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXRIBBONBUTTONBARBUTTONBASE_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

BEGIN_EXTERN_C()
void php_wxRibbonGalleryItem_free(void *object)
{
    zo_wxRibbonGalleryItem* custom_object = (zo_wxRibbonGalleryItem*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxRibbonGalleryItem_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxRibbonGalleryItem done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxRibbonGalleryItem_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxRibbonGalleryItem_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxRibbonGalleryItem* custom_object;

    custom_object = (zo_wxRibbonGalleryItem*) ecalloc(
        1,
        sizeof(zo_wxRibbonGalleryItem)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxRibbonGalleryItem_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXRIBBONGALLERYITEM_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

BEGIN_EXTERN_C()
void php_wxRibbonToolBarToolBase_free(void *object)
{
    zo_wxRibbonToolBarToolBase* custom_object = (zo_wxRibbonToolBarToolBase*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxRibbonToolBarToolBase_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxRibbonToolBarToolBase done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxRibbonToolBarToolBase_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxRibbonToolBarToolBase_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxRibbonToolBarToolBase* custom_object;

    custom_object = (zo_wxRibbonToolBarToolBase*) ecalloc(
        1,
        sizeof(zo_wxRibbonToolBarToolBase)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxRibbonToolBarToolBase_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXRIBBONTOOLBARTOOLBASE_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

BEGIN_EXTERN_C()
void php_wxGridCellCoords_free(void *object)
{
    zo_wxGridCellCoords* custom_object = (zo_wxGridCellCoords*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGridCellCoords_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxGridCellCoords done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxGridCellCoords_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGridCellCoords_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxGridCellCoords* custom_object;

    custom_object = (zo_wxGridCellCoords*) ecalloc(
        1,
        sizeof(zo_wxGridCellCoords)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxGridCellCoords_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCELLCOORDS_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxGridCellCoords::wxGridCellCoords()
   Default constructor initializes the object to invalid state. */
PHP_METHOD(php_wxGridCellCoords, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGridCellCoords::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGridCellCoords* current_object;
    wxGridCellCoords_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    long row1;
    long col1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (&row1, &col1)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &row1, &col1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxGridCellCoords_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) row1, (int) col1)\n");
                #endif

                native_object = new wxGridCellCoords_php((int) row1, (int) col1);

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxGridCellCoords_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxGridCellCoords::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto int wxGridCellCoords::GetRow()
   Return the row of the coordinate. */
PHP_METHOD(php_wxGridCellCoords, GetRow)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGridCellCoords::GetRow\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGridCellCoords* current_object;
    wxphp_object_type current_object_type;
    wxGridCellCoords_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGridCellCoords_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGridCellCoords::GetRow call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRIDCELLCOORDS_TYPE){
                references = &((wxGridCellCoords_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxGridCellCoords::GetRow())\n\n");
                #endif

                RETVAL_LONG(((wxGridCellCoords_php*)native_object)->GetRow());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGridCellCoords::GetRow\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxGridCellCoords::SetRow(int n)
   Set the row of the coordinate. */
PHP_METHOD(php_wxGridCellCoords, SetRow)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGridCellCoords::SetRow\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGridCellCoords* current_object;
    wxphp_object_type current_object_type;
    wxGridCellCoords_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGridCellCoords_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGridCellCoords::SetRow call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRIDCELLCOORDS_TYPE){
                references = &((wxGridCellCoords_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long n0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&n0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &n0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGridCellCoords::SetRow((int) n0)\n\n");
                #endif

                ((wxGridCellCoords_php*)native_object)->SetRow((int) n0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGridCellCoords::SetRow\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxGridCellCoords::GetCol()
   Return the column of the coordinate. */
PHP_METHOD(php_wxGridCellCoords, GetCol)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGridCellCoords::GetCol\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGridCellCoords* current_object;
    wxphp_object_type current_object_type;
    wxGridCellCoords_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGridCellCoords_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGridCellCoords::GetCol call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRIDCELLCOORDS_TYPE){
                references = &((wxGridCellCoords_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxGridCellCoords::GetCol())\n\n");
                #endif

                RETVAL_LONG(((wxGridCellCoords_php*)native_object)->GetCol());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGridCellCoords::GetCol\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxGridCellCoords::SetCol(int n)
   Set the column of the coordinate. */
PHP_METHOD(php_wxGridCellCoords, SetCol)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGridCellCoords::SetCol\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGridCellCoords* current_object;
    wxphp_object_type current_object_type;
    wxGridCellCoords_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGridCellCoords_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGridCellCoords::SetCol call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRIDCELLCOORDS_TYPE){
                references = &((wxGridCellCoords_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long n0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&n0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &n0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGridCellCoords::SetCol((int) n0)\n\n");
                #endif

                ((wxGridCellCoords_php*)native_object)->SetCol((int) n0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGridCellCoords::SetCol\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxGridCellCoords::Set(int row, int col)
   Set the row and column of the coordinate. */
PHP_METHOD(php_wxGridCellCoords, Set)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGridCellCoords::Set\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGridCellCoords* current_object;
    wxphp_object_type current_object_type;
    wxGridCellCoords_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGridCellCoords_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGridCellCoords::Set call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRIDCELLCOORDS_TYPE){
                references = &((wxGridCellCoords_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long row0;
    long col0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &row0, &col0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGridCellCoords::Set((int) row0, (int) col0)\n\n");
                #endif

                ((wxGridCellCoords_php*)native_object)->Set((int) row0, (int) col0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGridCellCoords::Set\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxNonOwnedWindow_free(void *object)
{
    zo_wxNonOwnedWindow* custom_object = (zo_wxNonOwnedWindow*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxNonOwnedWindow_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf(
                "Deleting object by calling destroy and delete\n"
            );
            #endif

            custom_object->native_object->Destroy();
            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxNonOwnedWindow done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxNonOwnedWindow_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxNonOwnedWindow_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxNonOwnedWindow* custom_object;

    custom_object = (zo_wxNonOwnedWindow*) ecalloc(
        1,
        sizeof(zo_wxNonOwnedWindow)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxNonOwnedWindow_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXNONOWNEDWINDOW_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto bool wxNonOwnedWindow::SetShape(wxRegion region)
   If the platform supports it, sets the shape of the window to that depicted by region. */
PHP_METHOD(php_wxNonOwnedWindow, SetShape)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNonOwnedWindow::SetShape\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNonOwnedWindow* current_object;
    wxphp_object_type current_object_type;
    wxNonOwnedWindow_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNonOwnedWindow_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNonOwnedWindow::SetShape call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNONOWNEDWINDOW_TYPE){
                references = &((wxNonOwnedWindow_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTOPLEVELWINDOW_TYPE) && (!reference_type_found)){
                references = &((wxTopLevelWindow_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFRAME_TYPE) && (!reference_type_found)){
                references = &((wxFrame_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXSPLASHSCREEN_TYPE) && (!reference_type_found)){
                references = &((wxSplashScreen_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXMDICHILDFRAME_TYPE) && (!reference_type_found)){
                references = &((wxMDIChildFrame_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXMDIPARENTFRAME_TYPE) && (!reference_type_found)){
                references = &((wxMDIParentFrame_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXMINIFRAME_TYPE) && (!reference_type_found)){
                references = &((wxMiniFrame_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXPREVIEWFRAME_TYPE) && (!reference_type_found)){
                references = &((wxPreviewFrame_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXHTMLHELPDIALOG_TYPE) && (!reference_type_found)){
                references = &((wxHtmlHelpDialog_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXHTMLHELPFRAME_TYPE) && (!reference_type_found)){
                references = &((wxHtmlHelpFrame_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXDIALOG_TYPE) && (!reference_type_found)){
                references = &((wxDialog_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTEXTENTRYDIALOG_TYPE) && (!reference_type_found)){
                references = &((wxTextEntryDialog_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXPASSWORDENTRYDIALOG_TYPE) && (!reference_type_found)){
                references = &((wxPasswordEntryDialog_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXMESSAGEDIALOG_TYPE) && (!reference_type_found)){
                references = &((wxMessageDialog_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFINDREPLACEDIALOG_TYPE) && (!reference_type_found)){
                references = &((wxFindReplaceDialog_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXDIRDIALOG_TYPE) && (!reference_type_found)){
                references = &((wxDirDialog_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXSYMBOLPICKERDIALOG_TYPE) && (!reference_type_found)){
                references = &((wxSymbolPickerDialog_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXPROPERTYSHEETDIALOG_TYPE) && (!reference_type_found)){
                references = &((wxPropertySheetDialog_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXWIZARD_TYPE) && (!reference_type_found)){
                references = &((wxWizard_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXPROGRESSDIALOG_TYPE) && (!reference_type_found)){
                references = &((wxProgressDialog_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXCOLOURDIALOG_TYPE) && (!reference_type_found)){
                references = &((wxColourDialog_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEDIALOG_TYPE) && (!reference_type_found)){
                references = &((wxFileDialog_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFONTDIALOG_TYPE) && (!reference_type_found)){
                references = &((wxFontDialog_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXSINGLECHOICEDIALOG_TYPE) && (!reference_type_found)){
                references = &((wxSingleChoiceDialog_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXGENERICPROGRESSDIALOG_TYPE) && (!reference_type_found)){
                references = &((wxGenericProgressDialog_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXPOPUPWINDOW_TYPE) && (!reference_type_found)){
                references = &((wxPopupWindow_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXPOPUPTRANSIENTWINDOW_TYPE) && (!reference_type_found)){
                references = &((wxPopupTransientWindow_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* region0;
    wxRegion* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&region0, php_wxRegion_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &region0, php_wxRegion_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(region0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxRegion_P(region0)->object_type;
                    argument_native_object = (void*) Z_wxRegion_P(region0)->native_object;
                    object_pointer0_0 = (wxRegion*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'region' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(region0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'region' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxNonOwnedWindow::SetShape(*(wxRegion*) object_pointer0_0))\n\n");
                #endif

                if(current_object_type == PHP_WXTOPLEVELWINDOW_TYPE)
                {
                    RETVAL_BOOL(((wxTopLevelWindow_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXFRAME_TYPE)
                {
                    RETVAL_BOOL(((wxFrame_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXSPLASHSCREEN_TYPE)
                {
                    RETVAL_BOOL(((wxSplashScreen_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXMDICHILDFRAME_TYPE)
                {
                    RETVAL_BOOL(((wxMDIChildFrame_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXMDIPARENTFRAME_TYPE)
                {
                    RETVAL_BOOL(((wxMDIParentFrame_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXMINIFRAME_TYPE)
                {
                    RETVAL_BOOL(((wxMiniFrame_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXPREVIEWFRAME_TYPE)
                {
                    RETVAL_BOOL(((wxPreviewFrame_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXHTMLHELPDIALOG_TYPE)
                {
                    RETVAL_BOOL(((wxHtmlHelpDialog_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXHTMLHELPFRAME_TYPE)
                {
                    RETVAL_BOOL(((wxHtmlHelpFrame_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXDIALOG_TYPE)
                {
                    RETVAL_BOOL(((wxDialog_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXTEXTENTRYDIALOG_TYPE)
                {
                    RETVAL_BOOL(((wxTextEntryDialog_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXPASSWORDENTRYDIALOG_TYPE)
                {
                    RETVAL_BOOL(((wxPasswordEntryDialog_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXMESSAGEDIALOG_TYPE)
                {
                    RETVAL_BOOL(((wxMessageDialog_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXFINDREPLACEDIALOG_TYPE)
                {
                    RETVAL_BOOL(((wxFindReplaceDialog_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXDIRDIALOG_TYPE)
                {
                    RETVAL_BOOL(((wxDirDialog_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXSYMBOLPICKERDIALOG_TYPE)
                {
                    RETVAL_BOOL(((wxSymbolPickerDialog_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXPROPERTYSHEETDIALOG_TYPE)
                {
                    RETVAL_BOOL(((wxPropertySheetDialog_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXWIZARD_TYPE)
                {
                    RETVAL_BOOL(((wxWizard_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXPROGRESSDIALOG_TYPE)
                {
                    RETVAL_BOOL(((wxProgressDialog_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXCOLOURDIALOG_TYPE)
                {
                    RETVAL_BOOL(((wxColourDialog_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXFILEDIALOG_TYPE)
                {
                    RETVAL_BOOL(((wxFileDialog_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXFONTDIALOG_TYPE)
                {
                    RETVAL_BOOL(((wxFontDialog_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXSINGLECHOICEDIALOG_TYPE)
                {
                    RETVAL_BOOL(((wxSingleChoiceDialog_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXGENERICPROGRESSDIALOG_TYPE)
                {
                    RETVAL_BOOL(((wxGenericProgressDialog_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXPOPUPWINDOW_TYPE)
                {
                    RETVAL_BOOL(((wxPopupWindow_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXPOPUPTRANSIENTWINDOW_TYPE)
                {
                    RETVAL_BOOL(((wxPopupTransientWindow_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }
                else if(current_object_type == PHP_WXNONOWNEDWINDOW_TYPE)
                {
                    RETVAL_BOOL(((wxNonOwnedWindow_php*)native_object)->SetShape(*(wxRegion*) object_pointer0_0));
                }

                references->AddReference(region0, "wxNonOwnedWindow::SetShape at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNonOwnedWindow::SetShape\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxAnyButton_free(void *object)
{
    zo_wxAnyButton* custom_object = (zo_wxAnyButton*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Obviate delete call for wxAnyButton on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n\n");
    #endif

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxAnyButton_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxAnyButton_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxAnyButton* custom_object;

    custom_object = (zo_wxAnyButton*) ecalloc(
        1,
        sizeof(zo_wxAnyButton)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxAnyButton_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXANYBUTTON_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxAnyButton::wxAnyButton() */
PHP_METHOD(php_wxAnyButton, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxAnyButton::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxAnyButton* current_object;
    wxAnyButton_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxAnyButton_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxAnyButton_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxAnyButton::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto wxBitmap wxAnyButton::GetBitmap()
   Return the bitmap shown by the button. */
PHP_METHOD(php_wxAnyButton, GetBitmap)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxAnyButton::GetBitmap\n");
    php_printf("===========================================\n");
    #endif

    zo_wxAnyButton* current_object;
    wxphp_object_type current_object_type;
    wxAnyButton_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxAnyButton_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxAnyButton::GetBitmap call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXANYBUTTON_TYPE){
                references = &((wxAnyButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxAnyButton::GetBitmap() to return new object\n\n");
                #endif

                wxBitmap value_to_return0;
                value_to_return0 = ((wxAnyButton_php*)native_object)->GetBitmap();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxBitmap));
                object_init_ex(return_value, php_wxBitmap_entry);
                ((wxBitmap_php*)ptr)->phpObj = *return_value;
                zo_wxBitmap* zo0 = Z_wxBitmap_P(return_value);
                zo0->native_object = (wxBitmap_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxAnyButton::GetBitmap\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmap wxAnyButton::GetBitmapCurrent()
   Returns the bitmap used when the mouse is over the button, which may be invalid. */
PHP_METHOD(php_wxAnyButton, GetBitmapCurrent)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxAnyButton::GetBitmapCurrent\n");
    php_printf("===========================================\n");
    #endif

    zo_wxAnyButton* current_object;
    wxphp_object_type current_object_type;
    wxAnyButton_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxAnyButton_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxAnyButton::GetBitmapCurrent call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXANYBUTTON_TYPE){
                references = &((wxAnyButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxAnyButton::GetBitmapCurrent() to return new object\n\n");
                #endif

                wxBitmap value_to_return0;
                value_to_return0 = ((wxAnyButton_php*)native_object)->GetBitmapCurrent();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxBitmap));
                object_init_ex(return_value, php_wxBitmap_entry);
                ((wxBitmap_php*)ptr)->phpObj = *return_value;
                zo_wxBitmap* zo0 = Z_wxBitmap_P(return_value);
                zo0->native_object = (wxBitmap_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxAnyButton::GetBitmapCurrent\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmap wxAnyButton::GetBitmapDisabled()
   Returns the bitmap for the disabled state, which may be invalid. */
PHP_METHOD(php_wxAnyButton, GetBitmapDisabled)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxAnyButton::GetBitmapDisabled\n");
    php_printf("===========================================\n");
    #endif

    zo_wxAnyButton* current_object;
    wxphp_object_type current_object_type;
    wxAnyButton_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxAnyButton_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxAnyButton::GetBitmapDisabled call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXANYBUTTON_TYPE){
                references = &((wxAnyButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxAnyButton::GetBitmapDisabled() to return new object\n\n");
                #endif

                wxBitmap value_to_return0;
                value_to_return0 = ((wxAnyButton_php*)native_object)->GetBitmapDisabled();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxBitmap));
                object_init_ex(return_value, php_wxBitmap_entry);
                ((wxBitmap_php*)ptr)->phpObj = *return_value;
                zo_wxBitmap* zo0 = Z_wxBitmap_P(return_value);
                zo0->native_object = (wxBitmap_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxAnyButton::GetBitmapDisabled\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmap wxAnyButton::GetBitmapFocus()
   Returns the bitmap for the focused state, which may be invalid. */
PHP_METHOD(php_wxAnyButton, GetBitmapFocus)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxAnyButton::GetBitmapFocus\n");
    php_printf("===========================================\n");
    #endif

    zo_wxAnyButton* current_object;
    wxphp_object_type current_object_type;
    wxAnyButton_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxAnyButton_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxAnyButton::GetBitmapFocus call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXANYBUTTON_TYPE){
                references = &((wxAnyButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxAnyButton::GetBitmapFocus() to return new object\n\n");
                #endif

                wxBitmap value_to_return0;
                value_to_return0 = ((wxAnyButton_php*)native_object)->GetBitmapFocus();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxBitmap));
                object_init_ex(return_value, php_wxBitmap_entry);
                ((wxBitmap_php*)ptr)->phpObj = *return_value;
                zo_wxBitmap* zo0 = Z_wxBitmap_P(return_value);
                zo0->native_object = (wxBitmap_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxAnyButton::GetBitmapFocus\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmap wxAnyButton::GetBitmapLabel()
   Returns the bitmap for the normal state. */
PHP_METHOD(php_wxAnyButton, GetBitmapLabel)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxAnyButton::GetBitmapLabel\n");
    php_printf("===========================================\n");
    #endif

    zo_wxAnyButton* current_object;
    wxphp_object_type current_object_type;
    wxAnyButton_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxAnyButton_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxAnyButton::GetBitmapLabel call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXANYBUTTON_TYPE){
                references = &((wxAnyButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxAnyButton::GetBitmapLabel() to return new object\n\n");
                #endif

                wxBitmap value_to_return0;
                value_to_return0 = ((wxAnyButton_php*)native_object)->GetBitmapLabel();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxBitmap));
                object_init_ex(return_value, php_wxBitmap_entry);
                ((wxBitmap_php*)ptr)->phpObj = *return_value;
                zo_wxBitmap* zo0 = Z_wxBitmap_P(return_value);
                zo0->native_object = (wxBitmap_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxAnyButton::GetBitmapLabel\n"
        );
    }
}
/* }}} */

/* {{{ proto wxSize wxAnyButton::GetBitmapMargins()
   Get the margins between the bitmap and the text of the button. */
PHP_METHOD(php_wxAnyButton, GetBitmapMargins)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxAnyButton::GetBitmapMargins\n");
    php_printf("===========================================\n");
    #endif

    zo_wxAnyButton* current_object;
    wxphp_object_type current_object_type;
    wxAnyButton_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxAnyButton_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxAnyButton::GetBitmapMargins call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXANYBUTTON_TYPE){
                references = &((wxAnyButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxAnyButton::GetBitmapMargins() to return new object\n\n");
                #endif

                wxSize value_to_return0;
                value_to_return0 = ((wxAnyButton_php*)native_object)->GetBitmapMargins();
                void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxSize));
                object_init_ex(return_value, php_wxSize_entry);
                ((wxSize_php*)ptr)->phpObj = *return_value;
                zo_wxSize* zo0 = Z_wxSize_P(return_value);
                zo0->native_object = (wxSize_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxAnyButton::GetBitmapMargins\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmap wxAnyButton::GetBitmapPressed()
   Returns the bitmap for the pressed state, which may be invalid. */
PHP_METHOD(php_wxAnyButton, GetBitmapPressed)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxAnyButton::GetBitmapPressed\n");
    php_printf("===========================================\n");
    #endif

    zo_wxAnyButton* current_object;
    wxphp_object_type current_object_type;
    wxAnyButton_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxAnyButton_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxAnyButton::GetBitmapPressed call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXANYBUTTON_TYPE){
                references = &((wxAnyButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxAnyButton::GetBitmapPressed() to return new object\n\n");
                #endif

                wxBitmap value_to_return0;
                value_to_return0 = ((wxAnyButton_php*)native_object)->GetBitmapPressed();
                ((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
                void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxBitmap));
                object_init_ex(return_value, php_wxBitmap_entry);
                ((wxBitmap_php*)ptr)->phpObj = *return_value;
                zo_wxBitmap* zo0 = Z_wxBitmap_P(return_value);
                zo0->native_object = (wxBitmap_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxAnyButton::GetBitmapPressed\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxAnyButton::SetBitmap(wxBitmap bitmap, wxDirection dir)
   Sets the bitmap to display in the button. */
PHP_METHOD(php_wxAnyButton, SetBitmap)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxAnyButton::SetBitmap\n");
    php_printf("===========================================\n");
    #endif

    zo_wxAnyButton* current_object;
    wxphp_object_type current_object_type;
    wxAnyButton_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxAnyButton_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxAnyButton::SetBitmap call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXANYBUTTON_TYPE){
                references = &((wxAnyButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* bitmap0;
    wxBitmap* object_pointer0_0 = 0;
    long dir0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O|l' (&bitmap0, php_wxBitmap_entry, &dir0)\n");
        #endif

        char parse_parameters_string[] = "O|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap0, php_wxBitmap_entry, &dir0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap0)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap0)->native_object;
                    object_pointer0_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(bitmap0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxAnyButton::SetBitmap(*(wxBitmap*) object_pointer0_0)\n\n");
                #endif

                ((wxAnyButton_php*)native_object)->SetBitmap(*(wxBitmap*) object_pointer0_0);

                references->AddReference(bitmap0, "wxAnyButton::SetBitmap at call 3 with 1 argument(s)");

                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxAnyButton::SetBitmap(*(wxBitmap*) object_pointer0_0, (wxDirection) dir0)\n\n");
                #endif

                ((wxAnyButton_php*)native_object)->SetBitmap(*(wxBitmap*) object_pointer0_0, (wxDirection) dir0);

                references->AddReference(bitmap0, "wxAnyButton::SetBitmap at call 3 with 2 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxAnyButton::SetBitmap\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxAnyButton::SetBitmapCurrent(wxBitmap bitmap)
   Sets the bitmap to be shown when the mouse is over the button. */
PHP_METHOD(php_wxAnyButton, SetBitmapCurrent)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxAnyButton::SetBitmapCurrent\n");
    php_printf("===========================================\n");
    #endif

    zo_wxAnyButton* current_object;
    wxphp_object_type current_object_type;
    wxAnyButton_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxAnyButton_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxAnyButton::SetBitmapCurrent call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXANYBUTTON_TYPE){
                references = &((wxAnyButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* bitmap0;
    wxBitmap* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&bitmap0, php_wxBitmap_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap0)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap0)->native_object;
                    object_pointer0_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(bitmap0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxAnyButton::SetBitmapCurrent(*(wxBitmap*) object_pointer0_0)\n\n");
                #endif

                ((wxAnyButton_php*)native_object)->SetBitmapCurrent(*(wxBitmap*) object_pointer0_0);

                references->AddReference(bitmap0, "wxAnyButton::SetBitmapCurrent at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxAnyButton::SetBitmapCurrent\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxAnyButton::SetBitmapDisabled(wxBitmap bitmap)
   Sets the bitmap for the disabled button appearance. */
PHP_METHOD(php_wxAnyButton, SetBitmapDisabled)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxAnyButton::SetBitmapDisabled\n");
    php_printf("===========================================\n");
    #endif

    zo_wxAnyButton* current_object;
    wxphp_object_type current_object_type;
    wxAnyButton_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxAnyButton_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxAnyButton::SetBitmapDisabled call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXANYBUTTON_TYPE){
                references = &((wxAnyButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* bitmap0;
    wxBitmap* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&bitmap0, php_wxBitmap_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap0)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap0)->native_object;
                    object_pointer0_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(bitmap0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxAnyButton::SetBitmapDisabled(*(wxBitmap*) object_pointer0_0)\n\n");
                #endif

                ((wxAnyButton_php*)native_object)->SetBitmapDisabled(*(wxBitmap*) object_pointer0_0);

                references->AddReference(bitmap0, "wxAnyButton::SetBitmapDisabled at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxAnyButton::SetBitmapDisabled\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxAnyButton::SetBitmapFocus(wxBitmap bitmap)
   Sets the bitmap for the button appearance when it has the keyboard focus. */
PHP_METHOD(php_wxAnyButton, SetBitmapFocus)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxAnyButton::SetBitmapFocus\n");
    php_printf("===========================================\n");
    #endif

    zo_wxAnyButton* current_object;
    wxphp_object_type current_object_type;
    wxAnyButton_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxAnyButton_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxAnyButton::SetBitmapFocus call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXANYBUTTON_TYPE){
                references = &((wxAnyButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* bitmap0;
    wxBitmap* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&bitmap0, php_wxBitmap_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap0)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap0)->native_object;
                    object_pointer0_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(bitmap0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxAnyButton::SetBitmapFocus(*(wxBitmap*) object_pointer0_0)\n\n");
                #endif

                ((wxAnyButton_php*)native_object)->SetBitmapFocus(*(wxBitmap*) object_pointer0_0);

                references->AddReference(bitmap0, "wxAnyButton::SetBitmapFocus at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxAnyButton::SetBitmapFocus\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxAnyButton::SetBitmapLabel(wxBitmap bitmap)
   Sets the bitmap label for the button. */
PHP_METHOD(php_wxAnyButton, SetBitmapLabel)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxAnyButton::SetBitmapLabel\n");
    php_printf("===========================================\n");
    #endif

    zo_wxAnyButton* current_object;
    wxphp_object_type current_object_type;
    wxAnyButton_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxAnyButton_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxAnyButton::SetBitmapLabel call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXANYBUTTON_TYPE){
                references = &((wxAnyButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* bitmap0;
    wxBitmap* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&bitmap0, php_wxBitmap_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap0)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap0)->native_object;
                    object_pointer0_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(bitmap0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxAnyButton::SetBitmapLabel(*(wxBitmap*) object_pointer0_0)\n\n");
                #endif

                ((wxAnyButton_php*)native_object)->SetBitmapLabel(*(wxBitmap*) object_pointer0_0);

                references->AddReference(bitmap0, "wxAnyButton::SetBitmapLabel at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxAnyButton::SetBitmapLabel\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxAnyButton::SetBitmapMargins(wxSize sz)
   Set the margins between the bitmap and the text of the button. */
PHP_METHOD(php_wxAnyButton, SetBitmapMargins)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxAnyButton::SetBitmapMargins\n");
    php_printf("===========================================\n");
    #endif

    zo_wxAnyButton* current_object;
    wxphp_object_type current_object_type;
    wxAnyButton_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxAnyButton_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxAnyButton::SetBitmapMargins call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXANYBUTTON_TYPE){
                references = &((wxAnyButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* sz0;
    wxSize* object_pointer0_0 = 0;
    bool overload0_called = false;

    //Parameters for overload 1
    long x1;
    long y1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&sz0, php_wxSize_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &sz0, php_wxSize_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(sz0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(sz0)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(sz0)->native_object;
                    object_pointer0_0 = (wxSize*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        goto overload1;
                    }
                }
                else if(Z_TYPE_P(sz0) != IS_NULL)
                {
                    goto overload1;
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (&x1, &y1)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &x1, &y1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxAnyButton::SetBitmapMargins(*(wxSize*) object_pointer0_0)\n\n");
                #endif

                ((wxAnyButton_php*)native_object)->SetBitmapMargins(*(wxSize*) object_pointer0_0);

                references->AddReference(sz0, "wxAnyButton::SetBitmapMargins at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxAnyButton::SetBitmapMargins((wxCoord) x1, (wxCoord) y1)\n\n");
                #endif

                ((wxAnyButton_php*)native_object)->SetBitmapMargins((wxCoord) x1, (wxCoord) y1);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxAnyButton::SetBitmapMargins\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxAnyButton::SetBitmapPosition(wxDirection dir)
   Set the position at which the bitmap is displayed. */
PHP_METHOD(php_wxAnyButton, SetBitmapPosition)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxAnyButton::SetBitmapPosition\n");
    php_printf("===========================================\n");
    #endif

    zo_wxAnyButton* current_object;
    wxphp_object_type current_object_type;
    wxAnyButton_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxAnyButton_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxAnyButton::SetBitmapPosition call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXANYBUTTON_TYPE){
                references = &((wxAnyButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long dir0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&dir0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &dir0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxAnyButton::SetBitmapPosition((wxDirection) dir0)\n\n");
                #endif

                ((wxAnyButton_php*)native_object)->SetBitmapPosition((wxDirection) dir0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxAnyButton::SetBitmapPosition\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxAnyButton::SetBitmapPressed(wxBitmap bitmap)
   Sets the bitmap for the selected (depressed) button appearance. */
PHP_METHOD(php_wxAnyButton, SetBitmapPressed)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxAnyButton::SetBitmapPressed\n");
    php_printf("===========================================\n");
    #endif

    zo_wxAnyButton* current_object;
    wxphp_object_type current_object_type;
    wxAnyButton_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxAnyButton_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxAnyButton::SetBitmapPressed call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXANYBUTTON_TYPE){
                references = &((wxAnyButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
                references = &((wxBitmapToggleButton_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* bitmap0;
    wxBitmap* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&bitmap0, php_wxBitmap_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bitmap0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bitmap0)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bitmap0)->native_object;
                    object_pointer0_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(bitmap0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxAnyButton::SetBitmapPressed(*(wxBitmap*) object_pointer0_0)\n\n");
                #endif

                ((wxAnyButton_php*)native_object)->SetBitmapPressed(*(wxBitmap*) object_pointer0_0);

                references->AddReference(bitmap0, "wxAnyButton::SetBitmapPressed at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxAnyButton::SetBitmapPressed\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxWithImages_free(void *object)
{
    zo_wxWithImages* custom_object = (zo_wxWithImages*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxWithImages_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxWithImages done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxWithImages_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxWithImages_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxWithImages* custom_object;

    custom_object = (zo_wxWithImages*) ecalloc(
        1,
        sizeof(zo_wxWithImages)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxWithImages_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXWITHIMAGES_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxWithImages::wxWithImages() */
PHP_METHOD(php_wxWithImages, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxWithImages::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxWithImages* current_object;
    wxWithImages_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxWithImages_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxWithImages_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxWithImages::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto  wxWithImages::SetImageList(wxImageList &imageList)
   Sets the image list to use. */
PHP_METHOD(php_wxWithImages, SetImageList)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxWithImages::SetImageList\n");
    php_printf("===========================================\n");
    #endif

    zo_wxWithImages* current_object;
    wxphp_object_type current_object_type;
    wxWithImages_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxWithImages_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxWithImages::SetImageList call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXWITHIMAGES_TYPE){
                references = &((wxWithImages_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBOOKCTRLBASE_TYPE) && (!reference_type_found)){
                references = &((wxBookCtrlBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXAUINOTEBOOK_TYPE) && (!reference_type_found)){
                references = &((wxAuiNotebook_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXLISTBOOK_TYPE) && (!reference_type_found)){
                references = &((wxListbook_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXCHOICEBOOK_TYPE) && (!reference_type_found)){
                references = &((wxChoicebook_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXNOTEBOOK_TYPE) && (!reference_type_found)){
                references = &((wxNotebook_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTREEBOOK_TYPE) && (!reference_type_found)){
                references = &((wxTreebook_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTOOLBOOK_TYPE) && (!reference_type_found)){
                references = &((wxToolbook_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* imageList0;
    wxImageList* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&imageList0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &imageList0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(imageList0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxImageList_P(imageList0)->object_type;
                    argument_native_object = (void*) Z_wxImageList_P(imageList0)->native_object;
                    object_pointer0_0 = (wxImageList*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXIMAGELIST_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'imageList' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(imageList0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'imageList' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxWithImages::SetImageList((wxImageList*) object_pointer0_0)\n\n");
                #endif

                ((wxWithImages_php*)native_object)->SetImageList((wxImageList*) object_pointer0_0);

                references->AddReference(imageList0, "wxWithImages::SetImageList at call 1 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxWithImages::SetImageList\n"
        );
    }
}
/* }}} */

/* {{{ proto wxImageList wxWithImages::GetImageList()
   Returns the associated image list, may be NULL. */
PHP_METHOD(php_wxWithImages, GetImageList)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxWithImages::GetImageList\n");
    php_printf("===========================================\n");
    #endif

    zo_wxWithImages* current_object;
    wxphp_object_type current_object_type;
    wxWithImages_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxWithImages_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxWithImages::GetImageList call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXWITHIMAGES_TYPE){
                references = &((wxWithImages_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBOOKCTRLBASE_TYPE) && (!reference_type_found)){
                references = &((wxBookCtrlBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXAUINOTEBOOK_TYPE) && (!reference_type_found)){
                references = &((wxAuiNotebook_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXLISTBOOK_TYPE) && (!reference_type_found)){
                references = &((wxListbook_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXCHOICEBOOK_TYPE) && (!reference_type_found)){
                references = &((wxChoicebook_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXNOTEBOOK_TYPE) && (!reference_type_found)){
                references = &((wxNotebook_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTREEBOOK_TYPE) && (!reference_type_found)){
                references = &((wxTreebook_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTOOLBOOK_TYPE) && (!reference_type_found)){
                references = &((wxToolbook_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxWithImages::GetImageList() to return object pointer\n\n");
                #endif

                wxImageList_php* value_to_return0;
                value_to_return0 = (wxImageList_php*) ((wxWithImages_php*)native_object)->GetImageList();

                if(value_to_return0 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxImageList_entry);
                    Z_wxImageList_P(return_value)->native_object = (wxImageList_php*) value_to_return0;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxWithImages::GetImageList at call 5 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxWithImages::GetImageList\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxWithImages::AssignImageList(wxImageList &imageList)
   Sets the image list for the page control and takes ownership of the list. */
PHP_METHOD(php_wxWithImages, AssignImageList)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxWithImages::AssignImageList\n");
    php_printf("===========================================\n");
    #endif

    zo_wxWithImages* current_object;
    wxphp_object_type current_object_type;
    wxWithImages_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxWithImages_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxWithImages::AssignImageList call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXWITHIMAGES_TYPE){
                references = &((wxWithImages_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXBOOKCTRLBASE_TYPE) && (!reference_type_found)){
                references = &((wxBookCtrlBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXAUINOTEBOOK_TYPE) && (!reference_type_found)){
                references = &((wxAuiNotebook_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXLISTBOOK_TYPE) && (!reference_type_found)){
                references = &((wxListbook_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXCHOICEBOOK_TYPE) && (!reference_type_found)){
                references = &((wxChoicebook_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXNOTEBOOK_TYPE) && (!reference_type_found)){
                references = &((wxNotebook_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTREEBOOK_TYPE) && (!reference_type_found)){
                references = &((wxTreebook_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXTOOLBOOK_TYPE) && (!reference_type_found)){
                references = &((wxToolbook_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* imageList0;
    wxImageList* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&imageList0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &imageList0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(imageList0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxImageList_P(imageList0)->object_type;
                    argument_native_object = (void*) Z_wxImageList_P(imageList0)->native_object;
                    object_pointer0_0 = (wxImageList*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXIMAGELIST_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'imageList' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(imageList0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'imageList' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxWithImages::AssignImageList((wxImageList*) object_pointer0_0)\n\n");
                #endif

                ((wxWithImages_php*)native_object)->AssignImageList((wxImageList*) object_pointer0_0);

                references->AddReference(imageList0, "wxWithImages::AssignImageList at call 1 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxWithImages::AssignImageList\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxTextCompleter_free(void *object)
{
    zo_wxTextCompleter* custom_object = (zo_wxTextCompleter*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxTextCompleter_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxTextCompleter done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxTextCompleter_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxTextCompleter_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxTextCompleter* custom_object;

    custom_object = (zo_wxTextCompleter*) ecalloc(
        1,
        sizeof(zo_wxTextCompleter)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxTextCompleter_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXTEXTCOMPLETER_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto string wxTextCompleter::GetNext()
   Called to retrieve the next completion. */
wxString wxTextCompleter_php::GetNext()
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxTextCompleter::GetNext\n");
    php_printf("===========================================\n");
    #endif

    zval* params[1];
    zval arguments[1];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "GetNext");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "GetNext");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "GetNext",
            7,
            &function_return_value,
            0,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxTextCompleter::GetNext'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return wxString(Z_STRVAL(function_return_value), wxConvUTF8);

}
/* }}} */

/* {{{ proto bool wxTextCompleter::Start(string prefix)
   Function called to start iteration over the completions for the given prefix. */
bool wxTextCompleter_php::Start(const wxString& prefix)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxTextCompleter::Start\n");
    php_printf("===========================================\n");
    #endif

    zval* params[1];
    zval arguments[1];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "Start");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    ZVAL_STRING(&arguments[0], prefix.ToUTF8().data());
    
    for(int i=0; i<1; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "Start");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "Start",
            5,
            &function_return_value,
            1,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<1; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxTextCompleter::Start'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return Z_TYPE(function_return_value) == IS_TRUE;

}
/* }}} */

BEGIN_EXTERN_C()
void php_wxWindowModalDialogEvent_free(void *object)
{
    zo_wxWindowModalDialogEvent* custom_object = (zo_wxWindowModalDialogEvent*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxWindowModalDialogEvent_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxWindowModalDialogEvent done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxWindowModalDialogEvent_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxWindowModalDialogEvent_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxWindowModalDialogEvent* custom_object;

    custom_object = (zo_wxWindowModalDialogEvent*) ecalloc(
        1,
        sizeof(zo_wxWindowModalDialogEvent)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxWindowModalDialogEvent_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXWINDOWMODALDIALOGEVENT_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto wxEvent wxWindowModalDialogEvent::Clone()
   Clone the event. */
PHP_METHOD(php_wxWindowModalDialogEvent, CloneMethod)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxWindowModalDialogEvent::Clone\n");
    php_printf("===========================================\n");
    #endif

    zo_wxWindowModalDialogEvent* current_object;
    wxphp_object_type current_object_type;
    wxWindowModalDialogEvent_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxWindowModalDialogEvent_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxWindowModalDialogEvent::Clone call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXWINDOWMODALDIALOGEVENT_TYPE){
                references = &((wxWindowModalDialogEvent_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxWindowModalDialogEvent::Clone() to return object pointer\n\n");
                #endif

                wxEvent_php* value_to_return0;
                value_to_return0 = (wxEvent_php*) ((wxWindowModalDialogEvent_php*)native_object)->Clone();

                if(value_to_return0 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxEvent_entry);
                    Z_wxEvent_P(return_value)->native_object = (wxEvent_php*) value_to_return0;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxWindowModalDialogEvent::Clone at call 5 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxWindowModalDialogEvent::Clone\n"
        );
    }
}
/* }}} */

/* {{{ proto wxDialog wxWindowModalDialogEvent::GetDialog()
   Return the corresponding dialog. */
PHP_METHOD(php_wxWindowModalDialogEvent, GetDialog)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxWindowModalDialogEvent::GetDialog\n");
    php_printf("===========================================\n");
    #endif

    zo_wxWindowModalDialogEvent* current_object;
    wxphp_object_type current_object_type;
    wxWindowModalDialogEvent_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxWindowModalDialogEvent_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxWindowModalDialogEvent::GetDialog call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXWINDOWMODALDIALOGEVENT_TYPE){
                references = &((wxWindowModalDialogEvent_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxWindowModalDialogEvent::GetDialog() to return object pointer\n\n");
                #endif

                wxDialog_php* value_to_return0;
                value_to_return0 = (wxDialog_php*) ((wxWindowModalDialogEvent_php*)native_object)->GetDialog();

                if(value_to_return0 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxDialog_entry);
                    Z_wxDialog_P(return_value)->native_object = (wxDialog_php*) value_to_return0;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxWindowModalDialogEvent::GetDialog at call 5 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxWindowModalDialogEvent::GetDialog\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxWindowModalDialogEvent::GetReturnCode()
   Return the dialog's return code. */
PHP_METHOD(php_wxWindowModalDialogEvent, GetReturnCode)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxWindowModalDialogEvent::GetReturnCode\n");
    php_printf("===========================================\n");
    #endif

    zo_wxWindowModalDialogEvent* current_object;
    wxphp_object_type current_object_type;
    wxWindowModalDialogEvent_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxWindowModalDialogEvent_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxWindowModalDialogEvent::GetReturnCode call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXWINDOWMODALDIALOGEVENT_TYPE){
                references = &((wxWindowModalDialogEvent_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxWindowModalDialogEvent::GetReturnCode())\n\n");
                #endif

                RETVAL_LONG(((wxWindowModalDialogEvent_php*)native_object)->GetReturnCode());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxWindowModalDialogEvent::GetReturnCode\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxWindowModalDialogEvent::wxWindowModalDialogEvent(int commandType, int id)
   Constructor. */
PHP_METHOD(php_wxWindowModalDialogEvent, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxWindowModalDialogEvent::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxWindowModalDialogEvent* current_object;
    wxWindowModalDialogEvent_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    long commandType0;
    long id0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|ll' (&commandType0, &id0)\n");
        #endif

        char parse_parameters_string[] = "|ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &commandType0, &id0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxWindowModalDialogEvent_php();

                native_object->references.Initialize();
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxEventType) commandType0)\n");
                #endif

                native_object = new wxWindowModalDialogEvent_php((wxEventType) commandType0);

                native_object->references.Initialize();
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxEventType) commandType0, (int) id0)\n");
                #endif

                native_object = new wxWindowModalDialogEvent_php((wxEventType) commandType0, (int) id0);

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxWindowModalDialogEvent_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxWindowModalDialogEvent::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxPoint2DDouble_free(void *object)
{
    zo_wxPoint2DDouble* custom_object = (zo_wxPoint2DDouble*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxPoint2DDouble_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            custom_object->native_object->UninitProperties();
            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxPoint2DDouble done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxPoint2DDouble_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxPoint2DDouble_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DDouble* custom_object;

    custom_object = (zo_wxPoint2DDouble*) ecalloc(
        1,
        sizeof(zo_wxPoint2DDouble)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxPoint2DDouble_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXPOINT2DDOUBLE_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxPoint2DDouble::wxPoint2DDouble() */
PHP_METHOD(php_wxPoint2DDouble, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DDouble::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DDouble* current_object;
    wxPoint2DDouble_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    double x1;
    double y1;
    bool overload1_called = false;

    //Parameters for overload 2
    zval* pt2;
    wxPoint2DDouble* object_pointer2_0 = 0;
    bool overload2_called = false;

    //Parameters for overload 3
    zval* pt3;
    wxPoint2DInt* object_pointer3_0 = 0;
    bool overload3_called = false;

    //Parameters for overload 4
    zval* pt4;
    wxPoint* object_pointer4_0 = 0;
    bool overload4_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'dd' (&x1, &y1)\n");
        #endif

        char parse_parameters_string[] = "dd";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &x1, &y1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&pt2, php_wxPoint2DDouble_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pt2, php_wxPoint2DDouble_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(pt2) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPoint2DDouble_P(pt2)->object_type;
                    argument_native_object = (void*) Z_wxPoint2DDouble_P(pt2)->native_object;
                    object_pointer2_0 = (wxPoint2DDouble*) argument_native_object;
                    if (!object_pointer2_0 )
                    {
                        goto overload3;
                    }
                }
                else if(Z_TYPE_P(pt2) != IS_NULL)
                {
                    goto overload3;
                }
            }

            overload2_called = true;
            already_called = true;
        }
    }

    //Overload 3
    overload3:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&pt3, php_wxPoint2DInt_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pt3, php_wxPoint2DInt_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(pt3) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPoint2DInt_P(pt3)->object_type;
                    argument_native_object = (void*) Z_wxPoint2DInt_P(pt3)->native_object;
                    object_pointer3_0 = (wxPoint2DInt*) argument_native_object;
                    if (!object_pointer3_0 )
                    {
                        goto overload4;
                    }
                }
                else if(Z_TYPE_P(pt3) != IS_NULL)
                {
                    goto overload4;
                }
            }

            overload3_called = true;
            already_called = true;
        }
    }

    //Overload 4
    overload4:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&pt4, php_wxPoint_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pt4, php_wxPoint_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(pt4) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPoint_P(pt4)->object_type;
                    argument_native_object = (void*) Z_wxPoint_P(pt4)->native_object;
                    object_pointer4_0 = (wxPoint*) argument_native_object;
                    if (!object_pointer4_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'pt' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(pt4) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'pt' not null, could not be retreived correctly.");
                }
            }

            overload4_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxPoint2DDouble_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(x1, y1)\n");
                #endif

                native_object = new wxPoint2DDouble_php(x1, y1);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxPoint2DDouble*) object_pointer2_0)\n");
                #endif

                native_object = new wxPoint2DDouble_php(*(wxPoint2DDouble*) object_pointer2_0);

                native_object->references.Initialize();
                ((wxPoint2DDouble_php*) native_object)->references.AddReference(pt2, "wxPoint2DDouble::wxPoint2DDouble at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    if(overload3_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxPoint2DInt*) object_pointer3_0)\n");
                #endif

                native_object = new wxPoint2DDouble_php(*(wxPoint2DInt*) object_pointer3_0);

                native_object->references.Initialize();
                ((wxPoint2DDouble_php*) native_object)->references.AddReference(pt3, "wxPoint2DDouble::wxPoint2DDouble at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    if(overload4_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxPoint*) object_pointer4_0)\n");
                #endif

                native_object = new wxPoint2DDouble_php(*(wxPoint*) object_pointer4_0);

                native_object->references.Initialize();
                ((wxPoint2DDouble_php*) native_object)->references.AddReference(pt4, "wxPoint2DDouble::wxPoint2DDouble at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();

        native_object->InitProperties();

        current_object = Z_wxPoint2DDouble_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxPoint2DDouble::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

PHP_METHOD(php_wxPoint2DDouble, __get)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DDouble::__get\n");
    php_printf("===========================================\n");
    #endif

    int arguments_received = ZEND_NUM_ARGS();
    zo_wxPoint2DDouble* current_object;
    wxPoint2DDouble_php* native_object;

    char* name;
    size_t name_len;

    //Get native object of the php object that called the method
    if (getThis() != NULL)
    {
        current_object = Z_wxPoint2DDouble_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DDouble::wxPoint2DDouble call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
        }
    }
    else
    {
        zend_error(E_ERROR, "Could not process __get call as static\n");
    }

    char parse_parameters_string[] = "s";

    if(
        zend_parse_parameters_ex(
            ZEND_PARSE_PARAMS_QUIET,
            arguments_received,
            parse_parameters_string,
            &name,
            &name_len
        ) == FAILURE
    )
    {
        RETVAL_NULL();
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Property to get: %s\n", name);
    php_printf("===========================================\n\n");
    #endif

    if(false){}
    else if(strcmp("m_x", name) == 0)
    {
        RETVAL_DOUBLE(*((wxDouble*) native_object->properties[0]));
    }
    else if(strcmp("m_y", name) == 0)
    {
        RETVAL_DOUBLE(*((wxDouble*) native_object->properties[1]));
    }
    else
    {
        RETVAL_NULL();
    }
}
/* {{{ proto  wxPoint2DDouble::SetVectorLength(float length) */
PHP_METHOD(php_wxPoint2DDouble, SetVectorLength)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DDouble::SetVectorLength\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DDouble* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DDouble_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DDouble_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DDouble::SetVectorLength call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
                references = &((wxPoint2DDouble_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    double length0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'd' (&length0)\n");
        #endif

        char parse_parameters_string[] = "d";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &length0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPoint2DDouble::SetVectorLength(length0)\n\n");
                #endif

                ((wxPoint2DDouble_php*)native_object)->SetVectorLength(length0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DDouble::SetVectorLength\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPoint2DDouble::SetVectorAngle(float degrees) */
PHP_METHOD(php_wxPoint2DDouble, SetVectorAngle)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DDouble::SetVectorAngle\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DDouble* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DDouble_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DDouble_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DDouble::SetVectorAngle call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
                references = &((wxPoint2DDouble_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    double degrees0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'd' (&degrees0)\n");
        #endif

        char parse_parameters_string[] = "d";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &degrees0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPoint2DDouble::SetVectorAngle(degrees0)\n\n");
                #endif

                ((wxPoint2DDouble_php*)native_object)->SetVectorAngle(degrees0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DDouble::SetVectorAngle\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPoint2DDouble::Normalize() */
PHP_METHOD(php_wxPoint2DDouble, Normalize)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DDouble::Normalize\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DDouble* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DDouble_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DDouble_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DDouble::Normalize call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
                references = &((wxPoint2DDouble_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPoint2DDouble::Normalize()\n\n");
                #endif

                ((wxPoint2DDouble_php*)native_object)->Normalize();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DDouble::Normalize\n"
        );
    }
}
/* }}} */

/* {{{ proto float wxPoint2DDouble::GetVectorLength() */
PHP_METHOD(php_wxPoint2DDouble, GetVectorLength)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DDouble::GetVectorLength\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DDouble* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DDouble_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DDouble_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DDouble::GetVectorLength call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
                references = &((wxPoint2DDouble_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPoint2DDouble::GetVectorLength())\n\n");
                #endif

                RETVAL_DOUBLE(((wxPoint2DDouble_php*)native_object)->GetVectorLength());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DDouble::GetVectorLength\n"
        );
    }
}
/* }}} */

/* {{{ proto float wxPoint2DDouble::GetVectorAngle() */
PHP_METHOD(php_wxPoint2DDouble, GetVectorAngle)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DDouble::GetVectorAngle\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DDouble* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DDouble_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DDouble_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DDouble::GetVectorAngle call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
                references = &((wxPoint2DDouble_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPoint2DDouble::GetVectorAngle())\n\n");
                #endif

                RETVAL_DOUBLE(((wxPoint2DDouble_php*)native_object)->GetVectorAngle());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DDouble::GetVectorAngle\n"
        );
    }
}
/* }}} */

/* {{{ proto float wxPoint2DDouble::GetDotProduct(wxPoint2DDouble vec) */
PHP_METHOD(php_wxPoint2DDouble, GetDotProduct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DDouble::GetDotProduct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DDouble* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DDouble_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DDouble_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DDouble::GetDotProduct call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
                references = &((wxPoint2DDouble_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* vec0;
    wxPoint2DDouble* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&vec0, php_wxPoint2DDouble_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &vec0, php_wxPoint2DDouble_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(vec0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPoint2DDouble_P(vec0)->object_type;
                    argument_native_object = (void*) Z_wxPoint2DDouble_P(vec0)->native_object;
                    object_pointer0_0 = (wxPoint2DDouble*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'vec' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(vec0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'vec' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPoint2DDouble::GetDotProduct(*(wxPoint2DDouble*) object_pointer0_0))\n\n");
                #endif

                RETVAL_DOUBLE(((wxPoint2DDouble_php*)native_object)->GetDotProduct(*(wxPoint2DDouble*) object_pointer0_0));

                references->AddReference(vec0, "wxPoint2DDouble::GetDotProduct at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DDouble::GetDotProduct\n"
        );
    }
}
/* }}} */

/* {{{ proto float wxPoint2DDouble::GetDistanceSquare(wxPoint2DDouble pt) */
PHP_METHOD(php_wxPoint2DDouble, GetDistanceSquare)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DDouble::GetDistanceSquare\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DDouble* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DDouble_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DDouble_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DDouble::GetDistanceSquare call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
                references = &((wxPoint2DDouble_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* pt0;
    wxPoint2DDouble* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&pt0, php_wxPoint2DDouble_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pt0, php_wxPoint2DDouble_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(pt0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPoint2DDouble_P(pt0)->object_type;
                    argument_native_object = (void*) Z_wxPoint2DDouble_P(pt0)->native_object;
                    object_pointer0_0 = (wxPoint2DDouble*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'pt' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(pt0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'pt' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPoint2DDouble::GetDistanceSquare(*(wxPoint2DDouble*) object_pointer0_0))\n\n");
                #endif

                RETVAL_DOUBLE(((wxPoint2DDouble_php*)native_object)->GetDistanceSquare(*(wxPoint2DDouble*) object_pointer0_0));

                references->AddReference(pt0, "wxPoint2DDouble::GetDistanceSquare at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DDouble::GetDistanceSquare\n"
        );
    }
}
/* }}} */

/* {{{ proto float wxPoint2DDouble::GetDistance(wxPoint2DDouble pt) */
PHP_METHOD(php_wxPoint2DDouble, GetDistance)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DDouble::GetDistance\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DDouble* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DDouble_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DDouble_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DDouble::GetDistance call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
                references = &((wxPoint2DDouble_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* pt0;
    wxPoint2DDouble* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&pt0, php_wxPoint2DDouble_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pt0, php_wxPoint2DDouble_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(pt0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPoint2DDouble_P(pt0)->object_type;
                    argument_native_object = (void*) Z_wxPoint2DDouble_P(pt0)->native_object;
                    object_pointer0_0 = (wxPoint2DDouble*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'pt' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(pt0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'pt' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPoint2DDouble::GetDistance(*(wxPoint2DDouble*) object_pointer0_0))\n\n");
                #endif

                RETVAL_DOUBLE(((wxPoint2DDouble_php*)native_object)->GetDistance(*(wxPoint2DDouble*) object_pointer0_0));

                references->AddReference(pt0, "wxPoint2DDouble::GetDistance at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DDouble::GetDistance\n"
        );
    }
}
/* }}} */

/* {{{ proto float wxPoint2DDouble::GetCrossProduct(wxPoint2DDouble vec) */
PHP_METHOD(php_wxPoint2DDouble, GetCrossProduct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DDouble::GetCrossProduct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DDouble* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DDouble_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DDouble_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DDouble::GetCrossProduct call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
                references = &((wxPoint2DDouble_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* vec0;
    wxPoint2DDouble* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&vec0, php_wxPoint2DDouble_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &vec0, php_wxPoint2DDouble_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(vec0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPoint2DDouble_P(vec0)->object_type;
                    argument_native_object = (void*) Z_wxPoint2DDouble_P(vec0)->native_object;
                    object_pointer0_0 = (wxPoint2DDouble*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'vec' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(vec0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'vec' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPoint2DDouble::GetCrossProduct(*(wxPoint2DDouble*) object_pointer0_0))\n\n");
                #endif

                RETVAL_DOUBLE(((wxPoint2DDouble_php*)native_object)->GetCrossProduct(*(wxPoint2DDouble*) object_pointer0_0));

                references->AddReference(vec0, "wxPoint2DDouble::GetCrossProduct at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DDouble::GetCrossProduct\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPoint2DDouble::GetFloor(int x, int y) */
PHP_METHOD(php_wxPoint2DDouble, GetFloor)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DDouble::GetFloor\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DDouble* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DDouble_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DDouble_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DDouble::GetFloor call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
                references = &((wxPoint2DDouble_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long x0;
    long y0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &x0, &y0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPoint2DDouble::GetFloor((wxInt32*) x0, (wxInt32*) y0)\n\n");
                #endif

                ((wxPoint2DDouble_php*)native_object)->GetFloor((wxInt32*) x0, (wxInt32*) y0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DDouble::GetFloor\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPoint2DDouble::GetRounded(int x, int y) */
PHP_METHOD(php_wxPoint2DDouble, GetRounded)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DDouble::GetRounded\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DDouble* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DDouble_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DDouble_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DDouble::GetRounded call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
                references = &((wxPoint2DDouble_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long x0;
    long y0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &x0, &y0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPoint2DDouble::GetRounded((wxInt32*) x0, (wxInt32*) y0)\n\n");
                #endif

                ((wxPoint2DDouble_php*)native_object)->GetRounded((wxInt32*) x0, (wxInt32*) y0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DDouble::GetRounded\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxPoint2DInt_free(void *object)
{
    zo_wxPoint2DInt* custom_object = (zo_wxPoint2DInt*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxPoint2DInt_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            custom_object->native_object->UninitProperties();
            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxPoint2DInt done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxPoint2DInt_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxPoint2DInt_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DInt* custom_object;

    custom_object = (zo_wxPoint2DInt*) ecalloc(
        1,
        sizeof(zo_wxPoint2DInt)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxPoint2DInt_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXPOINT2DINT_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto int wxPoint2DInt::GetCrossProduct(wxPoint2DInt vec) */
PHP_METHOD(php_wxPoint2DInt, GetCrossProduct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DInt::GetCrossProduct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DInt* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DInt_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DInt_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DInt::GetCrossProduct call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DINT_TYPE){
                references = &((wxPoint2DInt_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* vec0;
    wxPoint2DInt* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&vec0, php_wxPoint2DInt_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &vec0, php_wxPoint2DInt_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(vec0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPoint2DInt_P(vec0)->object_type;
                    argument_native_object = (void*) Z_wxPoint2DInt_P(vec0)->native_object;
                    object_pointer0_0 = (wxPoint2DInt*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'vec' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(vec0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'vec' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPoint2DInt::GetCrossProduct(*(wxPoint2DInt*) object_pointer0_0))\n\n");
                #endif

                RETVAL_LONG(((wxPoint2DInt_php*)native_object)->GetCrossProduct(*(wxPoint2DInt*) object_pointer0_0));

                references->AddReference(vec0, "wxPoint2DInt::GetCrossProduct at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DInt::GetCrossProduct\n"
        );
    }
}
/* }}} */

/* {{{ proto float wxPoint2DInt::GetDistance(wxPoint2DInt pt) */
PHP_METHOD(php_wxPoint2DInt, GetDistance)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DInt::GetDistance\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DInt* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DInt_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DInt_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DInt::GetDistance call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DINT_TYPE){
                references = &((wxPoint2DInt_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* pt0;
    wxPoint2DInt* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&pt0, php_wxPoint2DInt_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pt0, php_wxPoint2DInt_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(pt0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPoint2DInt_P(pt0)->object_type;
                    argument_native_object = (void*) Z_wxPoint2DInt_P(pt0)->native_object;
                    object_pointer0_0 = (wxPoint2DInt*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'pt' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(pt0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'pt' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPoint2DInt::GetDistance(*(wxPoint2DInt*) object_pointer0_0))\n\n");
                #endif

                RETVAL_DOUBLE(((wxPoint2DInt_php*)native_object)->GetDistance(*(wxPoint2DInt*) object_pointer0_0));

                references->AddReference(pt0, "wxPoint2DInt::GetDistance at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DInt::GetDistance\n"
        );
    }
}
/* }}} */

/* {{{ proto float wxPoint2DInt::GetDistanceSquare(wxPoint2DInt pt) */
PHP_METHOD(php_wxPoint2DInt, GetDistanceSquare)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DInt::GetDistanceSquare\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DInt* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DInt_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DInt_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DInt::GetDistanceSquare call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DINT_TYPE){
                references = &((wxPoint2DInt_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* pt0;
    wxPoint2DInt* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&pt0, php_wxPoint2DInt_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pt0, php_wxPoint2DInt_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(pt0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPoint2DInt_P(pt0)->object_type;
                    argument_native_object = (void*) Z_wxPoint2DInt_P(pt0)->native_object;
                    object_pointer0_0 = (wxPoint2DInt*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'pt' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(pt0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'pt' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPoint2DInt::GetDistanceSquare(*(wxPoint2DInt*) object_pointer0_0))\n\n");
                #endif

                RETVAL_DOUBLE(((wxPoint2DInt_php*)native_object)->GetDistanceSquare(*(wxPoint2DInt*) object_pointer0_0));

                references->AddReference(pt0, "wxPoint2DInt::GetDistanceSquare at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DInt::GetDistanceSquare\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxPoint2DInt::GetDotProduct(wxPoint2DInt vec) */
PHP_METHOD(php_wxPoint2DInt, GetDotProduct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DInt::GetDotProduct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DInt* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DInt_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DInt_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DInt::GetDotProduct call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DINT_TYPE){
                references = &((wxPoint2DInt_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* vec0;
    wxPoint2DInt* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&vec0, php_wxPoint2DInt_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &vec0, php_wxPoint2DInt_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(vec0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPoint2DInt_P(vec0)->object_type;
                    argument_native_object = (void*) Z_wxPoint2DInt_P(vec0)->native_object;
                    object_pointer0_0 = (wxPoint2DInt*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'vec' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(vec0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'vec' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPoint2DInt::GetDotProduct(*(wxPoint2DInt*) object_pointer0_0))\n\n");
                #endif

                RETVAL_LONG(((wxPoint2DInt_php*)native_object)->GetDotProduct(*(wxPoint2DInt*) object_pointer0_0));

                references->AddReference(vec0, "wxPoint2DInt::GetDotProduct at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DInt::GetDotProduct\n"
        );
    }
}
/* }}} */

/* {{{ proto float wxPoint2DInt::GetVectorAngle() */
PHP_METHOD(php_wxPoint2DInt, GetVectorAngle)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DInt::GetVectorAngle\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DInt* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DInt_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DInt_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DInt::GetVectorAngle call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DINT_TYPE){
                references = &((wxPoint2DInt_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPoint2DInt::GetVectorAngle())\n\n");
                #endif

                RETVAL_DOUBLE(((wxPoint2DInt_php*)native_object)->GetVectorAngle());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DInt::GetVectorAngle\n"
        );
    }
}
/* }}} */

/* {{{ proto float wxPoint2DInt::GetVectorLength() */
PHP_METHOD(php_wxPoint2DInt, GetVectorLength)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DInt::GetVectorLength\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DInt* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DInt_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DInt_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DInt::GetVectorLength call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DINT_TYPE){
                references = &((wxPoint2DInt_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPoint2DInt::GetVectorLength())\n\n");
                #endif

                RETVAL_DOUBLE(((wxPoint2DInt_php*)native_object)->GetVectorLength());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DInt::GetVectorLength\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPoint2DInt::Normalize() */
PHP_METHOD(php_wxPoint2DInt, Normalize)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DInt::Normalize\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DInt* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DInt_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DInt_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DInt::Normalize call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DINT_TYPE){
                references = &((wxPoint2DInt_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPoint2DInt::Normalize()\n\n");
                #endif

                ((wxPoint2DInt_php*)native_object)->Normalize();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DInt::Normalize\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPoint2DInt::SetVectorAngle(float degrees) */
PHP_METHOD(php_wxPoint2DInt, SetVectorAngle)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DInt::SetVectorAngle\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DInt* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DInt_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DInt_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DInt::SetVectorAngle call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DINT_TYPE){
                references = &((wxPoint2DInt_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    double degrees0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'd' (&degrees0)\n");
        #endif

        char parse_parameters_string[] = "d";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &degrees0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPoint2DInt::SetVectorAngle(degrees0)\n\n");
                #endif

                ((wxPoint2DInt_php*)native_object)->SetVectorAngle(degrees0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DInt::SetVectorAngle\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPoint2DInt::SetVectorLength(float length) */
PHP_METHOD(php_wxPoint2DInt, SetVectorLength)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DInt::SetVectorLength\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DInt* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DInt_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DInt_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DInt::SetVectorLength call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DINT_TYPE){
                references = &((wxPoint2DInt_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    double length0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'd' (&length0)\n");
        #endif

        char parse_parameters_string[] = "d";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &length0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPoint2DInt::SetVectorLength(length0)\n\n");
                #endif

                ((wxPoint2DInt_php*)native_object)->SetVectorLength(length0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DInt::SetVectorLength\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPoint2DInt::wxPoint2DInt() */
PHP_METHOD(php_wxPoint2DInt, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DInt::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DInt* current_object;
    wxPoint2DInt_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    long x1;
    long y1;
    bool overload1_called = false;

    //Parameters for overload 2
    zval* pt2;
    wxPoint2DInt* object_pointer2_0 = 0;
    bool overload2_called = false;

    //Parameters for overload 3
    zval* pt3;
    wxPoint* object_pointer3_0 = 0;
    bool overload3_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (&x1, &y1)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &x1, &y1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&pt2, php_wxPoint2DInt_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pt2, php_wxPoint2DInt_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(pt2) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPoint2DInt_P(pt2)->object_type;
                    argument_native_object = (void*) Z_wxPoint2DInt_P(pt2)->native_object;
                    object_pointer2_0 = (wxPoint2DInt*) argument_native_object;
                    if (!object_pointer2_0 )
                    {
                        goto overload3;
                    }
                }
                else if(Z_TYPE_P(pt2) != IS_NULL)
                {
                    goto overload3;
                }
            }

            overload2_called = true;
            already_called = true;
        }
    }

    //Overload 3
    overload3:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&pt3, php_wxPoint_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pt3, php_wxPoint_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(pt3) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPoint_P(pt3)->object_type;
                    argument_native_object = (void*) Z_wxPoint_P(pt3)->native_object;
                    object_pointer3_0 = (wxPoint*) argument_native_object;
                    if (!object_pointer3_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'pt' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(pt3) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'pt' not null, could not be retreived correctly.");
                }
            }

            overload3_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxPoint2DInt_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxInt32) x1, (wxInt32) y1)\n");
                #endif

                native_object = new wxPoint2DInt_php((wxInt32) x1, (wxInt32) y1);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxPoint2DInt*) object_pointer2_0)\n");
                #endif

                native_object = new wxPoint2DInt_php(*(wxPoint2DInt*) object_pointer2_0);

                native_object->references.Initialize();
                ((wxPoint2DInt_php*) native_object)->references.AddReference(pt2, "wxPoint2DInt::wxPoint2DInt at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    if(overload3_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxPoint*) object_pointer3_0)\n");
                #endif

                native_object = new wxPoint2DInt_php(*(wxPoint*) object_pointer3_0);

                native_object->references.Initialize();
                ((wxPoint2DInt_php*) native_object)->references.AddReference(pt3, "wxPoint2DInt::wxPoint2DInt at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();

        native_object->InitProperties();

        current_object = Z_wxPoint2DInt_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxPoint2DInt::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

PHP_METHOD(php_wxPoint2DInt, __get)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DInt::__get\n");
    php_printf("===========================================\n");
    #endif

    int arguments_received = ZEND_NUM_ARGS();
    zo_wxPoint2DInt* current_object;
    wxPoint2DInt_php* native_object;

    char* name;
    size_t name_len;

    //Get native object of the php object that called the method
    if (getThis() != NULL)
    {
        current_object = Z_wxPoint2DInt_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DInt::wxPoint2DInt call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
        }
    }
    else
    {
        zend_error(E_ERROR, "Could not process __get call as static\n");
    }

    char parse_parameters_string[] = "s";

    if(
        zend_parse_parameters_ex(
            ZEND_PARSE_PARAMS_QUIET,
            arguments_received,
            parse_parameters_string,
            &name,
            &name_len
        ) == FAILURE
    )
    {
        RETVAL_NULL();
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Property to get: %s\n", name);
    php_printf("===========================================\n\n");
    #endif

    if(false){}
    else if(strcmp("m_x", name) == 0)
    {
        RETVAL_LONG(*((wxInt32*) native_object->properties[0]));
    }
    else if(strcmp("m_y", name) == 0)
    {
        RETVAL_LONG(*((wxInt32*) native_object->properties[1]));
    }
    else
    {
        RETVAL_NULL();
    }
}
/* {{{ proto  wxPoint2DInt::GetFloor(int x, int y) */
PHP_METHOD(php_wxPoint2DInt, GetFloor)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DInt::GetFloor\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DInt* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DInt_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DInt_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DInt::GetFloor call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DINT_TYPE){
                references = &((wxPoint2DInt_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long x0;
    long y0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &x0, &y0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPoint2DInt::GetFloor((wxInt32*) x0, (wxInt32*) y0)\n\n");
                #endif

                ((wxPoint2DInt_php*)native_object)->GetFloor((wxInt32*) x0, (wxInt32*) y0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DInt::GetFloor\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPoint2DInt::GetRounded(int x, int y) */
PHP_METHOD(php_wxPoint2DInt, GetRounded)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPoint2DInt::GetRounded\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPoint2DInt* current_object;
    wxphp_object_type current_object_type;
    wxPoint2DInt_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPoint2DInt_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPoint2DInt::GetRounded call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPOINT2DINT_TYPE){
                references = &((wxPoint2DInt_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long x0;
    long y0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &x0, &y0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPoint2DInt::GetRounded((wxInt32*) x0, (wxInt32*) y0)\n\n");
                #endif

                ((wxPoint2DInt_php*)native_object)->GetRounded((wxInt32*) x0, (wxInt32*) y0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPoint2DInt::GetRounded\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxProgressDialog_free(void *object)
{
    zo_wxProgressDialog* custom_object = (zo_wxProgressDialog*) object;

    /*zend_error(
        E_WARNING,
        "Object of class wxProgressDialog went out of scope. "
        "Remember to always call Destroy() to prevent memory leaks."
    );*/

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxProgressDialog_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxProgressDialog_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxProgressDialog* custom_object;

    custom_object = (zo_wxProgressDialog*) ecalloc(
        1,
        sizeof(zo_wxProgressDialog)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxProgressDialog_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXPROGRESSDIALOG_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxProgressDialog::wxProgressDialog(string title, string message, int maximum, wxWindow &parent, int style) */
PHP_METHOD(php_wxProgressDialog, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxProgressDialog::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxProgressDialog* current_object;
    wxProgressDialog_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    char* title0;
    size_t title_len0;
    char* message0;
    size_t message_len0;
    long maximum0;
    zval* parent0;
    wxWindow* object_pointer0_3 = 0;
    long style0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 2  && arguments_received <= 5)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ss|lzl' (&title0, &title_len0, &message0, &message_len0, &maximum0, &parent0, &style0)\n");
        #endif

        char parse_parameters_string[] = "ss|lzl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &title0, &title_len0, &message0, &message_len0, &maximum0, &parent0, &style0 ) == SUCCESS)
        {
            if(arguments_received >= 4){
                if(Z_TYPE_P(parent0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxWindow_P(parent0)->object_type;
                    argument_native_object = (void*) Z_wxWindow_P(parent0)->native_object;
                    object_pointer0_3 = (wxWindow*) argument_native_object;
                    if (!object_pointer0_3 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'parent' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(parent0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'parent' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(title0, wxConvUTF8), wxString(message0, wxConvUTF8))\n");
                #endif

                native_object = new wxProgressDialog_php(wxString(title0, wxConvUTF8), wxString(message0, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(title0, wxConvUTF8), wxString(message0, wxConvUTF8), (int) maximum0)\n");
                #endif

                native_object = new wxProgressDialog_php(wxString(title0, wxConvUTF8), wxString(message0, wxConvUTF8), (int) maximum0);

                native_object->references.Initialize();
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(title0, wxConvUTF8), wxString(message0, wxConvUTF8), (int) maximum0, (wxWindow*) object_pointer0_3)\n");
                #endif

                native_object = new wxProgressDialog_php(wxString(title0, wxConvUTF8), wxString(message0, wxConvUTF8), (int) maximum0, (wxWindow*) object_pointer0_3);

                native_object->references.Initialize();
                ((wxProgressDialog_php*) native_object)->references.AddReference(parent0, "wxProgressDialog::wxProgressDialog at call 2 with 4 argument(s)");
                break;
            }
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(title0, wxConvUTF8), wxString(message0, wxConvUTF8), (int) maximum0, (wxWindow*) object_pointer0_3, (int) style0)\n");
                #endif

                native_object = new wxProgressDialog_php(wxString(title0, wxConvUTF8), wxString(message0, wxConvUTF8), (int) maximum0, (wxWindow*) object_pointer0_3, (int) style0);

                native_object->references.Initialize();
                ((wxProgressDialog_php*) native_object)->references.AddReference(parent0, "wxProgressDialog::wxProgressDialog at call 2 with 5 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxProgressDialog_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxProgressDialog::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxLayoutConstraints_free(void *object)
{
    zo_wxLayoutConstraints* custom_object = (zo_wxLayoutConstraints*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxLayoutConstraints_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            custom_object->native_object->UninitProperties();
            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxLayoutConstraints done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxLayoutConstraints_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxLayoutConstraints_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxLayoutConstraints* custom_object;

    custom_object = (zo_wxLayoutConstraints*) ecalloc(
        1,
        sizeof(zo_wxLayoutConstraints)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxLayoutConstraints_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXLAYOUTCONSTRAINTS_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto bool wxLayoutConstraints::AreSatisfied() */
PHP_METHOD(php_wxLayoutConstraints, AreSatisfied)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxLayoutConstraints::AreSatisfied\n");
    php_printf("===========================================\n");
    #endif

    zo_wxLayoutConstraints* current_object;
    wxphp_object_type current_object_type;
    wxLayoutConstraints_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxLayoutConstraints_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxLayoutConstraints::AreSatisfied call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXLAYOUTCONSTRAINTS_TYPE){
                references = &((wxLayoutConstraints_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxLayoutConstraints::AreSatisfied())\n\n");
                #endif

                RETVAL_BOOL(((wxLayoutConstraints_php*)native_object)->AreSatisfied());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxLayoutConstraints::AreSatisfied\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxLayoutConstraints::wxLayoutConstraints() */
PHP_METHOD(php_wxLayoutConstraints, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxLayoutConstraints::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxLayoutConstraints* current_object;
    wxLayoutConstraints_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxLayoutConstraints_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();

        native_object->InitProperties();

        current_object = Z_wxLayoutConstraints_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxLayoutConstraints::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

PHP_METHOD(php_wxLayoutConstraints, __get)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxLayoutConstraints::__get\n");
    php_printf("===========================================\n");
    #endif

    int arguments_received = ZEND_NUM_ARGS();
    zo_wxLayoutConstraints* current_object;
    wxLayoutConstraints_php* native_object;

    char* name;
    size_t name_len;

    //Get native object of the php object that called the method
    if (getThis() != NULL)
    {
        current_object = Z_wxLayoutConstraints_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxLayoutConstraints::wxLayoutConstraints call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
        }
    }
    else
    {
        zend_error(E_ERROR, "Could not process __get call as static\n");
    }

    char parse_parameters_string[] = "s";

    if(
        zend_parse_parameters_ex(
            ZEND_PARSE_PARAMS_QUIET,
            arguments_received,
            parse_parameters_string,
            &name,
            &name_len
        ) == FAILURE
    )
    {
        RETVAL_NULL();
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Property to get: %s\n", name);
    php_printf("===========================================\n\n");
    #endif

    if(false){}
    else if(strcmp("left", name) == 0)
    {
    }
    else if(strcmp("top", name) == 0)
    {
    }
    else if(strcmp("right", name) == 0)
    {
    }
    else if(strcmp("bottom", name) == 0)
    {
    }
    else if(strcmp("width", name) == 0)
    {
    }
    else if(strcmp("height", name) == 0)
    {
    }
    else if(strcmp("centreX", name) == 0)
    {
    }
    else if(strcmp("centreY", name) == 0)
    {
    }
    else
    {
        RETVAL_NULL();
    }
}
/* {{{ proto bool wxLayoutConstraints::SatisfyConstraints(wxWindow &win, int &noChanges) */
PHP_METHOD(php_wxLayoutConstraints, SatisfyConstraints)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxLayoutConstraints::SatisfyConstraints\n");
    php_printf("===========================================\n");
    #endif

    zo_wxLayoutConstraints* current_object;
    wxphp_object_type current_object_type;
    wxLayoutConstraints_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxLayoutConstraints_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxLayoutConstraints::SatisfyConstraints call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXLAYOUTCONSTRAINTS_TYPE){
                references = &((wxLayoutConstraints_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* win0;
    wxWindow* object_pointer0_0 = 0;
    long* noChanges0;
    zval noChanges0_ref;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'zl' (&win0, noChanges0)\n");
        #endif

        char parse_parameters_string[] = "zl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &win0, noChanges0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(win0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxWindow_P(win0)->object_type;
                    argument_native_object = (void*) Z_wxWindow_P(win0)->native_object;
                    object_pointer0_0 = (wxWindow*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'win' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(win0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'win' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;

            char parse_references_string[] = "zz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, &dummy, noChanges0_ref );
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxLayoutConstraints::SatisfyConstraints((wxWindow*) object_pointer0_0, (int*) noChanges0))\n\n");
                #endif

                RETVAL_BOOL(((wxLayoutConstraints_php*)native_object)->SatisfyConstraints((wxWindow*) object_pointer0_0, (int*) noChanges0));

                references->AddReference(win0, "wxLayoutConstraints::SatisfyConstraints at call 1 with 2 argument(s)");
                size_t elements_returned0_1 = sizeof(noChanges0)/sizeof(*noChanges0);
                array_init(&noChanges0_ref);
                for(size_t i=0; i<elements_returned0_1; i++)
                {
                    add_next_index_long(&noChanges0_ref, noChanges0[i]);
                }

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxLayoutConstraints::SatisfyConstraints\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCellAttrProvider_free(void *object)
{
    zo_wxGridCellAttrProvider* custom_object = (zo_wxGridCellAttrProvider*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGridCellAttrProvider_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxGridCellAttrProvider done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxGridCellAttrProvider_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGridCellAttrProvider_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxGridCellAttrProvider* custom_object;

    custom_object = (zo_wxGridCellAttrProvider*) ecalloc(
        1,
        sizeof(zo_wxGridCellAttrProvider)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxGridCellAttrProvider_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCELLATTRPROVIDER_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto wxGridCellAttr wxGridCellAttrProvider::GetAttr(int row, int col, wxGridCellAttr::wxAttrKind kind)
   Get the attribute to use for the specified cell. */
PHP_METHOD(php_wxGridCellAttrProvider, GetAttr)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGridCellAttrProvider::GetAttr\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGridCellAttrProvider* current_object;
    wxphp_object_type current_object_type;
    wxGridCellAttrProvider_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGridCellAttrProvider_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGridCellAttrProvider::GetAttr call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRIDCELLATTRPROVIDER_TYPE){
                references = &((wxGridCellAttrProvider_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long row0;
    long col0;
    long kind0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'lll' (&row0, &col0, &kind0)\n");
        #endif

        char parse_parameters_string[] = "lll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &row0, &col0, &kind0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGridCellAttrProvider::GetAttr((int) row0, (int) col0, (wxGridCellAttr::wxAttrKind) kind0) to return object pointer\n\n");
                #endif

                wxGridCellAttr_php* value_to_return3;
                value_to_return3 = (wxGridCellAttr_php*) ((wxGridCellAttrProvider_php*)native_object)->GetAttr((int) row0, (int) col0, (wxGridCellAttr::wxAttrKind) kind0);

                if(value_to_return3 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return3->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return3->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return3->phpObj);
                        zval_add_ref(&value_to_return3->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxGridCellAttr_entry);
                    Z_wxGridCellAttr_P(return_value)->native_object = (wxGridCellAttr_php*) value_to_return3;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return3 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxGridCellAttrProvider::GetAttr at call 5 with 3 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGridCellAttrProvider::GetAttr\n"
        );
    }
}
/* }}} */

/* {{{ proto wxGridColumnHeaderRenderer wxGridCellAttrProvider::GetColumnHeaderRenderer(int col)
   Getting header renderers. */
PHP_METHOD(php_wxGridCellAttrProvider, GetColumnHeaderRenderer)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGridCellAttrProvider::GetColumnHeaderRenderer\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGridCellAttrProvider* current_object;
    wxphp_object_type current_object_type;
    wxGridCellAttrProvider_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGridCellAttrProvider_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGridCellAttrProvider::GetColumnHeaderRenderer call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRIDCELLATTRPROVIDER_TYPE){
                references = &((wxGridCellAttrProvider_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long col0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&col0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &col0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGridCellAttrProvider::GetColumnHeaderRenderer((int) col0) to return object reference\n\n");
                #endif

                wxGridColumnHeaderRenderer_php* value_to_return1;
                value_to_return1 = (wxGridColumnHeaderRenderer_php*) &((wxGridCellAttrProvider_php*)native_object)->GetColumnHeaderRenderer((int) col0);

                if(value_to_return1->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return1->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return1->phpObj);
                        zval_add_ref(&value_to_return1->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxGridColumnHeaderRenderer_entry);
                    Z_wxGridColumnHeaderRenderer_P(return_value)->native_object = (wxGridColumnHeaderRenderer_php*) value_to_return1;
                }

                if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxGridCellAttrProvider::GetColumnHeaderRenderer at call 6 with 1 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGridCellAttrProvider::GetColumnHeaderRenderer\n"
        );
    }
}
/* }}} */

/* {{{ proto wxGridCornerHeaderRenderer wxGridCellAttrProvider::GetCornerRenderer()
   Return the renderer used for drawing the corner window. */
PHP_METHOD(php_wxGridCellAttrProvider, GetCornerRenderer)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGridCellAttrProvider::GetCornerRenderer\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGridCellAttrProvider* current_object;
    wxphp_object_type current_object_type;
    wxGridCellAttrProvider_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGridCellAttrProvider_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGridCellAttrProvider::GetCornerRenderer call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRIDCELLATTRPROVIDER_TYPE){
                references = &((wxGridCellAttrProvider_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGridCellAttrProvider::GetCornerRenderer() to return object reference\n\n");
                #endif

                wxGridCornerHeaderRenderer_php* value_to_return0;
                value_to_return0 = (wxGridCornerHeaderRenderer_php*) &((wxGridCellAttrProvider_php*)native_object)->GetCornerRenderer();

                if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxGridCornerHeaderRenderer_entry);
                    Z_wxGridCornerHeaderRenderer_P(return_value)->native_object = (wxGridCornerHeaderRenderer_php*) value_to_return0;
                }

                if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxGridCellAttrProvider::GetCornerRenderer at call 6 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGridCellAttrProvider::GetCornerRenderer\n"
        );
    }
}
/* }}} */

/* {{{ proto wxGridRowHeaderRenderer wxGridCellAttrProvider::GetRowHeaderRenderer(int row)
   Return the renderer used for drawing row headers. */
PHP_METHOD(php_wxGridCellAttrProvider, GetRowHeaderRenderer)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGridCellAttrProvider::GetRowHeaderRenderer\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGridCellAttrProvider* current_object;
    wxphp_object_type current_object_type;
    wxGridCellAttrProvider_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGridCellAttrProvider_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGridCellAttrProvider::GetRowHeaderRenderer call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRIDCELLATTRPROVIDER_TYPE){
                references = &((wxGridCellAttrProvider_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long row0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&row0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &row0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGridCellAttrProvider::GetRowHeaderRenderer((int) row0) to return object reference\n\n");
                #endif

                wxGridRowHeaderRenderer_php* value_to_return1;
                value_to_return1 = (wxGridRowHeaderRenderer_php*) &((wxGridCellAttrProvider_php*)native_object)->GetRowHeaderRenderer((int) row0);

                if(value_to_return1->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return1->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return1->phpObj);
                        zval_add_ref(&value_to_return1->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxGridRowHeaderRenderer_entry);
                    Z_wxGridRowHeaderRenderer_P(return_value)->native_object = (wxGridRowHeaderRenderer_php*) value_to_return1;
                }

                if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxGridCellAttrProvider::GetRowHeaderRenderer at call 6 with 1 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGridCellAttrProvider::GetRowHeaderRenderer\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxGridCellAttrProvider::SetAttr(wxGridCellAttr &attr, int row, int col)
   Setting attributes. */
PHP_METHOD(php_wxGridCellAttrProvider, SetAttr)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGridCellAttrProvider::SetAttr\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGridCellAttrProvider* current_object;
    wxphp_object_type current_object_type;
    wxGridCellAttrProvider_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGridCellAttrProvider_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGridCellAttrProvider::SetAttr call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRIDCELLATTRPROVIDER_TYPE){
                references = &((wxGridCellAttrProvider_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* attr0;
    wxGridCellAttr* object_pointer0_0 = 0;
    long row0;
    long col0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'zll' (&attr0, &row0, &col0)\n");
        #endif

        char parse_parameters_string[] = "zll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &attr0, &row0, &col0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(attr0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxGridCellAttr_P(attr0)->object_type;
                    argument_native_object = (void*) Z_wxGridCellAttr_P(attr0)->native_object;
                    object_pointer0_0 = (wxGridCellAttr*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXGRIDCELLATTR_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'attr' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(attr0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'attr' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGridCellAttrProvider::SetAttr((wxGridCellAttr*) object_pointer0_0, (int) row0, (int) col0)\n\n");
                #endif

                ((wxGridCellAttrProvider_php*)native_object)->SetAttr((wxGridCellAttr*) object_pointer0_0, (int) row0, (int) col0);

                references->AddReference(attr0, "wxGridCellAttrProvider::SetAttr at call 1 with 3 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGridCellAttrProvider::SetAttr\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxGridCellAttrProvider::SetColAttr(wxGridCellAttr &attr, int col)
   Set attribute for the specified column. */
PHP_METHOD(php_wxGridCellAttrProvider, SetColAttr)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGridCellAttrProvider::SetColAttr\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGridCellAttrProvider* current_object;
    wxphp_object_type current_object_type;
    wxGridCellAttrProvider_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGridCellAttrProvider_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGridCellAttrProvider::SetColAttr call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRIDCELLATTRPROVIDER_TYPE){
                references = &((wxGridCellAttrProvider_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* attr0;
    wxGridCellAttr* object_pointer0_0 = 0;
    long col0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'zl' (&attr0, &col0)\n");
        #endif

        char parse_parameters_string[] = "zl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &attr0, &col0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(attr0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxGridCellAttr_P(attr0)->object_type;
                    argument_native_object = (void*) Z_wxGridCellAttr_P(attr0)->native_object;
                    object_pointer0_0 = (wxGridCellAttr*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXGRIDCELLATTR_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'attr' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(attr0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'attr' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGridCellAttrProvider::SetColAttr((wxGridCellAttr*) object_pointer0_0, (int) col0)\n\n");
                #endif

                ((wxGridCellAttrProvider_php*)native_object)->SetColAttr((wxGridCellAttr*) object_pointer0_0, (int) col0);

                references->AddReference(attr0, "wxGridCellAttrProvider::SetColAttr at call 1 with 2 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGridCellAttrProvider::SetColAttr\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxGridCellAttrProvider::SetRowAttr(wxGridCellAttr &attr, int row)
   Set attribute for the specified row. */
PHP_METHOD(php_wxGridCellAttrProvider, SetRowAttr)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGridCellAttrProvider::SetRowAttr\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGridCellAttrProvider* current_object;
    wxphp_object_type current_object_type;
    wxGridCellAttrProvider_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGridCellAttrProvider_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGridCellAttrProvider::SetRowAttr call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRIDCELLATTRPROVIDER_TYPE){
                references = &((wxGridCellAttrProvider_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* attr0;
    wxGridCellAttr* object_pointer0_0 = 0;
    long row0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'zl' (&attr0, &row0)\n");
        #endif

        char parse_parameters_string[] = "zl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &attr0, &row0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(attr0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxGridCellAttr_P(attr0)->object_type;
                    argument_native_object = (void*) Z_wxGridCellAttr_P(attr0)->native_object;
                    object_pointer0_0 = (wxGridCellAttr*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXGRIDCELLATTR_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'attr' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(attr0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'attr' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGridCellAttrProvider::SetRowAttr((wxGridCellAttr*) object_pointer0_0, (int) row0)\n\n");
                #endif

                ((wxGridCellAttrProvider_php*)native_object)->SetRowAttr((wxGridCellAttr*) object_pointer0_0, (int) row0);

                references->AddReference(attr0, "wxGridCellAttrProvider::SetRowAttr at call 1 with 2 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGridCellAttrProvider::SetRowAttr\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxGridCellAttrProvider::wxGridCellAttrProvider()
   Trivial default constructor. */
PHP_METHOD(php_wxGridCellAttrProvider, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGridCellAttrProvider::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGridCellAttrProvider* current_object;
    wxGridCellAttrProvider_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxGridCellAttrProvider_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxGridCellAttrProvider_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxGridCellAttrProvider::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridColumnHeaderRenderer_free(void *object)
{
    zo_wxGridColumnHeaderRenderer* custom_object = (zo_wxGridColumnHeaderRenderer*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGridColumnHeaderRenderer_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxGridColumnHeaderRenderer done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxGridColumnHeaderRenderer_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGridColumnHeaderRenderer_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxGridColumnHeaderRenderer* custom_object;

    custom_object = (zo_wxGridColumnHeaderRenderer*) ecalloc(
        1,
        sizeof(zo_wxGridColumnHeaderRenderer)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxGridColumnHeaderRenderer_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCOLUMNHEADERRENDERER_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

BEGIN_EXTERN_C()
void php_wxGridColumnHeaderRendererDefault_free(void *object)
{
    zo_wxGridColumnHeaderRendererDefault* custom_object = (zo_wxGridColumnHeaderRendererDefault*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGridColumnHeaderRendererDefault_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxGridColumnHeaderRendererDefault done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxGridColumnHeaderRendererDefault_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGridColumnHeaderRendererDefault_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxGridColumnHeaderRendererDefault* custom_object;

    custom_object = (zo_wxGridColumnHeaderRendererDefault*) ecalloc(
        1,
        sizeof(zo_wxGridColumnHeaderRendererDefault)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxGridColumnHeaderRendererDefault_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCOLUMNHEADERRENDERERDEFAULT_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxGridColumnHeaderRendererDefault::DrawBorder(wxGrid grid, wxDC &dc, wxRect &rect)
   Implement border drawing for the column labels. */
PHP_METHOD(php_wxGridColumnHeaderRendererDefault, DrawBorder)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGridColumnHeaderRendererDefault::DrawBorder\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGridColumnHeaderRendererDefault* current_object;
    wxphp_object_type current_object_type;
    wxGridColumnHeaderRendererDefault_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGridColumnHeaderRendererDefault_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGridColumnHeaderRendererDefault::DrawBorder call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRIDCOLUMNHEADERRENDERERDEFAULT_TYPE){
                references = &((wxGridColumnHeaderRendererDefault_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* grid0;
    wxGrid* object_pointer0_0 = 0;
    zval* dc0;
    wxDC* object_pointer0_1 = 0;
    zval* rect0;
    wxRect* object_pointer0_2 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'OoO' (&grid0, php_wxGrid_entry, &dc0, &rect0, php_wxRect_entry)\n");
        #endif

        char parse_parameters_string[] = "OoO";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &grid0, php_wxGrid_entry, &dc0, &rect0, php_wxRect_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(grid0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxGrid_P(grid0)->object_type;
                    argument_native_object = (void*) Z_wxGrid_P(grid0)->native_object;
                    object_pointer0_0 = (wxGrid*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'grid' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(grid0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'grid' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 2){
                if(Z_TYPE_P(dc0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxDC_P(dc0)->object_type;
                    argument_native_object = (void*) Z_wxDC_P(dc0)->native_object;
                    object_pointer0_1 = (wxDC*) argument_native_object;
                    if (!object_pointer0_1 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(dc0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 3){
                if(Z_TYPE_P(rect0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxRect_P(rect0)->object_type;
                    argument_native_object = (void*) Z_wxRect_P(rect0)->native_object;
                    object_pointer0_2 = (wxRect*) argument_native_object;
                    if (!object_pointer0_2 )
                    {
                        zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(rect0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGridColumnHeaderRendererDefault::DrawBorder(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, *(wxRect*) object_pointer0_2)\n\n");
                #endif

                if(current_object_type == PHP_WXGRIDCOLUMNHEADERRENDERERDEFAULT_TYPE)
                {
                    ((wxGridColumnHeaderRendererDefault_php*)native_object)->DrawBorder(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, *(wxRect*) object_pointer0_2);
                }

                references->AddReference(grid0, "wxGridColumnHeaderRendererDefault::DrawBorder at call 3 with 3 argument(s)");
                references->AddReference(dc0, "wxGridColumnHeaderRendererDefault::DrawBorder at call 3 with 3 argument(s)");
                references->AddReference(rect0, "wxGridColumnHeaderRendererDefault::DrawBorder at call 3 with 3 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGridColumnHeaderRendererDefault::DrawBorder\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCornerHeaderRenderer_free(void *object)
{
    zo_wxGridCornerHeaderRenderer* custom_object = (zo_wxGridCornerHeaderRenderer*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGridCornerHeaderRenderer_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxGridCornerHeaderRenderer done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxGridCornerHeaderRenderer_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGridCornerHeaderRenderer_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxGridCornerHeaderRenderer* custom_object;

    custom_object = (zo_wxGridCornerHeaderRenderer*) ecalloc(
        1,
        sizeof(zo_wxGridCornerHeaderRenderer)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxGridCornerHeaderRenderer_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCORNERHEADERRENDERER_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxGridCornerHeaderRenderer::DrawBorder(wxGrid grid, wxDC &dc, wxRect &rect)
   Called by the grid to draw the corner window border. */
void wxGridCornerHeaderRenderer_php::DrawBorder(const wxGrid& grid, wxDC& dc, wxRect& rect)const
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxGridCornerHeaderRenderer::DrawBorder\n");
    php_printf("===========================================\n");
    #endif

    zval* params[3];
    zval arguments[3];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "DrawBorder");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    object_init_ex(&arguments[0], php_wxGrid_entry);
    Z_wxGrid_P(&arguments[0])->native_object = (wxGrid_php*) &grid;
    object_init_ex(&arguments[1], php_wxDC_entry);
    Z_wxDC_P(&arguments[1])->native_object = (wxDC_php*) &dc;
    object_init_ex(&arguments[2], php_wxRect_entry);
    Z_wxRect_P(&arguments[2])->native_object = (wxRect_php*) &rect;
    
    for(int i=0; i<3; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "DrawBorder");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "DrawBorder",
            10,
            &function_return_value,
            3,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<3; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxGridCornerHeaderRenderer::DrawBorder'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return;

}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCornerHeaderRendererDefault_free(void *object)
{
    zo_wxGridCornerHeaderRendererDefault* custom_object = (zo_wxGridCornerHeaderRendererDefault*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGridCornerHeaderRendererDefault_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxGridCornerHeaderRendererDefault done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxGridCornerHeaderRendererDefault_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGridCornerHeaderRendererDefault_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxGridCornerHeaderRendererDefault* custom_object;

    custom_object = (zo_wxGridCornerHeaderRendererDefault*) ecalloc(
        1,
        sizeof(zo_wxGridCornerHeaderRendererDefault)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxGridCornerHeaderRendererDefault_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCORNERHEADERRENDERERDEFAULT_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxGridCornerHeaderRendererDefault::DrawBorder(wxGrid grid, wxDC &dc, wxRect &rect)
   Implement border drawing for the corner window. */
PHP_METHOD(php_wxGridCornerHeaderRendererDefault, DrawBorder)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGridCornerHeaderRendererDefault::DrawBorder\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGridCornerHeaderRendererDefault* current_object;
    wxphp_object_type current_object_type;
    wxGridCornerHeaderRendererDefault_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGridCornerHeaderRendererDefault_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGridCornerHeaderRendererDefault::DrawBorder call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRIDCORNERHEADERRENDERERDEFAULT_TYPE){
                references = &((wxGridCornerHeaderRendererDefault_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* grid0;
    wxGrid* object_pointer0_0 = 0;
    zval* dc0;
    wxDC* object_pointer0_1 = 0;
    zval* rect0;
    wxRect* object_pointer0_2 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'OoO' (&grid0, php_wxGrid_entry, &dc0, &rect0, php_wxRect_entry)\n");
        #endif

        char parse_parameters_string[] = "OoO";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &grid0, php_wxGrid_entry, &dc0, &rect0, php_wxRect_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(grid0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxGrid_P(grid0)->object_type;
                    argument_native_object = (void*) Z_wxGrid_P(grid0)->native_object;
                    object_pointer0_0 = (wxGrid*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'grid' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(grid0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'grid' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 2){
                if(Z_TYPE_P(dc0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxDC_P(dc0)->object_type;
                    argument_native_object = (void*) Z_wxDC_P(dc0)->native_object;
                    object_pointer0_1 = (wxDC*) argument_native_object;
                    if (!object_pointer0_1 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(dc0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 3){
                if(Z_TYPE_P(rect0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxRect_P(rect0)->object_type;
                    argument_native_object = (void*) Z_wxRect_P(rect0)->native_object;
                    object_pointer0_2 = (wxRect*) argument_native_object;
                    if (!object_pointer0_2 )
                    {
                        zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(rect0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGridCornerHeaderRendererDefault::DrawBorder(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, *(wxRect*) object_pointer0_2)\n\n");
                #endif

                if(current_object_type == PHP_WXGRIDCORNERHEADERRENDERERDEFAULT_TYPE)
                {
                    ((wxGridCornerHeaderRendererDefault_php*)native_object)->DrawBorder(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, *(wxRect*) object_pointer0_2);
                }

                references->AddReference(grid0, "wxGridCornerHeaderRendererDefault::DrawBorder at call 3 with 3 argument(s)");
                references->AddReference(dc0, "wxGridCornerHeaderRendererDefault::DrawBorder at call 3 with 3 argument(s)");
                references->AddReference(rect0, "wxGridCornerHeaderRendererDefault::DrawBorder at call 3 with 3 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGridCornerHeaderRendererDefault::DrawBorder\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridHeaderLabelsRenderer_free(void *object)
{
    zo_wxGridHeaderLabelsRenderer* custom_object = (zo_wxGridHeaderLabelsRenderer*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGridHeaderLabelsRenderer_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxGridHeaderLabelsRenderer done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxGridHeaderLabelsRenderer_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGridHeaderLabelsRenderer_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxGridHeaderLabelsRenderer* custom_object;

    custom_object = (zo_wxGridHeaderLabelsRenderer*) ecalloc(
        1,
        sizeof(zo_wxGridHeaderLabelsRenderer)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxGridHeaderLabelsRenderer_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDHEADERLABELSRENDERER_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxGridHeaderLabelsRenderer::DrawLabel(wxGrid grid, wxDC &dc, string value, wxRect rect, int horizAlign, int vertAlign, int textOrientation)
   Called by the grid to draw the specified label. */
PHP_METHOD(php_wxGridHeaderLabelsRenderer, DrawLabel)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGridHeaderLabelsRenderer::DrawLabel\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGridHeaderLabelsRenderer* current_object;
    wxphp_object_type current_object_type;
    wxGridHeaderLabelsRenderer_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGridHeaderLabelsRenderer_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGridHeaderLabelsRenderer::DrawLabel call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRIDHEADERLABELSRENDERER_TYPE){
                references = &((wxGridHeaderLabelsRenderer_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXGRIDCOLUMNHEADERRENDERER_TYPE) && (!reference_type_found)){
                references = &((wxGridColumnHeaderRenderer_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXGRIDCOLUMNHEADERRENDERERDEFAULT_TYPE) && (!reference_type_found)){
                references = &((wxGridColumnHeaderRendererDefault_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXGRIDROWHEADERRENDERER_TYPE) && (!reference_type_found)){
                references = &((wxGridRowHeaderRenderer_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXGRIDROWHEADERRENDERERDEFAULT_TYPE) && (!reference_type_found)){
                references = &((wxGridRowHeaderRendererDefault_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* grid0;
    wxGrid* object_pointer0_0 = 0;
    zval* dc0;
    wxDC* object_pointer0_1 = 0;
    char* value0;
    size_t value_len0;
    zval* rect0;
    wxRect* object_pointer0_3 = 0;
    long horizAlign0;
    long vertAlign0;
    long textOrientation0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 7)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'OosOlll' (&grid0, php_wxGrid_entry, &dc0, &value0, &value_len0, &rect0, php_wxRect_entry, &horizAlign0, &vertAlign0, &textOrientation0)\n");
        #endif

        char parse_parameters_string[] = "OosOlll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &grid0, php_wxGrid_entry, &dc0, &value0, &value_len0, &rect0, php_wxRect_entry, &horizAlign0, &vertAlign0, &textOrientation0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(grid0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxGrid_P(grid0)->object_type;
                    argument_native_object = (void*) Z_wxGrid_P(grid0)->native_object;
                    object_pointer0_0 = (wxGrid*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'grid' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(grid0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'grid' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 2){
                if(Z_TYPE_P(dc0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxDC_P(dc0)->object_type;
                    argument_native_object = (void*) Z_wxDC_P(dc0)->native_object;
                    object_pointer0_1 = (wxDC*) argument_native_object;
                    if (!object_pointer0_1 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(dc0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 4){
                if(Z_TYPE_P(rect0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxRect_P(rect0)->object_type;
                    argument_native_object = (void*) Z_wxRect_P(rect0)->native_object;
                    object_pointer0_3 = (wxRect*) argument_native_object;
                    if (!object_pointer0_3 )
                    {
                        zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(rect0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 7:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGridHeaderLabelsRenderer::DrawLabel(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, wxString(value0, wxConvUTF8), *(wxRect*) object_pointer0_3, (int) horizAlign0, (int) vertAlign0, (int) textOrientation0)\n\n");
                #endif

                if(current_object_type == PHP_WXGRIDCOLUMNHEADERRENDERER_TYPE)
                {
                    ((wxGridColumnHeaderRenderer_php*)native_object)->DrawLabel(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, wxString(value0, wxConvUTF8), *(wxRect*) object_pointer0_3, (int) horizAlign0, (int) vertAlign0, (int) textOrientation0);
                }
                else if(current_object_type == PHP_WXGRIDCOLUMNHEADERRENDERERDEFAULT_TYPE)
                {
                    ((wxGridColumnHeaderRendererDefault_php*)native_object)->DrawLabel(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, wxString(value0, wxConvUTF8), *(wxRect*) object_pointer0_3, (int) horizAlign0, (int) vertAlign0, (int) textOrientation0);
                }
                else if(current_object_type == PHP_WXGRIDROWHEADERRENDERER_TYPE)
                {
                    ((wxGridRowHeaderRenderer_php*)native_object)->DrawLabel(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, wxString(value0, wxConvUTF8), *(wxRect*) object_pointer0_3, (int) horizAlign0, (int) vertAlign0, (int) textOrientation0);
                }
                else if(current_object_type == PHP_WXGRIDROWHEADERRENDERERDEFAULT_TYPE)
                {
                    ((wxGridRowHeaderRendererDefault_php*)native_object)->DrawLabel(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, wxString(value0, wxConvUTF8), *(wxRect*) object_pointer0_3, (int) horizAlign0, (int) vertAlign0, (int) textOrientation0);
                }
                else if(current_object_type == PHP_WXGRIDHEADERLABELSRENDERER_TYPE)
                {
                    ((wxGridHeaderLabelsRenderer_php*)native_object)->DrawLabel(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, wxString(value0, wxConvUTF8), *(wxRect*) object_pointer0_3, (int) horizAlign0, (int) vertAlign0, (int) textOrientation0);
                }

                references->AddReference(grid0, "wxGridHeaderLabelsRenderer::DrawLabel at call 3 with 7 argument(s)");
                references->AddReference(dc0, "wxGridHeaderLabelsRenderer::DrawLabel at call 3 with 7 argument(s)");
                references->AddReference(rect0, "wxGridHeaderLabelsRenderer::DrawLabel at call 3 with 7 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGridHeaderLabelsRenderer::DrawLabel\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridRowHeaderRenderer_free(void *object)
{
    zo_wxGridRowHeaderRenderer* custom_object = (zo_wxGridRowHeaderRenderer*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGridRowHeaderRenderer_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxGridRowHeaderRenderer done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxGridRowHeaderRenderer_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGridRowHeaderRenderer_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxGridRowHeaderRenderer* custom_object;

    custom_object = (zo_wxGridRowHeaderRenderer*) ecalloc(
        1,
        sizeof(zo_wxGridRowHeaderRenderer)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxGridRowHeaderRenderer_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDROWHEADERRENDERER_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

BEGIN_EXTERN_C()
void php_wxGridRowHeaderRendererDefault_free(void *object)
{
    zo_wxGridRowHeaderRendererDefault* custom_object = (zo_wxGridRowHeaderRendererDefault*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGridRowHeaderRendererDefault_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxGridRowHeaderRendererDefault done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxGridRowHeaderRendererDefault_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxGridRowHeaderRendererDefault_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxGridRowHeaderRendererDefault* custom_object;

    custom_object = (zo_wxGridRowHeaderRendererDefault*) ecalloc(
        1,
        sizeof(zo_wxGridRowHeaderRendererDefault)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxGridRowHeaderRendererDefault_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDROWHEADERRENDERERDEFAULT_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxGridRowHeaderRendererDefault::DrawBorder(wxGrid grid, wxDC &dc, wxRect &rect)
   Implement border drawing for the row labels. */
PHP_METHOD(php_wxGridRowHeaderRendererDefault, DrawBorder)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxGridRowHeaderRendererDefault::DrawBorder\n");
    php_printf("===========================================\n");
    #endif

    zo_wxGridRowHeaderRendererDefault* current_object;
    wxphp_object_type current_object_type;
    wxGridRowHeaderRendererDefault_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxGridRowHeaderRendererDefault_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxGridRowHeaderRendererDefault::DrawBorder call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXGRIDROWHEADERRENDERERDEFAULT_TYPE){
                references = &((wxGridRowHeaderRendererDefault_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* grid0;
    wxGrid* object_pointer0_0 = 0;
    zval* dc0;
    wxDC* object_pointer0_1 = 0;
    zval* rect0;
    wxRect* object_pointer0_2 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'OoO' (&grid0, php_wxGrid_entry, &dc0, &rect0, php_wxRect_entry)\n");
        #endif

        char parse_parameters_string[] = "OoO";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &grid0, php_wxGrid_entry, &dc0, &rect0, php_wxRect_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(grid0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxGrid_P(grid0)->object_type;
                    argument_native_object = (void*) Z_wxGrid_P(grid0)->native_object;
                    object_pointer0_0 = (wxGrid*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'grid' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(grid0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'grid' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 2){
                if(Z_TYPE_P(dc0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxDC_P(dc0)->object_type;
                    argument_native_object = (void*) Z_wxDC_P(dc0)->native_object;
                    object_pointer0_1 = (wxDC*) argument_native_object;
                    if (!object_pointer0_1 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(dc0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
                }
            }

            if(arguments_received >= 3){
                if(Z_TYPE_P(rect0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxRect_P(rect0)->object_type;
                    argument_native_object = (void*) Z_wxRect_P(rect0)->native_object;
                    object_pointer0_2 = (wxRect*) argument_native_object;
                    if (!object_pointer0_2 )
                    {
                        zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(rect0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxGridRowHeaderRendererDefault::DrawBorder(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, *(wxRect*) object_pointer0_2)\n\n");
                #endif

                if(current_object_type == PHP_WXGRIDROWHEADERRENDERERDEFAULT_TYPE)
                {
                    ((wxGridRowHeaderRendererDefault_php*)native_object)->DrawBorder(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, *(wxRect*) object_pointer0_2);
                }

                references->AddReference(grid0, "wxGridRowHeaderRendererDefault::DrawBorder at call 3 with 3 argument(s)");
                references->AddReference(dc0, "wxGridRowHeaderRendererDefault::DrawBorder at call 3 with 3 argument(s)");
                references->AddReference(rect0, "wxGridRowHeaderRendererDefault::DrawBorder at call 3 with 3 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxGridRowHeaderRendererDefault::DrawBorder\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxPaletteChangedEvent_free(void *object)
{
    zo_wxPaletteChangedEvent* custom_object = (zo_wxPaletteChangedEvent*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxPaletteChangedEvent_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxPaletteChangedEvent done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxPaletteChangedEvent_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxPaletteChangedEvent_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxPaletteChangedEvent* custom_object;

    custom_object = (zo_wxPaletteChangedEvent*) ecalloc(
        1,
        sizeof(zo_wxPaletteChangedEvent)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxPaletteChangedEvent_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXPALETTECHANGEDEVENT_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto wxWindow wxPaletteChangedEvent::GetChangedWindow() */
PHP_METHOD(php_wxPaletteChangedEvent, GetChangedWindow)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPaletteChangedEvent::GetChangedWindow\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPaletteChangedEvent* current_object;
    wxphp_object_type current_object_type;
    wxPaletteChangedEvent_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPaletteChangedEvent_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPaletteChangedEvent::GetChangedWindow call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPALETTECHANGEDEVENT_TYPE){
                references = &((wxPaletteChangedEvent_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPaletteChangedEvent::GetChangedWindow() to return object pointer\n\n");
                #endif

                wxWindow_php* value_to_return0;
                value_to_return0 = (wxWindow_php*) ((wxPaletteChangedEvent_php*)native_object)->GetChangedWindow();

                if(value_to_return0 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxWindow_entry);
                    Z_wxWindow_P(return_value)->native_object = (wxWindow_php*) value_to_return0;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxPaletteChangedEvent::GetChangedWindow at call 5 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPaletteChangedEvent::GetChangedWindow\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPaletteChangedEvent::SetChangedWindow(wxWindow &win) */
PHP_METHOD(php_wxPaletteChangedEvent, SetChangedWindow)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPaletteChangedEvent::SetChangedWindow\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPaletteChangedEvent* current_object;
    wxphp_object_type current_object_type;
    wxPaletteChangedEvent_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPaletteChangedEvent_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPaletteChangedEvent::SetChangedWindow call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPALETTECHANGEDEVENT_TYPE){
                references = &((wxPaletteChangedEvent_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* win0;
    wxWindow* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&win0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &win0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(win0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxWindow_P(win0)->object_type;
                    argument_native_object = (void*) Z_wxWindow_P(win0)->native_object;
                    object_pointer0_0 = (wxWindow*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'win' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(win0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'win' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPaletteChangedEvent::SetChangedWindow((wxWindow*) object_pointer0_0)\n\n");
                #endif

                ((wxPaletteChangedEvent_php*)native_object)->SetChangedWindow((wxWindow*) object_pointer0_0);

                references->AddReference(win0, "wxPaletteChangedEvent::SetChangedWindow at call 1 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPaletteChangedEvent::SetChangedWindow\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPaletteChangedEvent::wxPaletteChangedEvent(int winid) */
PHP_METHOD(php_wxPaletteChangedEvent, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPaletteChangedEvent::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPaletteChangedEvent* current_object;
    wxPaletteChangedEvent_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    long winid0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&winid0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &winid0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxPaletteChangedEvent_php();

                native_object->references.Initialize();
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxWindowID) winid0)\n");
                #endif

                native_object = new wxPaletteChangedEvent_php((wxWindowID) winid0);

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxPaletteChangedEvent_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxPaletteChangedEvent::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFileTypeInfo_free(void *object)
{
    zo_wxFileTypeInfo* custom_object = (zo_wxFileTypeInfo*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFileTypeInfo_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxFileTypeInfo done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxFileTypeInfo_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFileTypeInfo_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxFileTypeInfo* custom_object;

    custom_object = (zo_wxFileTypeInfo*) ecalloc(
        1,
        sizeof(zo_wxFileTypeInfo)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxFileTypeInfo_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFILETYPEINFO_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxFileTypeInfo::AddExtension(string ext)
   Add another extension associated with this file type. */
PHP_METHOD(php_wxFileTypeInfo, AddExtension)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileTypeInfo::AddExtension\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileTypeInfo* current_object;
    wxphp_object_type current_object_type;
    wxFileTypeInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileTypeInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileTypeInfo::AddExtension call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILETYPEINFO_TYPE){
                references = &((wxFileTypeInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* ext0;
    size_t ext_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&ext0, &ext_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &ext0, &ext_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileTypeInfo::AddExtension(wxString(ext0, wxConvUTF8))\n\n");
                #endif

                ((wxFileTypeInfo_php*)native_object)->AddExtension(wxString(ext0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileTypeInfo::AddExtension\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileTypeInfo::SetDescription(string description)
   Set the file type description. */
PHP_METHOD(php_wxFileTypeInfo, SetDescription)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileTypeInfo::SetDescription\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileTypeInfo* current_object;
    wxphp_object_type current_object_type;
    wxFileTypeInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileTypeInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileTypeInfo::SetDescription call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILETYPEINFO_TYPE){
                references = &((wxFileTypeInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* description0;
    size_t description_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&description0, &description_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &description0, &description_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileTypeInfo::SetDescription(wxString(description0, wxConvUTF8))\n\n");
                #endif

                ((wxFileTypeInfo_php*)native_object)->SetDescription(wxString(description0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileTypeInfo::SetDescription\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileTypeInfo::SetOpenCommand(string command)
   Set the command to be used for opening files of this type. */
PHP_METHOD(php_wxFileTypeInfo, SetOpenCommand)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileTypeInfo::SetOpenCommand\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileTypeInfo* current_object;
    wxphp_object_type current_object_type;
    wxFileTypeInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileTypeInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileTypeInfo::SetOpenCommand call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILETYPEINFO_TYPE){
                references = &((wxFileTypeInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* command0;
    size_t command_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&command0, &command_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &command0, &command_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileTypeInfo::SetOpenCommand(wxString(command0, wxConvUTF8))\n\n");
                #endif

                ((wxFileTypeInfo_php*)native_object)->SetOpenCommand(wxString(command0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileTypeInfo::SetOpenCommand\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileTypeInfo::SetPrintCommand(string command)
   Set the command to be used for printing files of this type. */
PHP_METHOD(php_wxFileTypeInfo, SetPrintCommand)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileTypeInfo::SetPrintCommand\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileTypeInfo* current_object;
    wxphp_object_type current_object_type;
    wxFileTypeInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileTypeInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileTypeInfo::SetPrintCommand call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILETYPEINFO_TYPE){
                references = &((wxFileTypeInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* command0;
    size_t command_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&command0, &command_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &command0, &command_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileTypeInfo::SetPrintCommand(wxString(command0, wxConvUTF8))\n\n");
                #endif

                ((wxFileTypeInfo_php*)native_object)->SetPrintCommand(wxString(command0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileTypeInfo::SetPrintCommand\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileTypeInfo::SetShortDesc(string shortDesc)
   Set the short description for the files of this type. */
PHP_METHOD(php_wxFileTypeInfo, SetShortDesc)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileTypeInfo::SetShortDesc\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileTypeInfo* current_object;
    wxphp_object_type current_object_type;
    wxFileTypeInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileTypeInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileTypeInfo::SetShortDesc call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILETYPEINFO_TYPE){
                references = &((wxFileTypeInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* shortDesc0;
    size_t shortDesc_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&shortDesc0, &shortDesc_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &shortDesc0, &shortDesc_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileTypeInfo::SetShortDesc(wxString(shortDesc0, wxConvUTF8))\n\n");
                #endif

                ((wxFileTypeInfo_php*)native_object)->SetShortDesc(wxString(shortDesc0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileTypeInfo::SetShortDesc\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileTypeInfo::wxFileTypeInfo()
   Default constructor creates an invalid file type info object. */
PHP_METHOD(php_wxFileTypeInfo, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileTypeInfo::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileTypeInfo* current_object;
    wxFileTypeInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    char* mimeType1;
    size_t mimeType_len1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&mimeType1, &mimeType_len1)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &mimeType1, &mimeType_len1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxFileTypeInfo_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(mimeType1, wxConvUTF8))\n");
                #endif

                native_object = new wxFileTypeInfo_php(wxString(mimeType1, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxFileTypeInfo_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxFileTypeInfo::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxDisplayChangedEvent_free(void *object)
{
    zo_wxDisplayChangedEvent* custom_object = (zo_wxDisplayChangedEvent*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxDisplayChangedEvent_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxDisplayChangedEvent done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxDisplayChangedEvent_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxDisplayChangedEvent_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxDisplayChangedEvent* custom_object;

    custom_object = (zo_wxDisplayChangedEvent*) ecalloc(
        1,
        sizeof(zo_wxDisplayChangedEvent)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxDisplayChangedEvent_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXDISPLAYCHANGEDEVENT_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxDisplayChangedEvent::wxDisplayChangedEvent() */
PHP_METHOD(php_wxDisplayChangedEvent, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDisplayChangedEvent::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDisplayChangedEvent* current_object;
    wxDisplayChangedEvent_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxDisplayChangedEvent_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxDisplayChangedEvent_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxDisplayChangedEvent::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxTimerRunner_free(void *object)
{
    zo_wxTimerRunner* custom_object = (zo_wxTimerRunner*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxTimerRunner_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxTimerRunner done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxTimerRunner_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxTimerRunner_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxTimerRunner* custom_object;

    custom_object = (zo_wxTimerRunner*) ecalloc(
        1,
        sizeof(zo_wxTimerRunner)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxTimerRunner_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXTIMERRUNNER_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxTimerRunner::Start(int milli, bool oneShot) */
PHP_METHOD(php_wxTimerRunner, Start)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxTimerRunner::Start\n");
    php_printf("===========================================\n");
    #endif

    zo_wxTimerRunner* current_object;
    wxphp_object_type current_object_type;
    wxTimerRunner_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxTimerRunner_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxTimerRunner::Start call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTIMERRUNNER_TYPE){
                references = &((wxTimerRunner_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long milli0;
    bool oneShot0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l|b' (&milli0, &oneShot0)\n");
        #endif

        char parse_parameters_string[] = "l|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &milli0, &oneShot0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxTimerRunner::Start((int) milli0)\n\n");
                #endif

                ((wxTimerRunner_php*)native_object)->Start((int) milli0);


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxTimerRunner::Start((int) milli0, oneShot0)\n\n");
                #endif

                ((wxTimerRunner_php*)native_object)->Start((int) milli0, oneShot0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxTimerRunner::Start\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxTimerRunner::wxTimerRunner(wxTimer &timer) */
PHP_METHOD(php_wxTimerRunner, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxTimerRunner::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxTimerRunner* current_object;
    wxTimerRunner_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    zval* timer0;
    wxTimer* object_pointer0_0 = 0;
    bool overload0_called = false;

    //Parameters for overload 1
    zval* timer1;
    wxTimer* object_pointer1_0 = 0;
    long milli1;
    bool oneShot1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&timer0, php_wxTimer_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &timer0, php_wxTimer_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(timer0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxTimer_P(timer0)->object_type;
                    argument_native_object = (void*) Z_wxTimer_P(timer0)->native_object;
                    object_pointer0_0 = (wxTimer*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        goto overload1;
                    }
                }
                else if(Z_TYPE_P(timer0) != IS_NULL)
                {
                    goto overload1;
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'Ol|b' (&timer1, php_wxTimer_entry, &milli1, &oneShot1)\n");
        #endif

        char parse_parameters_string[] = "Ol|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &timer1, php_wxTimer_entry, &milli1, &oneShot1 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(timer1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxTimer_P(timer1)->object_type;
                    argument_native_object = (void*) Z_wxTimer_P(timer1)->native_object;
                    object_pointer1_0 = (wxTimer*) argument_native_object;
                    if (!object_pointer1_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'timer' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(timer1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'timer' not null, could not be retreived correctly.");
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxTimer*) object_pointer0_0)\n");
                #endif

                native_object = new wxTimerRunner_php(*(wxTimer*) object_pointer0_0);

                native_object->references.Initialize();
                ((wxTimerRunner_php*) native_object)->references.AddReference(timer0, "wxTimerRunner::wxTimerRunner at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxTimer*) object_pointer1_0, (int) milli1)\n");
                #endif

                native_object = new wxTimerRunner_php(*(wxTimer*) object_pointer1_0, (int) milli1);

                native_object->references.Initialize();
                ((wxTimerRunner_php*) native_object)->references.AddReference(timer1, "wxTimerRunner::wxTimerRunner at call 4 with 2 argument(s)");
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxTimer*) object_pointer1_0, (int) milli1, oneShot1)\n");
                #endif

                native_object = new wxTimerRunner_php(*(wxTimer*) object_pointer1_0, (int) milli1, oneShot1);

                native_object->references.Initialize();
                ((wxTimerRunner_php*) native_object)->references.AddReference(timer1, "wxTimerRunner::wxTimerRunner at call 4 with 3 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxTimerRunner_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxTimerRunner::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxToolBarToolBase_free(void *object)
{
    zo_wxToolBarToolBase* custom_object = (zo_wxToolBarToolBase*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxToolBarToolBase_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxToolBarToolBase done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxToolBarToolBase_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxToolBarToolBase_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* custom_object;

    custom_object = (zo_wxToolBarToolBase*) ecalloc(
        1,
        sizeof(zo_wxToolBarToolBase)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxToolBarToolBase_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXTOOLBARTOOLBASE_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxToolBarToolBase::Detach() */
PHP_METHOD(php_wxToolBarToolBase, Detach)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::Detach\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::Detach call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxToolBarToolBase::Detach()\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    ((wxToolBarToolBase_php*)native_object)->Detach();
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::Detach\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::CanBeToggled() */
PHP_METHOD(php_wxToolBarToolBase, CanBeToggled)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::CanBeToggled\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::CanBeToggled call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxToolBarToolBase::CanBeToggled())\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    RETVAL_BOOL(((wxToolBarToolBase_php*)native_object)->CanBeToggled());
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::CanBeToggled\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::Enable(bool enable) */
PHP_METHOD(php_wxToolBarToolBase, Enable)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::Enable\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::Enable call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool enable0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'b' (&enable0)\n");
        #endif

        char parse_parameters_string[] = "b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &enable0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxToolBarToolBase::Enable(enable0))\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    RETVAL_BOOL(((wxToolBarToolBase_php*)native_object)->Enable(enable0));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::Enable\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmap wxToolBarToolBase::GetBitmap() */
PHP_METHOD(php_wxToolBarToolBase, GetBitmap)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::GetBitmap\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::GetBitmap call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxToolBarToolBase::GetBitmap() to return object reference\n\n");
                #endif

                wxBitmap_php* value_to_return0;
                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    value_to_return0 = (wxBitmap_php*) &((wxToolBarToolBase_php*)native_object)->GetBitmap();

                }
                if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxBitmap_entry);
                    Z_wxBitmap_P(return_value)->native_object = (wxBitmap_php*) value_to_return0;
                }

                if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxToolBarToolBase::GetBitmap at call 6 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::GetBitmap\n"
        );
    }
}
/* }}} */

/* {{{ proto wxObject wxToolBarToolBase::GetClientData() */
PHP_METHOD(php_wxToolBarToolBase, GetClientData)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::GetClientData\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::GetClientData call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxToolBarToolBase::GetClientData() to return object pointer\n\n");
                #endif

                wxObject_php* value_to_return0;
                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    value_to_return0 = (wxObject_php*) ((wxToolBarToolBase_php*)native_object)->GetClientData();

                }
                if(value_to_return0 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxObject_entry);
                    Z_wxObject_P(return_value)->native_object = (wxObject_php*) value_to_return0;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxToolBarToolBase::GetClientData at call 5 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::GetClientData\n"
        );
    }
}
/* }}} */

/* {{{ proto wxControl wxToolBarToolBase::GetControl() */
PHP_METHOD(php_wxToolBarToolBase, GetControl)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::GetControl\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::GetControl call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxToolBarToolBase::GetControl() to return object pointer\n\n");
                #endif

                wxControl_php* value_to_return0;
                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    value_to_return0 = (wxControl_php*) ((wxToolBarToolBase_php*)native_object)->GetControl();

                }
                if(value_to_return0 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxControl_entry);
                    Z_wxControl_P(return_value)->native_object = (wxControl_php*) value_to_return0;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxToolBarToolBase::GetControl at call 5 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::GetControl\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmap wxToolBarToolBase::GetDisabledBitmap() */
PHP_METHOD(php_wxToolBarToolBase, GetDisabledBitmap)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::GetDisabledBitmap\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::GetDisabledBitmap call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxToolBarToolBase::GetDisabledBitmap() to return object reference\n\n");
                #endif

                wxBitmap_php* value_to_return0;
                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    value_to_return0 = (wxBitmap_php*) &((wxToolBarToolBase_php*)native_object)->GetDisabledBitmap();

                }
                if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxBitmap_entry);
                    Z_wxBitmap_P(return_value)->native_object = (wxBitmap_php*) value_to_return0;
                }

                if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxToolBarToolBase::GetDisabledBitmap at call 6 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::GetDisabledBitmap\n"
        );
    }
}
/* }}} */

/* {{{ proto wxMenu wxToolBarToolBase::GetDropdownMenu() */
PHP_METHOD(php_wxToolBarToolBase, GetDropdownMenu)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::GetDropdownMenu\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::GetDropdownMenu call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxToolBarToolBase::GetDropdownMenu() to return object pointer\n\n");
                #endif

                wxMenu_php* value_to_return0;
                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    value_to_return0 = (wxMenu_php*) ((wxToolBarToolBase_php*)native_object)->GetDropdownMenu();

                }
                if(value_to_return0 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxMenu_entry);
                    Z_wxMenu_P(return_value)->native_object = (wxMenu_php*) value_to_return0;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxToolBarToolBase::GetDropdownMenu at call 5 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::GetDropdownMenu\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxToolBarToolBase::GetId() */
PHP_METHOD(php_wxToolBarToolBase, GetId)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::GetId\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::GetId call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxToolBarToolBase::GetId())\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    RETVAL_LONG(((wxToolBarToolBase_php*)native_object)->GetId());
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::GetId\n"
        );
    }
}
/* }}} */

/* {{{ proto wxItemKind wxToolBarToolBase::GetKind() */
PHP_METHOD(php_wxToolBarToolBase, GetKind)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::GetKind\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::GetKind call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxToolBarToolBase::GetKind())\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    RETVAL_LONG(((wxToolBarToolBase_php*)native_object)->GetKind());
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::GetKind\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxToolBarToolBase::GetLabel() */
PHP_METHOD(php_wxToolBarToolBase, GetLabel)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::GetLabel\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::GetLabel call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxToolBarToolBase::GetLabel().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    value_to_return0 = ((wxToolBarToolBase_php*)native_object)->GetLabel();
                }
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::GetLabel\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxToolBarToolBase::GetLongHelp() */
PHP_METHOD(php_wxToolBarToolBase, GetLongHelp)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::GetLongHelp\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::GetLongHelp call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxToolBarToolBase::GetLongHelp().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    value_to_return0 = ((wxToolBarToolBase_php*)native_object)->GetLongHelp();
                }
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::GetLongHelp\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmap wxToolBarToolBase::GetNormalBitmap() */
PHP_METHOD(php_wxToolBarToolBase, GetNormalBitmap)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::GetNormalBitmap\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::GetNormalBitmap call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxToolBarToolBase::GetNormalBitmap() to return object reference\n\n");
                #endif

                wxBitmap_php* value_to_return0;
                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    value_to_return0 = (wxBitmap_php*) &((wxToolBarToolBase_php*)native_object)->GetNormalBitmap();

                }
                if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxBitmap_entry);
                    Z_wxBitmap_P(return_value)->native_object = (wxBitmap_php*) value_to_return0;
                }

                if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxToolBarToolBase::GetNormalBitmap at call 6 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::GetNormalBitmap\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxToolBarToolBase::GetShortHelp() */
PHP_METHOD(php_wxToolBarToolBase, GetShortHelp)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::GetShortHelp\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::GetShortHelp call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxToolBarToolBase::GetShortHelp().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    value_to_return0 = ((wxToolBarToolBase_php*)native_object)->GetShortHelp();
                }
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::GetShortHelp\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxToolBarToolBase::GetStyle() */
PHP_METHOD(php_wxToolBarToolBase, GetStyle)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::GetStyle\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::GetStyle call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxToolBarToolBase::GetStyle())\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    RETVAL_LONG(((wxToolBarToolBase_php*)native_object)->GetStyle());
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::GetStyle\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::IsButton() */
PHP_METHOD(php_wxToolBarToolBase, IsButton)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::IsButton\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::IsButton call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxToolBarToolBase::IsButton())\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    RETVAL_BOOL(((wxToolBarToolBase_php*)native_object)->IsButton());
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::IsButton\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::IsControl() */
PHP_METHOD(php_wxToolBarToolBase, IsControl)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::IsControl\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::IsControl call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxToolBarToolBase::IsControl())\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    RETVAL_BOOL(((wxToolBarToolBase_php*)native_object)->IsControl());
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::IsControl\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::IsEnabled() */
PHP_METHOD(php_wxToolBarToolBase, IsEnabled)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::IsEnabled\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::IsEnabled call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxToolBarToolBase::IsEnabled())\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    RETVAL_BOOL(((wxToolBarToolBase_php*)native_object)->IsEnabled());
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::IsEnabled\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::IsSeparator() */
PHP_METHOD(php_wxToolBarToolBase, IsSeparator)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::IsSeparator\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::IsSeparator call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxToolBarToolBase::IsSeparator())\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    RETVAL_BOOL(((wxToolBarToolBase_php*)native_object)->IsSeparator());
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::IsSeparator\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::IsStretchable() */
PHP_METHOD(php_wxToolBarToolBase, IsStretchable)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::IsStretchable\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::IsStretchable call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxToolBarToolBase::IsStretchable())\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    RETVAL_BOOL(((wxToolBarToolBase_php*)native_object)->IsStretchable());
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::IsStretchable\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::IsStretchableSpace() */
PHP_METHOD(php_wxToolBarToolBase, IsStretchableSpace)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::IsStretchableSpace\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::IsStretchableSpace call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxToolBarToolBase::IsStretchableSpace())\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    RETVAL_BOOL(((wxToolBarToolBase_php*)native_object)->IsStretchableSpace());
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::IsStretchableSpace\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::IsToggled() */
PHP_METHOD(php_wxToolBarToolBase, IsToggled)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::IsToggled\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::IsToggled call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxToolBarToolBase::IsToggled())\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    RETVAL_BOOL(((wxToolBarToolBase_php*)native_object)->IsToggled());
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::IsToggled\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxToolBarToolBase::MakeStretchable() */
PHP_METHOD(php_wxToolBarToolBase, MakeStretchable)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::MakeStretchable\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::MakeStretchable call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxToolBarToolBase::MakeStretchable()\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    ((wxToolBarToolBase_php*)native_object)->MakeStretchable();
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::MakeStretchable\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxToolBarToolBase::SetDropdownMenu(wxMenu &menu) */
PHP_METHOD(php_wxToolBarToolBase, SetDropdownMenu)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::SetDropdownMenu\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::SetDropdownMenu call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* menu0;
    wxMenu* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&menu0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &menu0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(menu0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxMenu_P(menu0)->object_type;
                    argument_native_object = (void*) Z_wxMenu_P(menu0)->native_object;
                    object_pointer0_0 = (wxMenu*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXMENU_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'menu' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(menu0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'menu' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxToolBarToolBase::SetDropdownMenu((wxMenu*) object_pointer0_0)\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    ((wxToolBarToolBase_php*)native_object)->SetDropdownMenu((wxMenu*) object_pointer0_0);
                }

                references->AddReference(menu0, "wxToolBarToolBase::SetDropdownMenu at call 1 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::SetDropdownMenu\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxToolBarToolBase::SetLabel(string label) */
PHP_METHOD(php_wxToolBarToolBase, SetLabel)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::SetLabel\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::SetLabel call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* label0;
    size_t label_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&label0, &label_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &label0, &label_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxToolBarToolBase::SetLabel(wxString(label0, wxConvUTF8))\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    ((wxToolBarToolBase_php*)native_object)->SetLabel(wxString(label0, wxConvUTF8));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::SetLabel\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::SetLongHelp(string help) */
PHP_METHOD(php_wxToolBarToolBase, SetLongHelp)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::SetLongHelp\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::SetLongHelp call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* help0;
    size_t help_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&help0, &help_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &help0, &help_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxToolBarToolBase::SetLongHelp(wxString(help0, wxConvUTF8)))\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    RETVAL_BOOL(((wxToolBarToolBase_php*)native_object)->SetLongHelp(wxString(help0, wxConvUTF8)));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::SetLongHelp\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxToolBarToolBase::SetNormalBitmap(wxBitmap bmp) */
PHP_METHOD(php_wxToolBarToolBase, SetNormalBitmap)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::SetNormalBitmap\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::SetNormalBitmap call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* bmp0;
    wxBitmap* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&bmp0, php_wxBitmap_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bmp0, php_wxBitmap_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bmp0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bmp0)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bmp0)->native_object;
                    object_pointer0_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'bmp' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(bmp0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'bmp' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxToolBarToolBase::SetNormalBitmap(*(wxBitmap*) object_pointer0_0)\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    ((wxToolBarToolBase_php*)native_object)->SetNormalBitmap(*(wxBitmap*) object_pointer0_0);
                }

                references->AddReference(bmp0, "wxToolBarToolBase::SetNormalBitmap at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::SetNormalBitmap\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::SetShortHelp(string help) */
PHP_METHOD(php_wxToolBarToolBase, SetShortHelp)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::SetShortHelp\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::SetShortHelp call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* help0;
    size_t help_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&help0, &help_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &help0, &help_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxToolBarToolBase::SetShortHelp(wxString(help0, wxConvUTF8)))\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    RETVAL_BOOL(((wxToolBarToolBase_php*)native_object)->SetShortHelp(wxString(help0, wxConvUTF8)));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::SetShortHelp\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::SetToggle(bool toggle) */
PHP_METHOD(php_wxToolBarToolBase, SetToggle)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::SetToggle\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::SetToggle call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool toggle0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'b' (&toggle0)\n");
        #endif

        char parse_parameters_string[] = "b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &toggle0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxToolBarToolBase::SetToggle(toggle0))\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    RETVAL_BOOL(((wxToolBarToolBase_php*)native_object)->SetToggle(toggle0));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::SetToggle\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxToolBarToolBase::Toggle() */
PHP_METHOD(php_wxToolBarToolBase, Toggle)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::Toggle\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::Toggle call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxToolBarToolBase::Toggle()\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    ((wxToolBarToolBase_php*)native_object)->Toggle();
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::Toggle\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxToolBarToolBase::SetDisabledBitmap(wxBitmap bmp) */
PHP_METHOD(php_wxToolBarToolBase, SetDisabledBitmap)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::SetDisabledBitmap\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::SetDisabledBitmap call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* bmp0;
    wxBitmap* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&bmp0, php_wxBitmap_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bmp0, php_wxBitmap_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(bmp0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxBitmap_P(bmp0)->object_type;
                    argument_native_object = (void*) Z_wxBitmap_P(bmp0)->native_object;
                    object_pointer0_0 = (wxBitmap*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'bmp' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(bmp0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'bmp' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxToolBarToolBase::SetDisabledBitmap(*(wxBitmap*) object_pointer0_0)\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    ((wxToolBarToolBase_php*)native_object)->SetDisabledBitmap(*(wxBitmap*) object_pointer0_0);
                }

                references->AddReference(bmp0, "wxToolBarToolBase::SetDisabledBitmap at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::SetDisabledBitmap\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxToolBarToolBase::SetClientData(wxObject &clientData) */
PHP_METHOD(php_wxToolBarToolBase, SetClientData)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxToolBarToolBase::SetClientData\n");
    php_printf("===========================================\n");
    #endif

    zo_wxToolBarToolBase* current_object;
    wxphp_object_type current_object_type;
    wxToolBarToolBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxToolBarToolBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxToolBarToolBase::SetClientData call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
                references = &((wxToolBarToolBase_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* clientData0;
    wxObject* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&clientData0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &clientData0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(clientData0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxObject_P(clientData0)->object_type;
                    argument_native_object = (void*) Z_wxObject_P(clientData0)->native_object;
                    object_pointer0_0 = (wxObject*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXOBJECT_TYPE && argument_type != PHP_WXEVTHANDLER_TYPE && argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE && argument_type != PHP_WXVALIDATOR_TYPE && argument_type != PHP_WXTEXTVALIDATOR_TYPE && argument_type != PHP_WXGENERICVALIDATOR_TYPE && argument_type != PHP_WXMENU_TYPE && argument_type != PHP_WXAUIMANAGER_TYPE && argument_type != PHP_WXMOUSEEVENTSMANAGER_TYPE && argument_type != PHP_WXTIMER_TYPE && argument_type != PHP_WXEVENTBLOCKER_TYPE && argument_type != PHP_WXPROCESS_TYPE && argument_type != PHP_WXFILESYSTEMWATCHER_TYPE && argument_type != PHP_WXTASKBARICON_TYPE && argument_type != PHP_WXNOTIFICATIONMESSAGE_TYPE && argument_type != PHP_WXBITMAPHANDLER_TYPE && argument_type != PHP_WXIMAGE_TYPE && argument_type != PHP_WXSIZER_TYPE && argument_type != PHP_WXBOXSIZER_TYPE && argument_type != PHP_WXSTATICBOXSIZER_TYPE && argument_type != PHP_WXWRAPSIZER_TYPE && argument_type != PHP_WXSTDDIALOGBUTTONSIZER_TYPE && argument_type != PHP_WXGRIDSIZER_TYPE && argument_type != PHP_WXFLEXGRIDSIZER_TYPE && argument_type != PHP_WXGRIDBAGSIZER_TYPE && argument_type != PHP_WXSIZERITEM_TYPE && argument_type != PHP_WXGBSIZERITEM_TYPE && argument_type != PHP_WXIMAGELIST_TYPE && argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE && argument_type != PHP_WXCOLOUR_TYPE && argument_type != PHP_WXMENUITEM_TYPE && argument_type != PHP_WXEVENT_TYPE && argument_type != PHP_WXMENUEVENT_TYPE && argument_type != PHP_WXKEYEVENT_TYPE && argument_type != PHP_WXCOMMANDEVENT_TYPE && argument_type != PHP_WXNOTIFYEVENT_TYPE && argument_type != PHP_WXTREEEVENT_TYPE && argument_type != PHP_WXBOOKCTRLEVENT_TYPE && argument_type != PHP_WXAUINOTEBOOKEVENT_TYPE && argument_type != PHP_WXAUITOOLBAREVENT_TYPE && argument_type != PHP_WXLISTEVENT_TYPE && argument_type != PHP_WXSPINEVENT_TYPE && argument_type != PHP_WXSPLITTEREVENT_TYPE && argument_type != PHP_WXSPINDOUBLEEVENT_TYPE && argument_type != PHP_WXGRIDSIZEEVENT_TYPE && argument_type != PHP_WXWIZARDEVENT_TYPE && argument_type != PHP_WXGRIDEVENT_TYPE && argument_type != PHP_WXGRIDRANGESELECTEVENT_TYPE && argument_type != PHP_WXDATAVIEWEVENT_TYPE && argument_type != PHP_WXHEADERCTRLEVENT_TYPE && argument_type != PHP_WXRIBBONBAREVENT_TYPE && argument_type != PHP_WXMEDIAEVENT_TYPE && argument_type != PHP_WXSTYLEDTEXTEVENT_TYPE && argument_type != PHP_WXCHILDFOCUSEVENT_TYPE && argument_type != PHP_WXHTMLCELLEVENT_TYPE && argument_type != PHP_WXHTMLLINKEVENT_TYPE && argument_type != PHP_WXHYPERLINKEVENT_TYPE && argument_type != PHP_WXCOLOURPICKEREVENT_TYPE && argument_type != PHP_WXFONTPICKEREVENT_TYPE && argument_type != PHP_WXSCROLLEVENT_TYPE && argument_type != PHP_WXWINDOWMODALDIALOGEVENT_TYPE && argument_type != PHP_WXDATEEVENT_TYPE && argument_type != PHP_WXCALENDAREVENT_TYPE && argument_type != PHP_WXWINDOWCREATEEVENT_TYPE && argument_type != PHP_WXWINDOWDESTROYEVENT_TYPE && argument_type != PHP_WXUPDATEUIEVENT_TYPE && argument_type != PHP_WXHELPEVENT_TYPE && argument_type != PHP_WXGRIDEDITORCREATEDEVENT_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANEEVENT_TYPE && argument_type != PHP_WXCLIPBOARDTEXTEVENT_TYPE && argument_type != PHP_WXFILECTRLEVENT_TYPE && argument_type != PHP_WXSASHEVENT_TYPE && argument_type != PHP_WXFILEDIRPICKEREVENT_TYPE && argument_type != PHP_WXCONTEXTMENUEVENT_TYPE && argument_type != PHP_WXRIBBONBUTTONBAREVENT_TYPE && argument_type != PHP_WXRIBBONGALLERYEVENT_TYPE && argument_type != PHP_WXCLOSEEVENT_TYPE && argument_type != PHP_WXACTIVATEEVENT_TYPE && argument_type != PHP_WXAUIMANAGEREVENT_TYPE && argument_type != PHP_WXSIZEEVENT_TYPE && argument_type != PHP_WXMOUSEEVENT_TYPE && argument_type != PHP_WXMOVEEVENT_TYPE && argument_type != PHP_WXTIMEREVENT_TYPE && argument_type != PHP_WXTHREADEVENT_TYPE && argument_type != PHP_WXSCROLLWINEVENT_TYPE && argument_type != PHP_WXSYSCOLOURCHANGEDEVENT_TYPE && argument_type != PHP_WXPROCESSEVENT_TYPE && argument_type != PHP_WXERASEEVENT_TYPE && argument_type != PHP_WXSETCURSOREVENT_TYPE && argument_type != PHP_WXIDLEEVENT_TYPE && argument_type != PHP_WXPAINTEVENT_TYPE && argument_type != PHP_WXPALETTECHANGEDEVENT_TYPE && argument_type != PHP_WXINITDIALOGEVENT_TYPE && argument_type != PHP_WXMAXIMIZEEVENT_TYPE && argument_type != PHP_WXNAVIGATIONKEYEVENT_TYPE && argument_type != PHP_WXFOCUSEVENT_TYPE && argument_type != PHP_WXFILESYSTEMWATCHEREVENT_TYPE && argument_type != PHP_WXDISPLAYCHANGEDEVENT_TYPE && argument_type != PHP_WXCALCULATELAYOUTEVENT_TYPE && argument_type != PHP_WXQUERYLAYOUTINFOEVENT_TYPE && argument_type != PHP_WXTASKBARICONEVENT_TYPE && argument_type != PHP_WXACCELERATORTABLE_TYPE && argument_type != PHP_WXGDIOBJECT_TYPE && argument_type != PHP_WXBITMAP_TYPE && argument_type != PHP_WXPALETTE_TYPE && argument_type != PHP_WXICON_TYPE && argument_type != PHP_WXFONT_TYPE && argument_type != PHP_WXANIMATION_TYPE && argument_type != PHP_WXICONBUNDLE_TYPE && argument_type != PHP_WXCURSOR_TYPE && argument_type != PHP_WXREGION_TYPE && argument_type != PHP_WXPEN_TYPE && argument_type != PHP_WXBRUSH_TYPE && argument_type != PHP_WXARTPROVIDER_TYPE && argument_type != PHP_WXHTMLCELL_TYPE && argument_type != PHP_WXHTMLCONTAINERCELL_TYPE && argument_type != PHP_WXHTMLCOLOURCELL_TYPE && argument_type != PHP_WXHTMLWIDGETCELL_TYPE && argument_type != PHP_WXHTMLEASYPRINTING_TYPE && argument_type != PHP_WXHTMLLINKINFO_TYPE && argument_type != PHP_WXFINDREPLACEDATA_TYPE && argument_type != PHP_WXSOUND_TYPE && argument_type != PHP_WXFILESYSTEM_TYPE && argument_type != PHP_WXFILESYSTEMHANDLER_TYPE && argument_type != PHP_WXMASK_TYPE && argument_type != PHP_WXTOOLTIP_TYPE && argument_type != PHP_WXGRAPHICSRENDERER_TYPE && argument_type != PHP_WXLAYOUTCONSTRAINTS_TYPE && argument_type != PHP_WXFSFILE_TYPE && argument_type != PHP_WXCOLOURDATA_TYPE && argument_type != PHP_WXFONTDATA_TYPE && argument_type != PHP_WXGRIDTABLEBASE_TYPE && argument_type != PHP_WXDATAVIEWRENDERER_TYPE && argument_type != PHP_WXDATAVIEWBITMAPRENDERER_TYPE && argument_type != PHP_WXDATAVIEWCHOICERENDERER_TYPE && argument_type != PHP_WXDATAVIEWCUSTOMRENDERER_TYPE && argument_type != PHP_WXDATAVIEWSPINRENDERER_TYPE && argument_type != PHP_WXDATAVIEWDATERENDERER_TYPE && argument_type != PHP_WXDATAVIEWICONTEXTRENDERER_TYPE && argument_type != PHP_WXDATAVIEWPROGRESSRENDERER_TYPE && argument_type != PHP_WXDATAVIEWTEXTRENDERER_TYPE && argument_type != PHP_WXDATAVIEWTOGGLERENDERER_TYPE && argument_type != PHP_WXDATAVIEWICONTEXT_TYPE && argument_type != PHP_WXVARIANT_TYPE && argument_type != PHP_WXCLIPBOARD_TYPE && argument_type != PHP_WXCONFIGBASE_TYPE && argument_type != PHP_WXFILECONFIG_TYPE && argument_type != PHP_WXXMLRESOURCE_TYPE && argument_type != PHP_WXPAGESETUPDIALOG_TYPE && argument_type != PHP_WXPAGESETUPDIALOGDATA_TYPE && argument_type != PHP_WXPRINTDIALOG_TYPE && argument_type != PHP_WXPRINTDIALOGDATA_TYPE && argument_type != PHP_WXPRINTDATA_TYPE && argument_type != PHP_WXPRINTPREVIEW_TYPE && argument_type != PHP_WXPRINTER_TYPE && argument_type != PHP_WXPRINTOUT_TYPE && argument_type != PHP_WXHTMLPRINTOUT_TYPE && argument_type != PHP_WXHTMLDCRENDERER_TYPE && argument_type != PHP_WXHTMLFILTER_TYPE && argument_type != PHP_WXHTMLHELPDATA_TYPE && argument_type != PHP_WXHTMLTAGHANDLER_TYPE && argument_type != PHP_WXHTMLWINTAGHANDLER_TYPE && argument_type != PHP_WXMODULE_TYPE && argument_type != PHP_WXHTMLTAGSMODULE_TYPE && argument_type != PHP_WXIMAGEHANDLER_TYPE && argument_type != PHP_WXXMLRESOURCEHANDLER_TYPE && argument_type != PHP_WXXMLDOCUMENT_TYPE && argument_type != PHP_WXLAYOUTALGORITHM_TYPE && argument_type != PHP_WXFILEHISTORY_TYPE && argument_type != PHP_WXTOOLBARTOOLBASE_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'clientData' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(clientData0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'clientData' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxToolBarToolBase::SetClientData((wxObject*) object_pointer0_0)\n\n");
                #endif

                if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
                {
                    ((wxToolBarToolBase_php*)native_object)->SetClientData((wxObject*) object_pointer0_0);
                }

                references->AddReference(clientData0, "wxToolBarToolBase::SetClientData at call 1 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxToolBarToolBase::SetClientData\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxTextCompleterSimple_free(void *object)
{
    zo_wxTextCompleterSimple* custom_object = (zo_wxTextCompleterSimple*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxTextCompleterSimple_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxTextCompleterSimple done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxTextCompleterSimple_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxTextCompleterSimple_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxTextCompleterSimple* custom_object;

    custom_object = (zo_wxTextCompleterSimple*) ecalloc(
        1,
        sizeof(zo_wxTextCompleterSimple)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxTextCompleterSimple_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXTEXTCOMPLETERSIMPLE_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxTextCompleterSimple::GetCompletions(string prefix, array &res)
   Pure virtual method returning all possible completions for the given prefix. */
void wxTextCompleterSimple_php::GetCompletions(const wxString& prefix, wxArrayString& res)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxTextCompleterSimple::GetCompletions\n");
    php_printf("===========================================\n");
    #endif

    zval* params[2];
    zval arguments[2];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "GetCompletions");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    ZVAL_STRING(&arguments[0], prefix.ToUTF8().data());
    array_init(&arguments[1]);
    for(int i=0; i<res.GetCount(); i++)
    {
        add_next_index_string(&arguments[1], res[i].ToUTF8().data());
    }
    
    for(int i=0; i<2; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "GetCompletions");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "GetCompletions",
            14,
            &function_return_value,
            2,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<2; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxTextCompleterSimple::GetCompletions'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return;

}
/* }}} */

