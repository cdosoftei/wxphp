/*
 * @author Mário Soares
 * @contributors Jefferson González
 * @contributors René Vögeli / Rangee GmbH
 * 
 * @license 
 * This file is part of wxPHP check the LICENSE file for information.
 * 
 * @note
 * This file was auto-generated by the wxPHP source maker
*/

#include "php_wxwidgets.h"
#include "appmanagement.h"
#include "cfg.h"
#include "bookctrl.h"
#include "dnd.h"
#include "cmndlg.h"
#include "containers.h"
#include "ctrl.h"
#include "data.h"
#include "dc.h"
#include "docview.h"
#include "events.h"
#include "file.h"
#include "gdi.h"
#include "grid.h"
#include "html.h"
#include "help.h"
#include "logging.h"
#include "managedwnd.h"
#include "menus.h"
#include "misc.h"
#include "miscwnd.h"
#include "media.h"
#include "net.h"
#include "pickers.h"
#include "printing.h"
#include "ribbon.h"
#include "richtext.h"
#include "rtti.h"
#include "stc.h"
#include "streams.h"
#include "threading.h"
#include "validator.h"
#include "vfs.h"
#include "aui.h"
#include "winlayout.h"
#include "xml.h"
#include "xrc.h"
#include "dvc.h"
#include "others.h"


BEGIN_EXTERN_C()
void php_wxArtProvider_free(void *object)
{
    zo_wxArtProvider* custom_object = (zo_wxArtProvider*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxArtProvider_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxArtProvider done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxArtProvider_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxArtProvider_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxArtProvider* custom_object;

    custom_object = (zo_wxArtProvider*) ecalloc(
        1,
        sizeof(zo_wxArtProvider)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxArtProvider_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXARTPROVIDER_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto bool wxArtProvider::Remove(wxArtProvider &provider)
   Remove a provider from the stack if it is on it. */
PHP_METHOD(php_wxArtProvider, Remove)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxArtProvider::Remove\n");
    php_printf("===========================================\n");
    #endif

    zo_wxArtProvider* current_object;
    wxphp_object_type current_object_type;
    wxArtProvider_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxArtProvider_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxArtProvider::Remove call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXARTPROVIDER_TYPE){
                references = &((wxArtProvider_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* provider0;
    wxArtProvider* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&provider0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &provider0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(provider0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxArtProvider_P(provider0)->object_type;
                    argument_native_object = (void*) Z_wxArtProvider_P(provider0)->native_object;
                    object_pointer0_0 = (wxArtProvider*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXARTPROVIDER_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'provider' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(provider0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'provider' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxArtProvider::Remove((wxArtProvider*) object_pointer0_0))\n\n");
                #endif

                RETVAL_BOOL(wxArtProvider::Remove((wxArtProvider*) object_pointer0_0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxArtProvider::Remove\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxArtProvider::PushBack(wxArtProvider &provider)
   Register new art provider and add it to the bottom of providers stack. */
PHP_METHOD(php_wxArtProvider, PushBack)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxArtProvider::PushBack\n");
    php_printf("===========================================\n");
    #endif

    zo_wxArtProvider* current_object;
    wxphp_object_type current_object_type;
    wxArtProvider_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxArtProvider_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxArtProvider::PushBack call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXARTPROVIDER_TYPE){
                references = &((wxArtProvider_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* provider0;
    wxArtProvider* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&provider0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &provider0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(provider0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxArtProvider_P(provider0)->object_type;
                    argument_native_object = (void*) Z_wxArtProvider_P(provider0)->native_object;
                    object_pointer0_0 = (wxArtProvider*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXARTPROVIDER_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'provider' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(provider0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'provider' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxArtProvider::PushBack((wxArtProvider*) object_pointer0_0)\n\n");
                #endif

                wxArtProvider::PushBack((wxArtProvider*) object_pointer0_0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxArtProvider::PushBack\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxArtProvider::Push(wxArtProvider &provider)
   Register new art provider and add it to the top of providers stack (i.e. */
PHP_METHOD(php_wxArtProvider, Push)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxArtProvider::Push\n");
    php_printf("===========================================\n");
    #endif

    zo_wxArtProvider* current_object;
    wxphp_object_type current_object_type;
    wxArtProvider_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxArtProvider_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxArtProvider::Push call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXARTPROVIDER_TYPE){
                references = &((wxArtProvider_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* provider0;
    wxArtProvider* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&provider0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &provider0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(provider0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxArtProvider_P(provider0)->object_type;
                    argument_native_object = (void*) Z_wxArtProvider_P(provider0)->native_object;
                    object_pointer0_0 = (wxArtProvider*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXARTPROVIDER_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'provider' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(provider0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'provider' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxArtProvider::Push((wxArtProvider*) object_pointer0_0)\n\n");
                #endif

                wxArtProvider::Push((wxArtProvider*) object_pointer0_0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxArtProvider::Push\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxArtProvider::Pop()
   Remove latest added provider and delete it. */
PHP_METHOD(php_wxArtProvider, Pop)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxArtProvider::Pop\n");
    php_printf("===========================================\n");
    #endif

    zo_wxArtProvider* current_object;
    wxphp_object_type current_object_type;
    wxArtProvider_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxArtProvider_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxArtProvider::Pop call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXARTPROVIDER_TYPE){
                references = &((wxArtProvider_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxArtProvider::Pop())\n\n");
                #endif

                RETVAL_BOOL(wxArtProvider::Pop());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxArtProvider::Pop\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxArtProvider::HasNativeProvider()
   Returns true if the platform uses native icons provider that should take precedence over any customizations. */
PHP_METHOD(php_wxArtProvider, HasNativeProvider)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxArtProvider::HasNativeProvider\n");
    php_printf("===========================================\n");
    #endif

    zo_wxArtProvider* current_object;
    wxphp_object_type current_object_type;
    wxArtProvider_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxArtProvider_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxArtProvider::HasNativeProvider call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXARTPROVIDER_TYPE){
                references = &((wxArtProvider_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxArtProvider::HasNativeProvider())\n\n");
                #endif

                RETVAL_BOOL(wxArtProvider::HasNativeProvider());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxArtProvider::HasNativeProvider\n"
        );
    }
}
/* }}} */

/* {{{ proto wxSize wxArtProvider::GetSizeHint(string client, bool platform_default)
   Returns a suitable size hint for the given wxArtClient. */
PHP_METHOD(php_wxArtProvider, GetSizeHint)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxArtProvider::GetSizeHint\n");
    php_printf("===========================================\n");
    #endif

    zo_wxArtProvider* current_object;
    wxphp_object_type current_object_type;
    wxArtProvider_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxArtProvider_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxArtProvider::GetSizeHint call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXARTPROVIDER_TYPE){
                references = &((wxArtProvider_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* client0;
    size_t client_len0;
    bool platform_default0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|b' (&client0, &client_len0, &platform_default0)\n");
        #endif

        char parse_parameters_string[] = "s|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &client0, &client_len0, &platform_default0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxArtProvider::GetSizeHint(wxString(client0, wxConvUTF8)) to return new object\n\n");
                #endif

                wxSize value_to_return1;
                value_to_return1 = wxArtProvider::GetSizeHint(wxString(client0, wxConvUTF8));
                void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxSize));
                object_init_ex(return_value, php_wxSize_entry);
                ((wxSize_php*)ptr)->phpObj = *return_value;
                zo_wxSize* zo1 = Z_wxSize_P(return_value);
                zo1->native_object = (wxSize_php*) ptr;


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxArtProvider::GetSizeHint(wxString(client0, wxConvUTF8), platform_default0) to return new object\n\n");
                #endif

                wxSize value_to_return2;
                value_to_return2 = wxArtProvider::GetSizeHint(wxString(client0, wxConvUTF8), platform_default0);
                void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
                memcpy(ptr, (void*) &value_to_return2, sizeof(wxSize));
                object_init_ex(return_value, php_wxSize_entry);
                ((wxSize_php*)ptr)->phpObj = *return_value;
                zo_wxSize* zo2 = Z_wxSize_P(return_value);
                zo2->native_object = (wxSize_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxArtProvider::GetSizeHint\n"
        );
    }
}
/* }}} */

/* {{{ proto wxSize wxArtProvider::GetNativeSizeHint(string client)
   Returns native icon size for use specified by client hint. */
PHP_METHOD(php_wxArtProvider, GetNativeSizeHint)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxArtProvider::GetNativeSizeHint\n");
    php_printf("===========================================\n");
    #endif

    zo_wxArtProvider* current_object;
    wxphp_object_type current_object_type;
    wxArtProvider_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxArtProvider_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxArtProvider::GetNativeSizeHint call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXARTPROVIDER_TYPE){
                references = &((wxArtProvider_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* client0;
    size_t client_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&client0, &client_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &client0, &client_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxArtProvider::GetNativeSizeHint(wxString(client0, wxConvUTF8)) to return new object\n\n");
                #endif

                wxSize value_to_return1;
                value_to_return1 = wxArtProvider::GetNativeSizeHint(wxString(client0, wxConvUTF8));
                void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxSize));
                object_init_ex(return_value, php_wxSize_entry);
                ((wxSize_php*)ptr)->phpObj = *return_value;
                zo_wxSize* zo1 = Z_wxSize_P(return_value);
                zo1->native_object = (wxSize_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxArtProvider::GetNativeSizeHint\n"
        );
    }
}
/* }}} */

/* {{{ proto wxIconBundle wxArtProvider::GetIconBundle(string id, string client)
   Query registered providers for icon bundle with given ID. */
PHP_METHOD(php_wxArtProvider, GetIconBundle)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxArtProvider::GetIconBundle\n");
    php_printf("===========================================\n");
    #endif

    zo_wxArtProvider* current_object;
    wxphp_object_type current_object_type;
    wxArtProvider_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxArtProvider_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxArtProvider::GetIconBundle call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXARTPROVIDER_TYPE){
                references = &((wxArtProvider_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* id0;
    size_t id_len0;
    char* client0;
    size_t client_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|s' (&id0, &id_len0, &client0, &client_len0)\n");
        #endif

        char parse_parameters_string[] = "s|s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &id0, &id_len0, &client0, &client_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxArtProvider::GetIconBundle(wxString(id0, wxConvUTF8)) to return new object\n\n");
                #endif

                wxIconBundle value_to_return1;
                value_to_return1 = wxArtProvider::GetIconBundle(wxString(id0, wxConvUTF8));
                #if !defined(__WXMSW__) && !defined(__WXMAC__)
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                #endif
                void* ptr = safe_emalloc(1, sizeof(wxIconBundle_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxIconBundle));
                object_init_ex(return_value, php_wxIconBundle_entry);
                ((wxIconBundle_php*)ptr)->phpObj = *return_value;
                zo_wxIconBundle* zo1 = Z_wxIconBundle_P(return_value);
                zo1->native_object = (wxIconBundle_php*) ptr;


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxArtProvider::GetIconBundle(wxString(id0, wxConvUTF8), wxString(client0, wxConvUTF8)) to return new object\n\n");
                #endif

                wxIconBundle value_to_return2;
                value_to_return2 = wxArtProvider::GetIconBundle(wxString(id0, wxConvUTF8), wxString(client0, wxConvUTF8));
                #if !defined(__WXMSW__) && !defined(__WXMAC__)
                ((wxRefCounter *) value_to_return2.GetRefData())->IncRef();
                #endif
                void* ptr = safe_emalloc(1, sizeof(wxIconBundle_php), 0);
                memcpy(ptr, (void*) &value_to_return2, sizeof(wxIconBundle));
                object_init_ex(return_value, php_wxIconBundle_entry);
                ((wxIconBundle_php*)ptr)->phpObj = *return_value;
                zo_wxIconBundle* zo2 = Z_wxIconBundle_P(return_value);
                zo2->native_object = (wxIconBundle_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxArtProvider::GetIconBundle\n"
        );
    }
}
/* }}} */

/* {{{ proto wxIcon wxArtProvider::GetIcon(string id, string client, wxSize size)
   Same as wxArtProvider::GetBitmap, but return a wxIcon object (or wxNullIcon on failure). */
PHP_METHOD(php_wxArtProvider, GetIcon)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxArtProvider::GetIcon\n");
    php_printf("===========================================\n");
    #endif

    zo_wxArtProvider* current_object;
    wxphp_object_type current_object_type;
    wxArtProvider_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxArtProvider_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxArtProvider::GetIcon call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXARTPROVIDER_TYPE){
                references = &((wxArtProvider_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* id0;
    size_t id_len0;
    char* client0;
    size_t client_len0;
    zval* size0;
    wxSize* object_pointer0_2 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|sO' (&id0, &id_len0, &client0, &client_len0, &size0, php_wxSize_entry)\n");
        #endif

        char parse_parameters_string[] = "s|sO";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &id0, &id_len0, &client0, &client_len0, &size0, php_wxSize_entry ) == SUCCESS)
        {
            if(arguments_received >= 3){
                if(Z_TYPE_P(size0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(size0)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(size0)->native_object;
                    object_pointer0_2 = (wxSize*) argument_native_object;
                    if (!object_pointer0_2 )
                    {
                        zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(size0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxArtProvider::GetIcon(wxString(id0, wxConvUTF8)) to return new object\n\n");
                #endif

                wxIcon value_to_return1;
                value_to_return1 = wxArtProvider::GetIcon(wxString(id0, wxConvUTF8));
                #if !defined(__WXMSW__) && !defined(__WXMAC__)
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                #endif
                void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxIcon));
                object_init_ex(return_value, php_wxIcon_entry);
                ((wxIcon_php*)ptr)->phpObj = *return_value;
                zo_wxIcon* zo1 = Z_wxIcon_P(return_value);
                zo1->native_object = (wxIcon_php*) ptr;


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxArtProvider::GetIcon(wxString(id0, wxConvUTF8), wxString(client0, wxConvUTF8)) to return new object\n\n");
                #endif

                wxIcon value_to_return2;
                value_to_return2 = wxArtProvider::GetIcon(wxString(id0, wxConvUTF8), wxString(client0, wxConvUTF8));
                #if !defined(__WXMSW__) && !defined(__WXMAC__)
                ((wxRefCounter *) value_to_return2.GetRefData())->IncRef();
                #endif
                void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
                memcpy(ptr, (void*) &value_to_return2, sizeof(wxIcon));
                object_init_ex(return_value, php_wxIcon_entry);
                ((wxIcon_php*)ptr)->phpObj = *return_value;
                zo_wxIcon* zo2 = Z_wxIcon_P(return_value);
                zo2->native_object = (wxIcon_php*) ptr;


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxArtProvider::GetIcon(wxString(id0, wxConvUTF8), wxString(client0, wxConvUTF8), *(wxSize*) object_pointer0_2) to return new object\n\n");
                #endif

                wxIcon value_to_return3;
                value_to_return3 = wxArtProvider::GetIcon(wxString(id0, wxConvUTF8), wxString(client0, wxConvUTF8), *(wxSize*) object_pointer0_2);
                #if !defined(__WXMSW__) && !defined(__WXMAC__)
                ((wxRefCounter *) value_to_return3.GetRefData())->IncRef();
                #endif
                void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
                memcpy(ptr, (void*) &value_to_return3, sizeof(wxIcon));
                object_init_ex(return_value, php_wxIcon_entry);
                ((wxIcon_php*)ptr)->phpObj = *return_value;
                zo_wxIcon* zo3 = Z_wxIcon_P(return_value);
                zo3->native_object = (wxIcon_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxArtProvider::GetIcon\n"
        );
    }
}
/* }}} */

/* {{{ proto wxBitmap wxArtProvider::GetBitmap(string id, string client, wxSize size)
   Query registered providers for bitmap with given ID. */
PHP_METHOD(php_wxArtProvider, GetBitmap)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxArtProvider::GetBitmap\n");
    php_printf("===========================================\n");
    #endif

    zo_wxArtProvider* current_object;
    wxphp_object_type current_object_type;
    wxArtProvider_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxArtProvider_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxArtProvider::GetBitmap call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXARTPROVIDER_TYPE){
                references = &((wxArtProvider_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* id0;
    size_t id_len0;
    char* client0;
    size_t client_len0;
    zval* size0;
    wxSize* object_pointer0_2 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|sO' (&id0, &id_len0, &client0, &client_len0, &size0, php_wxSize_entry)\n");
        #endif

        char parse_parameters_string[] = "s|sO";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &id0, &id_len0, &client0, &client_len0, &size0, php_wxSize_entry ) == SUCCESS)
        {
            if(arguments_received >= 3){
                if(Z_TYPE_P(size0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(size0)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(size0)->native_object;
                    object_pointer0_2 = (wxSize*) argument_native_object;
                    if (!object_pointer0_2 )
                    {
                        zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(size0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxArtProvider::GetBitmap(wxString(id0, wxConvUTF8)) to return new object\n\n");
                #endif

                wxBitmap value_to_return1;
                value_to_return1 = wxArtProvider::GetBitmap(wxString(id0, wxConvUTF8));
                #if !defined(__WXMSW__) && !defined(__WXMAC__)
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                #endif
                void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxBitmap));
                object_init_ex(return_value, php_wxBitmap_entry);
                ((wxBitmap_php*)ptr)->phpObj = *return_value;
                zo_wxBitmap* zo1 = Z_wxBitmap_P(return_value);
                zo1->native_object = (wxBitmap_php*) ptr;


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxArtProvider::GetBitmap(wxString(id0, wxConvUTF8), wxString(client0, wxConvUTF8)) to return new object\n\n");
                #endif

                wxBitmap value_to_return2;
                value_to_return2 = wxArtProvider::GetBitmap(wxString(id0, wxConvUTF8), wxString(client0, wxConvUTF8));
                #if !defined(__WXMSW__) && !defined(__WXMAC__)
                ((wxRefCounter *) value_to_return2.GetRefData())->IncRef();
                #endif
                void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
                memcpy(ptr, (void*) &value_to_return2, sizeof(wxBitmap));
                object_init_ex(return_value, php_wxBitmap_entry);
                ((wxBitmap_php*)ptr)->phpObj = *return_value;
                zo_wxBitmap* zo2 = Z_wxBitmap_P(return_value);
                zo2->native_object = (wxBitmap_php*) ptr;


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxArtProvider::GetBitmap(wxString(id0, wxConvUTF8), wxString(client0, wxConvUTF8), *(wxSize*) object_pointer0_2) to return new object\n\n");
                #endif

                wxBitmap value_to_return3;
                value_to_return3 = wxArtProvider::GetBitmap(wxString(id0, wxConvUTF8), wxString(client0, wxConvUTF8), *(wxSize*) object_pointer0_2);
                #if !defined(__WXMSW__) && !defined(__WXMAC__)
                ((wxRefCounter *) value_to_return3.GetRefData())->IncRef();
                #endif
                void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
                memcpy(ptr, (void*) &value_to_return3, sizeof(wxBitmap));
                object_init_ex(return_value, php_wxBitmap_entry);
                ((wxBitmap_php*)ptr)->phpObj = *return_value;
                zo_wxBitmap* zo3 = Z_wxBitmap_P(return_value);
                zo3->native_object = (wxBitmap_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxArtProvider::GetBitmap\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxArtProvider::Delete(wxArtProvider &provider)
   Delete the given provider. */
PHP_METHOD(php_wxArtProvider, Delete)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxArtProvider::Delete\n");
    php_printf("===========================================\n");
    #endif

    zo_wxArtProvider* current_object;
    wxphp_object_type current_object_type;
    wxArtProvider_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxArtProvider_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxArtProvider::Delete call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXARTPROVIDER_TYPE){
                references = &((wxArtProvider_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* provider0;
    wxArtProvider* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&provider0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &provider0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(provider0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxArtProvider_P(provider0)->object_type;
                    argument_native_object = (void*) Z_wxArtProvider_P(provider0)->native_object;
                    object_pointer0_0 = (wxArtProvider*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXARTPROVIDER_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'provider' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(provider0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'provider' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxArtProvider::Delete((wxArtProvider*) object_pointer0_0))\n\n");
                #endif

                RETVAL_BOOL(wxArtProvider::Delete((wxArtProvider*) object_pointer0_0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxArtProvider::Delete\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxCaret_free(void *object)
{
    zo_wxCaret* custom_object = (zo_wxCaret*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxCaret_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxCaret done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxCaret_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxCaret_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxCaret* custom_object;

    custom_object = (zo_wxCaret*) ecalloc(
        1,
        sizeof(zo_wxCaret)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxCaret_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXCARET_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxCaret::wxCaret()
   Default constructor. */
PHP_METHOD(php_wxCaret, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxCaret::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxCaret* current_object;
    wxCaret_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    zval* window1;
    wxWindow* object_pointer1_0 = 0;
    long width1;
    long height1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'zll' (&window1, &width1, &height1)\n");
        #endif

        char parse_parameters_string[] = "zll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &window1, &width1, &height1 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(window1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxWindow_P(window1)->object_type;
                    argument_native_object = (void*) Z_wxWindow_P(window1)->native_object;
                    object_pointer1_0 = (wxWindow*) argument_native_object;
                    if (!object_pointer1_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'window' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(window1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'window' not null, could not be retreived correctly.");
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxCaret_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxWindow*) object_pointer1_0, (int) width1, (int) height1)\n");
                #endif

                native_object = new wxCaret_php((wxWindow*) object_pointer1_0, (int) width1, (int) height1);

                native_object->references.Initialize();
                ((wxCaret_php*) native_object)->references.AddReference(window1, "wxCaret::wxCaret at call 2 with 3 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxCaret_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxCaret::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto  wxCaret::Show(bool show)
   Shows or hides the caret. */
PHP_METHOD(php_wxCaret, Show)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxCaret::Show\n");
    php_printf("===========================================\n");
    #endif

    zo_wxCaret* current_object;
    wxphp_object_type current_object_type;
    wxCaret_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxCaret_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxCaret::Show call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCARET_TYPE){
                references = &((wxCaret_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool show0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|b' (&show0)\n");
        #endif

        char parse_parameters_string[] = "|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &show0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxCaret::Show()\n\n");
                #endif

                ((wxCaret_php*)native_object)->Show();


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxCaret::Show(show0)\n\n");
                #endif

                ((wxCaret_php*)native_object)->Show(show0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxCaret::Show\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxCaret::SetSize(wxSize size)
   Changes the size of the caret. */
PHP_METHOD(php_wxCaret, SetSize)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxCaret::SetSize\n");
    php_printf("===========================================\n");
    #endif

    zo_wxCaret* current_object;
    wxphp_object_type current_object_type;
    wxCaret_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxCaret_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxCaret::SetSize call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCARET_TYPE){
                references = &((wxCaret_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* size0;
    wxSize* object_pointer0_0 = 0;
    bool overload0_called = false;

    //Parameters for overload 1
    long width1;
    long height1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&size0, php_wxSize_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &size0, php_wxSize_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(size0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxSize_P(size0)->object_type;
                    argument_native_object = (void*) Z_wxSize_P(size0)->native_object;
                    object_pointer0_0 = (wxSize*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        goto overload1;
                    }
                }
                else if(Z_TYPE_P(size0) != IS_NULL)
                {
                    goto overload1;
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (&width1, &height1)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &width1, &height1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxCaret::SetSize(*(wxSize*) object_pointer0_0)\n\n");
                #endif

                ((wxCaret_php*)native_object)->SetSize(*(wxSize*) object_pointer0_0);

                references->AddReference(size0, "wxCaret::SetSize at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxCaret::SetSize((int) width1, (int) height1)\n\n");
                #endif

                ((wxCaret_php*)native_object)->SetSize((int) width1, (int) height1);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxCaret::SetSize\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxCaret::SetBlinkTime(int milliseconds)
   Sets the blink time for all the carets. */
PHP_METHOD(php_wxCaret, SetBlinkTime)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxCaret::SetBlinkTime\n");
    php_printf("===========================================\n");
    #endif

    zo_wxCaret* current_object;
    wxphp_object_type current_object_type;
    wxCaret_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxCaret_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxCaret::SetBlinkTime call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCARET_TYPE){
                references = &((wxCaret_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long milliseconds0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&milliseconds0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &milliseconds0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxCaret::SetBlinkTime((int) milliseconds0)\n\n");
                #endif

                wxCaret::SetBlinkTime((int) milliseconds0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxCaret::SetBlinkTime\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxCaret::Move(wxPoint pt)
   Move the caret to given position (in logical coordinates). */
PHP_METHOD(php_wxCaret, Move)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxCaret::Move\n");
    php_printf("===========================================\n");
    #endif

    zo_wxCaret* current_object;
    wxphp_object_type current_object_type;
    wxCaret_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxCaret_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxCaret::Move call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCARET_TYPE){
                references = &((wxCaret_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* pt0;
    wxPoint* object_pointer0_0 = 0;
    bool overload0_called = false;

    //Parameters for overload 1
    long x1;
    long y1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&pt0, php_wxPoint_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pt0, php_wxPoint_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(pt0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPoint_P(pt0)->object_type;
                    argument_native_object = (void*) Z_wxPoint_P(pt0)->native_object;
                    object_pointer0_0 = (wxPoint*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        goto overload1;
                    }
                }
                else if(Z_TYPE_P(pt0) != IS_NULL)
                {
                    goto overload1;
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (&x1, &y1)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &x1, &y1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxCaret::Move(*(wxPoint*) object_pointer0_0)\n\n");
                #endif

                ((wxCaret_php*)native_object)->Move(*(wxPoint*) object_pointer0_0);

                references->AddReference(pt0, "wxCaret::Move at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxCaret::Move((int) x1, (int) y1)\n\n");
                #endif

                ((wxCaret_php*)native_object)->Move((int) x1, (int) y1);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxCaret::Move\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxCaret::IsVisible()
   Returns true if the caret is visible and false if it is permanently hidden (if it is blinking and not shown currently but will be after the next blink, this method still returns true). */
PHP_METHOD(php_wxCaret, IsVisible)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxCaret::IsVisible\n");
    php_printf("===========================================\n");
    #endif

    zo_wxCaret* current_object;
    wxphp_object_type current_object_type;
    wxCaret_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxCaret_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxCaret::IsVisible call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCARET_TYPE){
                references = &((wxCaret_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxCaret::IsVisible())\n\n");
                #endif

                RETVAL_BOOL(((wxCaret_php*)native_object)->IsVisible());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxCaret::IsVisible\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxCaret::IsOk()
   Returns true if the caret was created successfully. */
PHP_METHOD(php_wxCaret, IsOk)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxCaret::IsOk\n");
    php_printf("===========================================\n");
    #endif

    zo_wxCaret* current_object;
    wxphp_object_type current_object_type;
    wxCaret_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxCaret_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxCaret::IsOk call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCARET_TYPE){
                references = &((wxCaret_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxCaret::IsOk())\n\n");
                #endif

                RETVAL_BOOL(((wxCaret_php*)native_object)->IsOk());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxCaret::IsOk\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxCaret::Hide()
   Hides the caret, same as Show(false). */
PHP_METHOD(php_wxCaret, Hide)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxCaret::Hide\n");
    php_printf("===========================================\n");
    #endif

    zo_wxCaret* current_object;
    wxphp_object_type current_object_type;
    wxCaret_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxCaret_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxCaret::Hide call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCARET_TYPE){
                references = &((wxCaret_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxCaret::Hide()\n\n");
                #endif

                ((wxCaret_php*)native_object)->Hide();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxCaret::Hide\n"
        );
    }
}
/* }}} */

/* {{{ proto wxWindow wxCaret::GetWindow()
   Get the window the caret is associated with. */
PHP_METHOD(php_wxCaret, GetWindow)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxCaret::GetWindow\n");
    php_printf("===========================================\n");
    #endif

    zo_wxCaret* current_object;
    wxphp_object_type current_object_type;
    wxCaret_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxCaret_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxCaret::GetWindow call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCARET_TYPE){
                references = &((wxCaret_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxCaret::GetWindow() to return object pointer\n\n");
                #endif

                wxWindow_php* value_to_return0;
                value_to_return0 = (wxWindow_php*) ((wxCaret_php*)native_object)->GetWindow();

                if(value_to_return0 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxWindow_entry);
                    Z_wxWindow_P(return_value)->native_object = (wxWindow_php*) value_to_return0;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxCaret::GetWindow at call 5 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxCaret::GetWindow\n"
        );
    }
}
/* }}} */

/* {{{ proto wxSize wxCaret::GetSize()
   Get the caret size. */
PHP_METHOD(php_wxCaret, GetSize)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxCaret::GetSize\n");
    php_printf("===========================================\n");
    #endif

    zo_wxCaret* current_object;
    wxphp_object_type current_object_type;
    wxCaret_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxCaret_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxCaret::GetSize call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCARET_TYPE){
                references = &((wxCaret_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    long* width1;
    zval width1_ref;
    long* height1;
    zval height1_ref;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (width1, height1)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, width1, height1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;

            char parse_references_string[] = "zz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, width1_ref, height1_ref );
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxCaret::GetSize() to return new object\n\n");
                #endif

                wxSize value_to_return0;
                value_to_return0 = ((wxCaret_php*)native_object)->GetSize();
                void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxSize));
                object_init_ex(return_value, php_wxSize_entry);
                ((wxSize_php*)ptr)->phpObj = *return_value;
                zo_wxSize* zo0 = Z_wxSize_P(return_value);
                zo0->native_object = (wxSize_php*) ptr;


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxCaret::GetSize((int*) width1, (int*) height1)\n\n");
                #endif

                ((wxCaret_php*)native_object)->GetSize((int*) width1, (int*) height1);

                size_t elements_returned1_0 = sizeof(width1)/sizeof(*width1);
                array_init(&width1_ref);
                for(size_t i=0; i<elements_returned1_0; i++)
                {
                    add_next_index_long(&width1_ref, width1[i]);
                }
                size_t elements_returned1_1 = sizeof(height1)/sizeof(*height1);
                array_init(&height1_ref);
                for(size_t i=0; i<elements_returned1_1; i++)
                {
                    add_next_index_long(&height1_ref, height1[i]);
                }

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxCaret::GetSize\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxCaret::GetBlinkTime()
   Returns the blink time which is measured in milliseconds and is the time elapsed between 2 inversions of the caret (blink time of the caret is the same for all carets, so this functions is static). */
PHP_METHOD(php_wxCaret, GetBlinkTime)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxCaret::GetBlinkTime\n");
    php_printf("===========================================\n");
    #endif

    zo_wxCaret* current_object;
    wxphp_object_type current_object_type;
    wxCaret_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxCaret_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxCaret::GetBlinkTime call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCARET_TYPE){
                references = &((wxCaret_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_LONG(wxCaret::GetBlinkTime())\n\n");
                #endif

                RETVAL_LONG(wxCaret::GetBlinkTime());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxCaret::GetBlinkTime\n"
        );
    }
}
/* }}} */

/* {{{ proto wxPoint wxCaret::GetPosition()
   Get the caret position (in pixels). */
PHP_METHOD(php_wxCaret, GetPosition)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxCaret::GetPosition\n");
    php_printf("===========================================\n");
    #endif

    zo_wxCaret* current_object;
    wxphp_object_type current_object_type;
    wxCaret_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxCaret_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxCaret::GetPosition call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCARET_TYPE){
                references = &((wxCaret_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    long* x1;
    zval x1_ref;
    long* y1;
    zval y1_ref;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (x1, y1)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, x1, y1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;

            char parse_references_string[] = "zz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, x1_ref, y1_ref );
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxCaret::GetPosition() to return new object\n\n");
                #endif

                wxPoint value_to_return0;
                value_to_return0 = ((wxCaret_php*)native_object)->GetPosition();
                void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxPoint));
                object_init_ex(return_value, php_wxPoint_entry);
                ((wxPoint_php*)ptr)->phpObj = *return_value;
                ((wxPoint_php*)ptr)->InitProperties();
                zo_wxPoint* zo0 = Z_wxPoint_P(return_value);
                zo0->native_object = (wxPoint_php*) ptr;


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxCaret::GetPosition((int*) x1, (int*) y1)\n\n");
                #endif

                ((wxCaret_php*)native_object)->GetPosition((int*) x1, (int*) y1);

                size_t elements_returned1_0 = sizeof(x1)/sizeof(*x1);
                array_init(&x1_ref);
                for(size_t i=0; i<elements_returned1_0; i++)
                {
                    add_next_index_long(&x1_ref, x1[i]);
                }
                size_t elements_returned1_1 = sizeof(y1)/sizeof(*y1);
                array_init(&y1_ref);
                for(size_t i=0; i<elements_returned1_1; i++)
                {
                    add_next_index_long(&y1_ref, y1[i]);
                }

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxCaret::GetPosition\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxNotificationMessage_free(void *object)
{
    zo_wxNotificationMessage* custom_object = (zo_wxNotificationMessage*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxNotificationMessage_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxNotificationMessage done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxNotificationMessage_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxNotificationMessage_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxNotificationMessage* custom_object;

    custom_object = (zo_wxNotificationMessage*) ecalloc(
        1,
        sizeof(zo_wxNotificationMessage)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxNotificationMessage_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXNOTIFICATIONMESSAGE_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto bool wxNotificationMessage::Close()
   Hides the notification. */
PHP_METHOD(php_wxNotificationMessage, Close)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNotificationMessage::Close\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNotificationMessage* current_object;
    wxphp_object_type current_object_type;
    wxNotificationMessage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNotificationMessage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNotificationMessage::Close call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNOTIFICATIONMESSAGE_TYPE){
                references = &((wxNotificationMessage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxNotificationMessage::Close())\n\n");
                #endif

                RETVAL_BOOL(((wxNotificationMessage_php*)native_object)->Close());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNotificationMessage::Close\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxNotificationMessage::SetFlags(int flags)
   This parameter can be currently used to specify the icon to show in the notification. */
PHP_METHOD(php_wxNotificationMessage, SetFlags)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNotificationMessage::SetFlags\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNotificationMessage* current_object;
    wxphp_object_type current_object_type;
    wxNotificationMessage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNotificationMessage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNotificationMessage::SetFlags call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNOTIFICATIONMESSAGE_TYPE){
                references = &((wxNotificationMessage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long flags0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&flags0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &flags0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxNotificationMessage::SetFlags((int) flags0)\n\n");
                #endif

                ((wxNotificationMessage_php*)native_object)->SetFlags((int) flags0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNotificationMessage::SetFlags\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxNotificationMessage::SetMessage(string message)
   Set the main text of the notification. */
PHP_METHOD(php_wxNotificationMessage, SetMessage)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNotificationMessage::SetMessage\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNotificationMessage* current_object;
    wxphp_object_type current_object_type;
    wxNotificationMessage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNotificationMessage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNotificationMessage::SetMessage call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNOTIFICATIONMESSAGE_TYPE){
                references = &((wxNotificationMessage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* message0;
    size_t message_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&message0, &message_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &message0, &message_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxNotificationMessage::SetMessage(wxString(message0, wxConvUTF8))\n\n");
                #endif

                ((wxNotificationMessage_php*)native_object)->SetMessage(wxString(message0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNotificationMessage::SetMessage\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxNotificationMessage::SetParent(wxWindow &parent)
   Set the parent for this notification: the notification will be associated with the top level parent of this window or, if this method is not called, with the main application window by default. */
PHP_METHOD(php_wxNotificationMessage, SetParent)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNotificationMessage::SetParent\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNotificationMessage* current_object;
    wxphp_object_type current_object_type;
    wxNotificationMessage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNotificationMessage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNotificationMessage::SetParent call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNOTIFICATIONMESSAGE_TYPE){
                references = &((wxNotificationMessage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* parent0;
    wxWindow* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&parent0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &parent0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(parent0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxWindow_P(parent0)->object_type;
                    argument_native_object = (void*) Z_wxWindow_P(parent0)->native_object;
                    object_pointer0_0 = (wxWindow*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'parent' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(parent0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'parent' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxNotificationMessage::SetParent((wxWindow*) object_pointer0_0)\n\n");
                #endif

                ((wxNotificationMessage_php*)native_object)->SetParent((wxWindow*) object_pointer0_0);

                references->AddReference(parent0, "wxNotificationMessage::SetParent at call 1 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNotificationMessage::SetParent\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxNotificationMessage::SetTitle(string title)
   Set the title, it must be a concise string (not more than 64 characters), use SetMessage() to give the user more details. */
PHP_METHOD(php_wxNotificationMessage, SetTitle)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNotificationMessage::SetTitle\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNotificationMessage* current_object;
    wxphp_object_type current_object_type;
    wxNotificationMessage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNotificationMessage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNotificationMessage::SetTitle call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNOTIFICATIONMESSAGE_TYPE){
                references = &((wxNotificationMessage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* title0;
    size_t title_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&title0, &title_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &title0, &title_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxNotificationMessage::SetTitle(wxString(title0, wxConvUTF8))\n\n");
                #endif

                ((wxNotificationMessage_php*)native_object)->SetTitle(wxString(title0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNotificationMessage::SetTitle\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxNotificationMessage::Show(int timeout)
   Show the notification to the user and hides it after timeout seconds are elapsed. */
PHP_METHOD(php_wxNotificationMessage, Show)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNotificationMessage::Show\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNotificationMessage* current_object;
    wxphp_object_type current_object_type;
    wxNotificationMessage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxNotificationMessage_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxNotificationMessage::Show call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXNOTIFICATIONMESSAGE_TYPE){
                references = &((wxNotificationMessage_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long timeout0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&timeout0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &timeout0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxNotificationMessage::Show())\n\n");
                #endif

                RETVAL_BOOL(((wxNotificationMessage_php*)native_object)->Show());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxNotificationMessage::Show((int) timeout0))\n\n");
                #endif

                RETVAL_BOOL(((wxNotificationMessage_php*)native_object)->Show((int) timeout0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxNotificationMessage::Show\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxNotificationMessage::wxNotificationMessage()
   Default constructor, use SetParent(), SetTitle() and SetMessage() to initialize the object before showing it. */
PHP_METHOD(php_wxNotificationMessage, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxNotificationMessage::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxNotificationMessage* current_object;
    wxNotificationMessage_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    char* title1;
    size_t title_len1;
    char* message1;
    size_t message_len1;
    zval* parent1;
    wxWindow* object_pointer1_2 = 0;
    long flags1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 1  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|szl' (&title1, &title_len1, &message1, &message_len1, &parent1, &flags1)\n");
        #endif

        char parse_parameters_string[] = "s|szl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &title1, &title_len1, &message1, &message_len1, &parent1, &flags1 ) == SUCCESS)
        {
            if(arguments_received >= 3){
                if(Z_TYPE_P(parent1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxWindow_P(parent1)->object_type;
                    argument_native_object = (void*) Z_wxWindow_P(parent1)->native_object;
                    object_pointer1_2 = (wxWindow*) argument_native_object;
                    if (!object_pointer1_2 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'parent' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(parent1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'parent' not null, could not be retreived correctly.");
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxNotificationMessage_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(title1, wxConvUTF8))\n");
                #endif

                native_object = new wxNotificationMessage_php(wxString(title1, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(title1, wxConvUTF8), wxString(message1, wxConvUTF8))\n");
                #endif

                native_object = new wxNotificationMessage_php(wxString(title1, wxConvUTF8), wxString(message1, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(title1, wxConvUTF8), wxString(message1, wxConvUTF8), (wxWindow*) object_pointer1_2)\n");
                #endif

                native_object = new wxNotificationMessage_php(wxString(title1, wxConvUTF8), wxString(message1, wxConvUTF8), (wxWindow*) object_pointer1_2);

                native_object->references.Initialize();
                ((wxNotificationMessage_php*) native_object)->references.AddReference(parent1, "wxNotificationMessage::wxNotificationMessage at call 2 with 3 argument(s)");
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(title1, wxConvUTF8), wxString(message1, wxConvUTF8), (wxWindow*) object_pointer1_2, (int) flags1)\n");
                #endif

                native_object = new wxNotificationMessage_php(wxString(title1, wxConvUTF8), wxString(message1, wxConvUTF8), (wxWindow*) object_pointer1_2, (int) flags1);

                native_object->references.Initialize();
                ((wxNotificationMessage_php*) native_object)->references.AddReference(parent1, "wxNotificationMessage::wxNotificationMessage at call 2 with 4 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxNotificationMessage_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxNotificationMessage::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxStopWatch_free(void *object)
{
    zo_wxStopWatch* custom_object = (zo_wxStopWatch*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxStopWatch_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxStopWatch done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxStopWatch_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxStopWatch_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxStopWatch* custom_object;

    custom_object = (zo_wxStopWatch*) ecalloc(
        1,
        sizeof(zo_wxStopWatch)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxStopWatch_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXSTOPWATCH_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxStopWatch::wxStopWatch()
   Constructor. */
PHP_METHOD(php_wxStopWatch, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStopWatch::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStopWatch* current_object;
    wxStopWatch_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxStopWatch_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxStopWatch_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxStopWatch::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto int wxStopWatch::Time()
   Returns the time in milliseconds since the start (or restart) or the last call of Pause(). */
PHP_METHOD(php_wxStopWatch, Time)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStopWatch::Time\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStopWatch* current_object;
    wxphp_object_type current_object_type;
    wxStopWatch_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStopWatch_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStopWatch::Time call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTOPWATCH_TYPE){
                references = &((wxStopWatch_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxStopWatch::Time())\n\n");
                #endif

                RETVAL_LONG(((wxStopWatch_php*)native_object)->Time());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStopWatch::Time\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxStopWatch::Start(int milliseconds)
   (Re)starts the stop watch with a given initial value. */
PHP_METHOD(php_wxStopWatch, Start)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStopWatch::Start\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStopWatch* current_object;
    wxphp_object_type current_object_type;
    wxStopWatch_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStopWatch_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStopWatch::Start call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTOPWATCH_TYPE){
                references = &((wxStopWatch_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long milliseconds0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&milliseconds0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &milliseconds0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxStopWatch::Start()\n\n");
                #endif

                ((wxStopWatch_php*)native_object)->Start();


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxStopWatch::Start((long) milliseconds0)\n\n");
                #endif

                ((wxStopWatch_php*)native_object)->Start((long) milliseconds0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStopWatch::Start\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxStopWatch::Resume()
   Resumes the stop watch which had been paused with Pause(). */
PHP_METHOD(php_wxStopWatch, Resume)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStopWatch::Resume\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStopWatch* current_object;
    wxphp_object_type current_object_type;
    wxStopWatch_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStopWatch_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStopWatch::Resume call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTOPWATCH_TYPE){
                references = &((wxStopWatch_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxStopWatch::Resume()\n\n");
                #endif

                ((wxStopWatch_php*)native_object)->Resume();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStopWatch::Resume\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxStopWatch::Pause()
   Pauses the stop watch. */
PHP_METHOD(php_wxStopWatch, Pause)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStopWatch::Pause\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStopWatch* current_object;
    wxphp_object_type current_object_type;
    wxStopWatch_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStopWatch_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStopWatch::Pause call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTOPWATCH_TYPE){
                references = &((wxStopWatch_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxStopWatch::Pause()\n\n");
                #endif

                ((wxStopWatch_php*)native_object)->Pause();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStopWatch::Pause\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxTaskBarIcon_free(void *object)
{
    zo_wxTaskBarIcon* custom_object = (zo_wxTaskBarIcon*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxTaskBarIcon_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxTaskBarIcon done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxTaskBarIcon_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxTaskBarIcon_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxTaskBarIcon* custom_object;

    custom_object = (zo_wxTaskBarIcon*) ecalloc(
        1,
        sizeof(zo_wxTaskBarIcon)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxTaskBarIcon_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXTASKBARICON_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto wxMenu wxTaskBarIcon::CreatePopupMenu()
   This method is called by the library when the user requests popup menu (on Windows and Unix platforms, this is when the user right-clicks the icon). */
wxMenu* wxTaskBarIcon_php::CreatePopupMenu()
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxTaskBarIcon::CreatePopupMenu\n");
    php_printf("===========================================\n");
    #endif

    zval* params[1];
    zval arguments[1];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "CreatePopupMenu");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "CreatePopupMenu");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "CreatePopupMenu",
            15,
            &function_return_value,
            0,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Returning userspace value.\n");
        #endif

        if(Z_TYPE(function_return_value) == IS_OBJECT)
    {
        return_object = (void*) Z_wxMenu_P(&function_return_value)->native_object;
    }

    //Threat it as a normal object on the calling function and not a php user space intiialized one
    Z_wxMenu_P(&function_return_value)->is_user_initialized = 0;
    wxMenu_php* var = (wxMenu_php*) return_object;
    var->references.UnInitialize();

    return (wxMenu*) return_object;
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Calling original method\n");
    php_printf("===========================================\n\n");
    #endif

    //Call original method
    return wxTaskBarIcon::CreatePopupMenu(
            );
}
/* }}} */

/* {{{ proto  wxTaskBarIcon::Destroy()
   This method is similar to wxWindow::Destroy and can be used to schedule the task bar icon object for the delayed destruction: it will be deleted during the next event loop iteration, which allows the task bar icon to process any pending events for it before being destroyed. */
PHP_METHOD(php_wxTaskBarIcon, Destroy)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxTaskBarIcon::Destroy\n");
    php_printf("===========================================\n");
    #endif

    zo_wxTaskBarIcon* current_object;
    wxphp_object_type current_object_type;
    wxTaskBarIcon_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxTaskBarIcon_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxTaskBarIcon::Destroy call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTASKBARICON_TYPE){
                references = &((wxTaskBarIcon_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxTaskBarIcon::Destroy()\n\n");
                #endif

                ((wxTaskBarIcon_php*)native_object)->Destroy();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxTaskBarIcon::Destroy\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxTaskBarIcon::IsAvailable()
   Returns true if system tray is available in the desktop environment the app runs under. */
PHP_METHOD(php_wxTaskBarIcon, IsAvailable)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxTaskBarIcon::IsAvailable\n");
    php_printf("===========================================\n");
    #endif

    zo_wxTaskBarIcon* current_object;
    wxphp_object_type current_object_type;
    wxTaskBarIcon_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxTaskBarIcon_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxTaskBarIcon::IsAvailable call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTASKBARICON_TYPE){
                references = &((wxTaskBarIcon_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxTaskBarIcon::IsAvailable())\n\n");
                #endif

                RETVAL_BOOL(wxTaskBarIcon::IsAvailable());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxTaskBarIcon::IsAvailable\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxTaskBarIcon::IsIconInstalled()
   Returns true if SetIcon() was called with no subsequent RemoveIcon(). */
PHP_METHOD(php_wxTaskBarIcon, IsIconInstalled)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxTaskBarIcon::IsIconInstalled\n");
    php_printf("===========================================\n");
    #endif

    zo_wxTaskBarIcon* current_object;
    wxphp_object_type current_object_type;
    wxTaskBarIcon_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxTaskBarIcon_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxTaskBarIcon::IsIconInstalled call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTASKBARICON_TYPE){
                references = &((wxTaskBarIcon_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxTaskBarIcon::IsIconInstalled())\n\n");
                #endif

                RETVAL_BOOL(((wxTaskBarIcon_php*)native_object)->IsIconInstalled());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxTaskBarIcon::IsIconInstalled\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxTaskBarIcon::IsOk()
   Returns true if the object initialized successfully. */
PHP_METHOD(php_wxTaskBarIcon, IsOk)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxTaskBarIcon::IsOk\n");
    php_printf("===========================================\n");
    #endif

    zo_wxTaskBarIcon* current_object;
    wxphp_object_type current_object_type;
    wxTaskBarIcon_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxTaskBarIcon_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxTaskBarIcon::IsOk call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTASKBARICON_TYPE){
                references = &((wxTaskBarIcon_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxTaskBarIcon::IsOk())\n\n");
                #endif

                RETVAL_BOOL(((wxTaskBarIcon_php*)native_object)->IsOk());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxTaskBarIcon::IsOk\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxTaskBarIcon::PopupMenu(wxMenu &menu)
   Pops up a menu at the current mouse position. */
PHP_METHOD(php_wxTaskBarIcon, PopupMenu)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxTaskBarIcon::PopupMenu\n");
    php_printf("===========================================\n");
    #endif

    zo_wxTaskBarIcon* current_object;
    wxphp_object_type current_object_type;
    wxTaskBarIcon_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxTaskBarIcon_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxTaskBarIcon::PopupMenu call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTASKBARICON_TYPE){
                references = &((wxTaskBarIcon_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* menu0;
    wxMenu* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&menu0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &menu0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(menu0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxMenu_P(menu0)->object_type;
                    argument_native_object = (void*) Z_wxMenu_P(menu0)->native_object;
                    object_pointer0_0 = (wxMenu*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXMENU_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'menu' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(menu0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'menu' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxTaskBarIcon::PopupMenu((wxMenu*) object_pointer0_0))\n\n");
                #endif

                RETVAL_BOOL(((wxTaskBarIcon_php*)native_object)->PopupMenu((wxMenu*) object_pointer0_0));

                references->AddReference(menu0, "wxTaskBarIcon::PopupMenu at call 1 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxTaskBarIcon::PopupMenu\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxTaskBarIcon::RemoveIcon()
   Removes the icon previously set with SetIcon(). */
PHP_METHOD(php_wxTaskBarIcon, RemoveIcon)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxTaskBarIcon::RemoveIcon\n");
    php_printf("===========================================\n");
    #endif

    zo_wxTaskBarIcon* current_object;
    wxphp_object_type current_object_type;
    wxTaskBarIcon_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxTaskBarIcon_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxTaskBarIcon::RemoveIcon call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTASKBARICON_TYPE){
                references = &((wxTaskBarIcon_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxTaskBarIcon::RemoveIcon())\n\n");
                #endif

                RETVAL_BOOL(((wxTaskBarIcon_php*)native_object)->RemoveIcon());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxTaskBarIcon::RemoveIcon\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxTaskBarIcon::SetIcon(wxIcon icon, string tooltip)
   Sets the icon, and optional tooltip text. */
PHP_METHOD(php_wxTaskBarIcon, SetIcon)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxTaskBarIcon::SetIcon\n");
    php_printf("===========================================\n");
    #endif

    zo_wxTaskBarIcon* current_object;
    wxphp_object_type current_object_type;
    wxTaskBarIcon_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxTaskBarIcon_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxTaskBarIcon::SetIcon call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTASKBARICON_TYPE){
                references = &((wxTaskBarIcon_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* icon0;
    wxIcon* object_pointer0_0 = 0;
    char* tooltip0;
    size_t tooltip_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O|s' (&icon0, php_wxIcon_entry, &tooltip0, &tooltip_len0)\n");
        #endif

        char parse_parameters_string[] = "O|s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &icon0, php_wxIcon_entry, &tooltip0, &tooltip_len0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(icon0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxIcon_P(icon0)->object_type;
                    argument_native_object = (void*) Z_wxIcon_P(icon0)->native_object;
                    object_pointer0_0 = (wxIcon*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'icon' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(icon0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'icon' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxTaskBarIcon::SetIcon(*(wxIcon*) object_pointer0_0))\n\n");
                #endif

                RETVAL_BOOL(((wxTaskBarIcon_php*)native_object)->SetIcon(*(wxIcon*) object_pointer0_0));

                references->AddReference(icon0, "wxTaskBarIcon::SetIcon at call 3 with 1 argument(s)");

                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxTaskBarIcon::SetIcon(*(wxIcon*) object_pointer0_0, wxString(tooltip0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxTaskBarIcon_php*)native_object)->SetIcon(*(wxIcon*) object_pointer0_0, wxString(tooltip0, wxConvUTF8)));

                references->AddReference(icon0, "wxTaskBarIcon::SetIcon at call 3 with 2 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxTaskBarIcon::SetIcon\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxTaskBarIcon::wxTaskBarIcon(wxTaskBarIconType iconType)
   Default constructor. */
PHP_METHOD(php_wxTaskBarIcon, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxTaskBarIcon::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxTaskBarIcon* current_object;
    wxTaskBarIcon_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    long iconType0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&iconType0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &iconType0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxTaskBarIcon_php();

                native_object->references.Initialize();
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxTaskBarIconType) iconType0)\n");
                #endif

                native_object = new wxTaskBarIcon_php((wxTaskBarIconType) iconType0);

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxTaskBarIcon_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxTaskBarIcon::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxTimer_free(void *object)
{
    zo_wxTimer* custom_object = (zo_wxTimer*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxTimer_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxTimer done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxTimer_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxTimer_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxTimer* custom_object;

    custom_object = (zo_wxTimer*) ecalloc(
        1,
        sizeof(zo_wxTimer)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxTimer_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXTIMER_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto int wxTimer::GetId()
   Returns the ID of the events generated by this timer. */
PHP_METHOD(php_wxTimer, GetId)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxTimer::GetId\n");
    php_printf("===========================================\n");
    #endif

    zo_wxTimer* current_object;
    wxphp_object_type current_object_type;
    wxTimer_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxTimer_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxTimer::GetId call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTIMER_TYPE){
                references = &((wxTimer_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxTimer::GetId())\n\n");
                #endif

                RETVAL_LONG(((wxTimer_php*)native_object)->GetId());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxTimer::GetId\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxTimer::GetInterval()
   Returns the current interval for the timer (in milliseconds). */
PHP_METHOD(php_wxTimer, GetInterval)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxTimer::GetInterval\n");
    php_printf("===========================================\n");
    #endif

    zo_wxTimer* current_object;
    wxphp_object_type current_object_type;
    wxTimer_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxTimer_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxTimer::GetInterval call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTIMER_TYPE){
                references = &((wxTimer_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxTimer::GetInterval())\n\n");
                #endif

                RETVAL_LONG(((wxTimer_php*)native_object)->GetInterval());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxTimer::GetInterval\n"
        );
    }
}
/* }}} */

/* {{{ proto wxEvtHandler wxTimer::GetOwner()
   Returns the current owner of the timer. */
PHP_METHOD(php_wxTimer, GetOwner)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxTimer::GetOwner\n");
    php_printf("===========================================\n");
    #endif

    zo_wxTimer* current_object;
    wxphp_object_type current_object_type;
    wxTimer_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxTimer_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxTimer::GetOwner call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTIMER_TYPE){
                references = &((wxTimer_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxTimer::GetOwner() to return object pointer\n\n");
                #endif

                wxEvtHandler_php* value_to_return0;
                value_to_return0 = (wxEvtHandler_php*) ((wxTimer_php*)native_object)->GetOwner();

                if(value_to_return0 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxEvtHandler_entry);
                    Z_wxEvtHandler_P(return_value)->native_object = (wxEvtHandler_php*) value_to_return0;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxTimer::GetOwner at call 5 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxTimer::GetOwner\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxTimer::IsOneShot()
   Returns true if the timer is one shot, i.e. if it will stop after firing the first notification automatically. */
PHP_METHOD(php_wxTimer, IsOneShot)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxTimer::IsOneShot\n");
    php_printf("===========================================\n");
    #endif

    zo_wxTimer* current_object;
    wxphp_object_type current_object_type;
    wxTimer_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxTimer_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxTimer::IsOneShot call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTIMER_TYPE){
                references = &((wxTimer_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxTimer::IsOneShot())\n\n");
                #endif

                RETVAL_BOOL(((wxTimer_php*)native_object)->IsOneShot());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxTimer::IsOneShot\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxTimer::IsRunning()
   Returns true if the timer is running, false if it is stopped. */
PHP_METHOD(php_wxTimer, IsRunning)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxTimer::IsRunning\n");
    php_printf("===========================================\n");
    #endif

    zo_wxTimer* current_object;
    wxphp_object_type current_object_type;
    wxTimer_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxTimer_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxTimer::IsRunning call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTIMER_TYPE){
                references = &((wxTimer_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxTimer::IsRunning())\n\n");
                #endif

                RETVAL_BOOL(((wxTimer_php*)native_object)->IsRunning());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxTimer::IsRunning\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxTimer::Notify()
   This member should be overridden by the user if the default constructor was used and SetOwner() wasn't called. */
PHP_METHOD(php_wxTimer, Notify)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxTimer::Notify\n");
    php_printf("===========================================\n");
    #endif

    zo_wxTimer* current_object;
    wxphp_object_type current_object_type;
    wxTimer_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxTimer_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxTimer::Notify call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTIMER_TYPE){
                references = &((wxTimer_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxTimer::Notify()\n\n");
                #endif

                ((wxTimer_php*)native_object)->Notify();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxTimer::Notify\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxTimer::SetOwner(wxEvtHandler &owner, int id)
   Associates the timer with the given owner object. */
PHP_METHOD(php_wxTimer, SetOwner)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxTimer::SetOwner\n");
    php_printf("===========================================\n");
    #endif

    zo_wxTimer* current_object;
    wxphp_object_type current_object_type;
    wxTimer_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxTimer_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxTimer::SetOwner call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTIMER_TYPE){
                references = &((wxTimer_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* owner0;
    wxEvtHandler* object_pointer0_0 = 0;
    long id0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z|l' (&owner0, &id0)\n");
        #endif

        char parse_parameters_string[] = "z|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &owner0, &id0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(owner0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxEvtHandler_P(owner0)->object_type;
                    argument_native_object = (void*) Z_wxEvtHandler_P(owner0)->native_object;
                    object_pointer0_0 = (wxEvtHandler*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXEVTHANDLER_TYPE && argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE && argument_type != PHP_WXVALIDATOR_TYPE && argument_type != PHP_WXTEXTVALIDATOR_TYPE && argument_type != PHP_WXGENERICVALIDATOR_TYPE && argument_type != PHP_WXMENU_TYPE && argument_type != PHP_WXAUIMANAGER_TYPE && argument_type != PHP_WXMOUSEEVENTSMANAGER_TYPE && argument_type != PHP_WXTIMER_TYPE && argument_type != PHP_WXEVENTBLOCKER_TYPE && argument_type != PHP_WXPROCESS_TYPE && argument_type != PHP_WXFILESYSTEMWATCHER_TYPE && argument_type != PHP_WXTASKBARICON_TYPE && argument_type != PHP_WXNOTIFICATIONMESSAGE_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'owner' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(owner0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'owner' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxTimer::SetOwner((wxEvtHandler*) object_pointer0_0)\n\n");
                #endif

                ((wxTimer_php*)native_object)->SetOwner((wxEvtHandler*) object_pointer0_0);

                references->AddReference(owner0, "wxTimer::SetOwner at call 1 with 1 argument(s)");

                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxTimer::SetOwner((wxEvtHandler*) object_pointer0_0, (int) id0)\n\n");
                #endif

                ((wxTimer_php*)native_object)->SetOwner((wxEvtHandler*) object_pointer0_0, (int) id0);

                references->AddReference(owner0, "wxTimer::SetOwner at call 1 with 2 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxTimer::SetOwner\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxTimer::Start(int milliseconds, bool oneShot)
   (Re)starts the timer. */
PHP_METHOD(php_wxTimer, Start)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxTimer::Start\n");
    php_printf("===========================================\n");
    #endif

    zo_wxTimer* current_object;
    wxphp_object_type current_object_type;
    wxTimer_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxTimer_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxTimer::Start call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTIMER_TYPE){
                references = &((wxTimer_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long milliseconds0;
    bool oneShot0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|lb' (&milliseconds0, &oneShot0)\n");
        #endif

        char parse_parameters_string[] = "|lb";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &milliseconds0, &oneShot0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxTimer::Start())\n\n");
                #endif

                RETVAL_BOOL(((wxTimer_php*)native_object)->Start());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxTimer::Start((int) milliseconds0))\n\n");
                #endif

                RETVAL_BOOL(((wxTimer_php*)native_object)->Start((int) milliseconds0));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxTimer::Start((int) milliseconds0, oneShot0))\n\n");
                #endif

                RETVAL_BOOL(((wxTimer_php*)native_object)->Start((int) milliseconds0, oneShot0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxTimer::Start\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxTimer::Stop()
   Stops the timer. */
PHP_METHOD(php_wxTimer, Stop)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxTimer::Stop\n");
    php_printf("===========================================\n");
    #endif

    zo_wxTimer* current_object;
    wxphp_object_type current_object_type;
    wxTimer_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxTimer_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxTimer::Stop call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXTIMER_TYPE){
                references = &((wxTimer_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxTimer::Stop()\n\n");
                #endif

                ((wxTimer_php*)native_object)->Stop();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxTimer::Stop\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxTimer::wxTimer()
   Default constructor. */
PHP_METHOD(php_wxTimer, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxTimer::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxTimer* current_object;
    wxTimer_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    zval* owner1;
    wxEvtHandler* object_pointer1_0 = 0;
    long id1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z|l' (&owner1, &id1)\n");
        #endif

        char parse_parameters_string[] = "z|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &owner1, &id1 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(owner1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxEvtHandler_P(owner1)->object_type;
                    argument_native_object = (void*) Z_wxEvtHandler_P(owner1)->native_object;
                    object_pointer1_0 = (wxEvtHandler*) argument_native_object;
                    if (!object_pointer1_0 || (argument_type != PHP_WXEVTHANDLER_TYPE && argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE && argument_type != PHP_WXVALIDATOR_TYPE && argument_type != PHP_WXTEXTVALIDATOR_TYPE && argument_type != PHP_WXGENERICVALIDATOR_TYPE && argument_type != PHP_WXMENU_TYPE && argument_type != PHP_WXAUIMANAGER_TYPE && argument_type != PHP_WXMOUSEEVENTSMANAGER_TYPE && argument_type != PHP_WXTIMER_TYPE && argument_type != PHP_WXEVENTBLOCKER_TYPE && argument_type != PHP_WXPROCESS_TYPE && argument_type != PHP_WXFILESYSTEMWATCHER_TYPE && argument_type != PHP_WXTASKBARICON_TYPE && argument_type != PHP_WXNOTIFICATIONMESSAGE_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'owner' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(owner1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'owner' not null, could not be retreived correctly.");
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxTimer_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxEvtHandler*) object_pointer1_0)\n");
                #endif

                native_object = new wxTimer_php((wxEvtHandler*) object_pointer1_0);

                native_object->references.Initialize();
                ((wxTimer_php*) native_object)->references.AddReference(owner1, "wxTimer::wxTimer at call 2 with 1 argument(s)");
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxEvtHandler*) object_pointer1_0, (int) id1)\n");
                #endif

                native_object = new wxTimer_php((wxEvtHandler*) object_pointer1_0, (int) id1);

                native_object->references.Initialize();
                ((wxTimer_php*) native_object)->references.AddReference(owner1, "wxTimer::wxTimer at call 2 with 2 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxTimer_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxTimer::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxWindowDisabler_free(void *object)
{
    zo_wxWindowDisabler* custom_object = (zo_wxWindowDisabler*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxWindowDisabler_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxWindowDisabler done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxWindowDisabler_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxWindowDisabler_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxWindowDisabler* custom_object;

    custom_object = (zo_wxWindowDisabler*) ecalloc(
        1,
        sizeof(zo_wxWindowDisabler)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxWindowDisabler_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXWINDOWDISABLER_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxWindowDisabler::wxWindowDisabler(bool disable)
   Disables all top level windows of the applications. */
PHP_METHOD(php_wxWindowDisabler, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxWindowDisabler::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxWindowDisabler* current_object;
    wxWindowDisabler_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool disable0;
    bool overload0_called = false;

    //Parameters for overload 1
    zval* winToSkip1;
    wxWindow* object_pointer1_0 = 0;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|b' (&disable0)\n");
        #endif

        char parse_parameters_string[] = "|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &disable0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&winToSkip1)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &winToSkip1 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(winToSkip1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxWindow_P(winToSkip1)->object_type;
                    argument_native_object = (void*) Z_wxWindow_P(winToSkip1)->native_object;
                    object_pointer1_0 = (wxWindow*) argument_native_object;
                    if (!object_pointer1_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'winToSkip' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(winToSkip1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'winToSkip' not null, could not be retreived correctly.");
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxWindowDisabler_php();

                native_object->references.Initialize();
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(disable0)\n");
                #endif

                native_object = new wxWindowDisabler_php(disable0);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
                #endif

                native_object = new wxWindowDisabler_php((wxWindow*) object_pointer1_0);

                native_object->references.Initialize();
                ((wxWindowDisabler_php*) native_object)->references.AddReference(winToSkip1, "wxWindowDisabler::wxWindowDisabler at call 2 with 1 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxWindowDisabler_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxWindowDisabler::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxBusyCursor_free(void *object)
{
    zo_wxBusyCursor* custom_object = (zo_wxBusyCursor*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxBusyCursor_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxBusyCursor done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxBusyCursor_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxBusyCursor_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxBusyCursor* custom_object;

    custom_object = (zo_wxBusyCursor*) ecalloc(
        1,
        sizeof(zo_wxBusyCursor)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxBusyCursor_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXBUSYCURSOR_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxBusyCursor::wxBusyCursor(wxCursor cursor)
   Constructs a busy cursor object, calling wxBeginBusyCursor(). */
PHP_METHOD(php_wxBusyCursor, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxBusyCursor::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxBusyCursor* current_object;
    wxBusyCursor_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    zval* cursor0;
    wxCursor* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|z' (&cursor0)\n");
        #endif

        char parse_parameters_string[] = "|z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &cursor0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(cursor0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxCursor_P(cursor0)->object_type;
                    argument_native_object = (void*) Z_wxCursor_P(cursor0)->native_object;
                    object_pointer0_0 = (wxCursor*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXCURSOR_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'cursor' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(cursor0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'cursor' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxBusyCursor_php();

                native_object->references.Initialize();
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((const wxCursor*) object_pointer0_0)\n");
                #endif

                native_object = new wxBusyCursor_php((const wxCursor*) object_pointer0_0);

                native_object->references.Initialize();
                ((wxBusyCursor_php*) native_object)->references.AddReference(cursor0, "wxBusyCursor::wxBusyCursor at call 2 with 1 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxBusyCursor_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxBusyCursor::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

