/*
 * @author Mário Soares
 * @contributors Jefferson González
 * @contributors René Vögeli / Rangee GmbH
 * 
 * @license 
 * This file is part of wxPHP check the LICENSE file for information.
 * 
 * @note
 * This file was auto-generated by the wxPHP source maker
*/

#include "php_wxwidgets.h"
#include "appmanagement.h"
#include "cfg.h"
#include "bookctrl.h"
#include "dnd.h"
#include "cmndlg.h"
#include "containers.h"
#include "ctrl.h"
#include "data.h"
#include "dc.h"
#include "docview.h"
#include "events.h"
#include "file.h"
#include "gdi.h"
#include "grid.h"
#include "html.h"
#include "help.h"
#include "logging.h"
#include "managedwnd.h"
#include "menus.h"
#include "misc.h"
#include "miscwnd.h"
#include "media.h"
#include "net.h"
#include "pickers.h"
#include "printing.h"
#include "ribbon.h"
#include "richtext.h"
#include "rtti.h"
#include "stc.h"
#include "streams.h"
#include "threading.h"
#include "validator.h"
#include "vfs.h"
#include "aui.h"
#include "winlayout.h"
#include "xml.h"
#include "xrc.h"
#include "dvc.h"
#include "others.h"


BEGIN_EXTERN_C()
void php_wxDataOutputStream_free(void *object)
{
    zo_wxDataOutputStream* custom_object = (zo_wxDataOutputStream*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxDataOutputStream_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxDataOutputStream done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxDataOutputStream_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxDataOutputStream_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxDataOutputStream* custom_object;

    custom_object = (zo_wxDataOutputStream*) ecalloc(
        1,
        sizeof(zo_wxDataOutputStream)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxDataOutputStream_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXDATAOUTPUTSTREAM_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxDataOutputStream::BigEndianOrdered(bool be_order)
   If be_order is true, all data will be written in big-endian order, e.g. */
PHP_METHOD(php_wxDataOutputStream, BigEndianOrdered)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDataOutputStream::BigEndianOrdered\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDataOutputStream* current_object;
    wxphp_object_type current_object_type;
    wxDataOutputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxDataOutputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxDataOutputStream::BigEndianOrdered call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXDATAOUTPUTSTREAM_TYPE){
                references = &((wxDataOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool be_order0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'b' (&be_order0)\n");
        #endif

        char parse_parameters_string[] = "b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &be_order0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxDataOutputStream::BigEndianOrdered(be_order0)\n\n");
                #endif

                if(current_object_type == PHP_WXDATAOUTPUTSTREAM_TYPE)
                {
                    ((wxDataOutputStream_php*)native_object)->BigEndianOrdered(be_order0);
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxDataOutputStream::BigEndianOrdered\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxDataOutputStream::Write16(int i16)
   Writes the 16 bit unsigned integer i16 to the stream. */
PHP_METHOD(php_wxDataOutputStream, Write16)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDataOutputStream::Write16\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDataOutputStream* current_object;
    wxphp_object_type current_object_type;
    wxDataOutputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxDataOutputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxDataOutputStream::Write16 call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXDATAOUTPUTSTREAM_TYPE){
                references = &((wxDataOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long i160;
    bool overload0_called = false;

    //Parameters for overload 1
    long buffer1;
    long size1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&i160)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &i160 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (&buffer1, &size1)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &buffer1, &size1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxDataOutputStream::Write16((wxUint16) i160)\n\n");
                #endif

                if(current_object_type == PHP_WXDATAOUTPUTSTREAM_TYPE)
                {
                    ((wxDataOutputStream_php*)native_object)->Write16((wxUint16) i160);
                }


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxDataOutputStream::Write16((const wxUint16*) buffer1, (size_t) size1)\n\n");
                #endif

                if(current_object_type == PHP_WXDATAOUTPUTSTREAM_TYPE)
                {
                    ((wxDataOutputStream_php*)native_object)->Write16((const wxUint16*) buffer1, (size_t) size1);
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxDataOutputStream::Write16\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxDataOutputStream::Write32(int i32)
   Writes the 32 bit unsigned integer i32 to the stream. */
PHP_METHOD(php_wxDataOutputStream, Write32)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDataOutputStream::Write32\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDataOutputStream* current_object;
    wxphp_object_type current_object_type;
    wxDataOutputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxDataOutputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxDataOutputStream::Write32 call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXDATAOUTPUTSTREAM_TYPE){
                references = &((wxDataOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long i320;
    bool overload0_called = false;

    //Parameters for overload 1
    long buffer1;
    long size1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&i320)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &i320 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (&buffer1, &size1)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &buffer1, &size1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxDataOutputStream::Write32((wxUint32) i320)\n\n");
                #endif

                if(current_object_type == PHP_WXDATAOUTPUTSTREAM_TYPE)
                {
                    ((wxDataOutputStream_php*)native_object)->Write32((wxUint32) i320);
                }


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxDataOutputStream::Write32((const wxUint32*) buffer1, (size_t) size1)\n\n");
                #endif

                if(current_object_type == PHP_WXDATAOUTPUTSTREAM_TYPE)
                {
                    ((wxDataOutputStream_php*)native_object)->Write32((const wxUint32*) buffer1, (size_t) size1);
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxDataOutputStream::Write32\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxDataOutputStream::Write8(int i8)
   Writes the single byte i8 to the stream. */
PHP_METHOD(php_wxDataOutputStream, Write8)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDataOutputStream::Write8\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDataOutputStream* current_object;
    wxphp_object_type current_object_type;
    wxDataOutputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxDataOutputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxDataOutputStream::Write8 call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXDATAOUTPUTSTREAM_TYPE){
                references = &((wxDataOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long i80;
    bool overload0_called = false;

    //Parameters for overload 1
    long buffer1;
    long size1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&i80)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &i80 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (&buffer1, &size1)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &buffer1, &size1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxDataOutputStream::Write8((wxUint8) i80)\n\n");
                #endif

                if(current_object_type == PHP_WXDATAOUTPUTSTREAM_TYPE)
                {
                    ((wxDataOutputStream_php*)native_object)->Write8((wxUint8) i80);
                }


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxDataOutputStream::Write8((const wxUint8*) buffer1, (size_t) size1)\n\n");
                #endif

                if(current_object_type == PHP_WXDATAOUTPUTSTREAM_TYPE)
                {
                    ((wxDataOutputStream_php*)native_object)->Write8((const wxUint8*) buffer1, (size_t) size1);
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxDataOutputStream::Write8\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxDataOutputStream::WriteDouble(float d)
   Writes the double d to the stream. */
PHP_METHOD(php_wxDataOutputStream, WriteDouble)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDataOutputStream::WriteDouble\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDataOutputStream* current_object;
    wxphp_object_type current_object_type;
    wxDataOutputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxDataOutputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxDataOutputStream::WriteDouble call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXDATAOUTPUTSTREAM_TYPE){
                references = &((wxDataOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    double d0;
    bool overload0_called = false;

    //Parameters for overload 1
    zval* buffer1;
    long size1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'd' (&d0)\n");
        #endif

        char parse_parameters_string[] = "d";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &d0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'al' (&buffer1, &size1)\n");
        #endif

        char parse_parameters_string[] = "al";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &buffer1, &size1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxDataOutputStream::WriteDouble(d0)\n\n");
                #endif

                if(current_object_type == PHP_WXDATAOUTPUTSTREAM_TYPE)
                {
                    ((wxDataOutputStream_php*)native_object)->WriteDouble(d0);
                }


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        int array_count1_0 = 1;
        HashTable* arr_hash1_0;
        if(arguments_received > 0)
        {
            arr_hash1_0 = Z_ARRVAL_P(buffer1);
            array_count1_0 = zend_hash_num_elements(arr_hash1_0);
        }
        double* floats_array1_0 = new double[array_count1_0];
        bool floats_continue1_0 = true;

        switch(arguments_received)
        {
            case 2:
            {
                int array_index1_0 = 0;
                zval* temp_array_value1_0 = 0;
                while(floats_continue1_0)
                {
                    if((temp_array_value1_0 = zend_hash_index_find(HASH_OF(buffer1), array_index1_0)) != NULL)
                    {
                        convert_to_double_ex(temp_array_value1_0);
                        floats_array1_0[array_index1_0] = (double) Z_DVAL_P(temp_array_value1_0);
                        array_index1_0++;
                    }
                    else
                    {
                        floats_continue1_0 = false;
                    }
                }
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxDataOutputStream::WriteDouble((const double*) floats_array1_0, (size_t) size1)\n\n");
                #endif

                if(current_object_type == PHP_WXDATAOUTPUTSTREAM_TYPE)
                {
                    ((wxDataOutputStream_php*)native_object)->WriteDouble((const double*) floats_array1_0, (size_t) size1);
                }

                delete[] floats_array1_0;

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxDataOutputStream::WriteDouble\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxDataOutputStream::WriteString(string string)
   Writes string to the stream. */
PHP_METHOD(php_wxDataOutputStream, WriteString)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDataOutputStream::WriteString\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDataOutputStream* current_object;
    wxphp_object_type current_object_type;
    wxDataOutputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxDataOutputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxDataOutputStream::WriteString call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXDATAOUTPUTSTREAM_TYPE){
                references = &((wxDataOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* string0;
    size_t string_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&string0, &string_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &string0, &string_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxDataOutputStream::WriteString(wxString(string0, wxConvUTF8))\n\n");
                #endif

                if(current_object_type == PHP_WXDATAOUTPUTSTREAM_TYPE)
                {
                    ((wxDataOutputStream_php*)native_object)->WriteString(wxString(string0, wxConvUTF8));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxDataOutputStream::WriteString\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxDataInputStream_free(void *object)
{
    zo_wxDataInputStream* custom_object = (zo_wxDataInputStream*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxDataInputStream_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxDataInputStream done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxDataInputStream_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxDataInputStream_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxDataInputStream* custom_object;

    custom_object = (zo_wxDataInputStream*) ecalloc(
        1,
        sizeof(zo_wxDataInputStream)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxDataInputStream_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXDATAINPUTSTREAM_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto string wxDataInputStream::ReadString()
   Reads a string from a stream. */
PHP_METHOD(php_wxDataInputStream, ReadString)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDataInputStream::ReadString\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDataInputStream* current_object;
    wxphp_object_type current_object_type;
    wxDataInputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxDataInputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxDataInputStream::ReadString call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXDATAINPUTSTREAM_TYPE){
                references = &((wxDataInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxDataInputStream::ReadString().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXDATAINPUTSTREAM_TYPE)
                {
                    value_to_return0 = ((wxDataInputStream_php*)native_object)->ReadString();
                }
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxDataInputStream::ReadString\n"
        );
    }
}
/* }}} */

/* {{{ proto float wxDataInputStream::ReadDouble()
   Reads a double from the stream. */
PHP_METHOD(php_wxDataInputStream, ReadDouble)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDataInputStream::ReadDouble\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDataInputStream* current_object;
    wxphp_object_type current_object_type;
    wxDataInputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxDataInputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxDataInputStream::ReadDouble call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXDATAINPUTSTREAM_TYPE){
                references = &((wxDataInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    double* buffer1;
    zval buffer1_ref;
    long size1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'dl' (buffer1, &size1)\n");
        #endif

        char parse_parameters_string[] = "dl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, buffer1, &size1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;

            char parse_references_string[] = "zz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, buffer1_ref, dummy );
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxDataInputStream::ReadDouble())\n\n");
                #endif

                if(current_object_type == PHP_WXDATAINPUTSTREAM_TYPE)
                {
                    RETVAL_DOUBLE(((wxDataInputStream_php*)native_object)->ReadDouble());
                }


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxDataInputStream::ReadDouble(buffer1, (size_t) size1)\n\n");
                #endif

                if(current_object_type == PHP_WXDATAINPUTSTREAM_TYPE)
                {
                    ((wxDataInputStream_php*)native_object)->ReadDouble(buffer1, (size_t) size1);
                }

                size_t elements_returned1_0 = sizeof(buffer1)/sizeof(*buffer1);
                array_init(&buffer1_ref);
                for(size_t i=0; i<elements_returned1_0; i++)
                {
                    add_next_index_long(&buffer1_ref, buffer1[i]);
                }

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxDataInputStream::ReadDouble\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxDataInputStream::Read8()
   Reads a single byte from the stream. */
PHP_METHOD(php_wxDataInputStream, Read8)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDataInputStream::Read8\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDataInputStream* current_object;
    wxphp_object_type current_object_type;
    wxDataInputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxDataInputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxDataInputStream::Read8 call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXDATAINPUTSTREAM_TYPE){
                references = &((wxDataInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    long buffer1;
    long size1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (&buffer1, &size1)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &buffer1, &size1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxDataInputStream::Read8())\n\n");
                #endif

                if(current_object_type == PHP_WXDATAINPUTSTREAM_TYPE)
                {
                    RETVAL_LONG(((wxDataInputStream_php*)native_object)->Read8());
                }


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxDataInputStream::Read8((wxUint8*) buffer1, (size_t) size1)\n\n");
                #endif

                if(current_object_type == PHP_WXDATAINPUTSTREAM_TYPE)
                {
                    ((wxDataInputStream_php*)native_object)->Read8((wxUint8*) buffer1, (size_t) size1);
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxDataInputStream::Read8\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxDataInputStream::Read32()
   Reads a 32 bit unsigned integer from the stream. */
PHP_METHOD(php_wxDataInputStream, Read32)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDataInputStream::Read32\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDataInputStream* current_object;
    wxphp_object_type current_object_type;
    wxDataInputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxDataInputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxDataInputStream::Read32 call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXDATAINPUTSTREAM_TYPE){
                references = &((wxDataInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    long buffer1;
    long size1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (&buffer1, &size1)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &buffer1, &size1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxDataInputStream::Read32())\n\n");
                #endif

                if(current_object_type == PHP_WXDATAINPUTSTREAM_TYPE)
                {
                    RETVAL_LONG(((wxDataInputStream_php*)native_object)->Read32());
                }


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxDataInputStream::Read32((wxUint32*) buffer1, (size_t) size1)\n\n");
                #endif

                if(current_object_type == PHP_WXDATAINPUTSTREAM_TYPE)
                {
                    ((wxDataInputStream_php*)native_object)->Read32((wxUint32*) buffer1, (size_t) size1);
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxDataInputStream::Read32\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxDataInputStream::Read16()
   Reads a 16 bit unsigned integer from the stream. */
PHP_METHOD(php_wxDataInputStream, Read16)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDataInputStream::Read16\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDataInputStream* current_object;
    wxphp_object_type current_object_type;
    wxDataInputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxDataInputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxDataInputStream::Read16 call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXDATAINPUTSTREAM_TYPE){
                references = &((wxDataInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    long buffer1;
    long size1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll' (&buffer1, &size1)\n");
        #endif

        char parse_parameters_string[] = "ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &buffer1, &size1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxDataInputStream::Read16())\n\n");
                #endif

                if(current_object_type == PHP_WXDATAINPUTSTREAM_TYPE)
                {
                    RETVAL_LONG(((wxDataInputStream_php*)native_object)->Read16());
                }


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxDataInputStream::Read16((wxUint16*) buffer1, (size_t) size1)\n\n");
                #endif

                if(current_object_type == PHP_WXDATAINPUTSTREAM_TYPE)
                {
                    ((wxDataInputStream_php*)native_object)->Read16((wxUint16*) buffer1, (size_t) size1);
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxDataInputStream::Read16\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxDataInputStream::BigEndianOrdered(bool be_order)
   If be_order is true, all data will be read in big-endian order, such as written by programs on a big endian architecture (e.g. */
PHP_METHOD(php_wxDataInputStream, BigEndianOrdered)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDataInputStream::BigEndianOrdered\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDataInputStream* current_object;
    wxphp_object_type current_object_type;
    wxDataInputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxDataInputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxDataInputStream::BigEndianOrdered call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXDATAINPUTSTREAM_TYPE){
                references = &((wxDataInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool be_order0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'b' (&be_order0)\n");
        #endif

        char parse_parameters_string[] = "b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &be_order0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxDataInputStream::BigEndianOrdered(be_order0)\n\n");
                #endif

                if(current_object_type == PHP_WXDATAINPUTSTREAM_TYPE)
                {
                    ((wxDataInputStream_php*)native_object)->BigEndianOrdered(be_order0);
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxDataInputStream::BigEndianOrdered\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxStreamBase_free(void *object)
{
    zo_wxStreamBase* custom_object = (zo_wxStreamBase*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxStreamBase_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxStreamBase done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxStreamBase_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxStreamBase_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxStreamBase* custom_object;

    custom_object = (zo_wxStreamBase*) ecalloc(
        1,
        sizeof(zo_wxStreamBase)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxStreamBase_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXSTREAMBASE_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxStreamBase::wxStreamBase()
   Creates a dummy stream object. */
PHP_METHOD(php_wxStreamBase, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStreamBase::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStreamBase* current_object;
    wxStreamBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxStreamBase_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxStreamBase_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxStreamBase::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto  wxStreamBase::Reset(wxStreamError error)
   Resets the stream state. */
PHP_METHOD(php_wxStreamBase, Reset)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStreamBase::Reset\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStreamBase* current_object;
    wxphp_object_type current_object_type;
    wxStreamBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStreamBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStreamBase::Reset call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTREAMBASE_TYPE){
                references = &((wxStreamBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long error0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&error0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &error0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxStreamBase::Reset()\n\n");
                #endif

                ((wxStreamBase_php*)native_object)->Reset();


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxStreamBase::Reset((wxStreamError) error0)\n\n");
                #endif

                ((wxStreamBase_php*)native_object)->Reset((wxStreamError) error0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStreamBase::Reset\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxStreamBase::IsSeekable()
   Returns true if the stream supports seeking to arbitrary offsets. */
PHP_METHOD(php_wxStreamBase, IsSeekable)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStreamBase::IsSeekable\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStreamBase* current_object;
    wxphp_object_type current_object_type;
    wxStreamBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStreamBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStreamBase::IsSeekable call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTREAMBASE_TYPE){
                references = &((wxStreamBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxStreamBase::IsSeekable())\n\n");
                #endif

                RETVAL_BOOL(((wxStreamBase_php*)native_object)->IsSeekable());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStreamBase::IsSeekable\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxStreamBase::IsOk()
   Returns true if no error occurred on the stream. */
PHP_METHOD(php_wxStreamBase, IsOk)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStreamBase::IsOk\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStreamBase* current_object;
    wxphp_object_type current_object_type;
    wxStreamBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStreamBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStreamBase::IsOk call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTREAMBASE_TYPE){
                references = &((wxStreamBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxStreamBase::IsOk())\n\n");
                #endif

                RETVAL_BOOL(((wxStreamBase_php*)native_object)->IsOk());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStreamBase::IsOk\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxStreamBase::GetSize()
   This function returns the size of the stream. */
PHP_METHOD(php_wxStreamBase, GetSize)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStreamBase::GetSize\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStreamBase* current_object;
    wxphp_object_type current_object_type;
    wxStreamBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStreamBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStreamBase::GetSize call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTREAMBASE_TYPE){
                references = &((wxStreamBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxStreamBase::GetSize())\n\n");
                #endif

                RETVAL_LONG(((wxStreamBase_php*)native_object)->GetSize());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStreamBase::GetSize\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxStreamBase::GetLength()
   Returns the length of the stream in bytes. */
PHP_METHOD(php_wxStreamBase, GetLength)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStreamBase::GetLength\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStreamBase* current_object;
    wxphp_object_type current_object_type;
    wxStreamBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStreamBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStreamBase::GetLength call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTREAMBASE_TYPE){
                references = &((wxStreamBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxStreamBase::GetLength())\n\n");
                #endif

                RETVAL_LONG(((wxStreamBase_php*)native_object)->GetLength());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStreamBase::GetLength\n"
        );
    }
}
/* }}} */

/* {{{ proto wxStreamError wxStreamBase::GetLastError()
   This function returns the last error. */
PHP_METHOD(php_wxStreamBase, GetLastError)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStreamBase::GetLastError\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStreamBase* current_object;
    wxphp_object_type current_object_type;
    wxStreamBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStreamBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStreamBase::GetLastError call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTREAMBASE_TYPE){
                references = &((wxStreamBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxStreamBase::GetLastError())\n\n");
                #endif

                RETVAL_LONG(((wxStreamBase_php*)native_object)->GetLastError());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStreamBase::GetLastError\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxStreamBase::OnSysSeek(int pos, wxSeekMode mode)
   Internal function. */
wxFileOffset wxStreamBase_php::OnSysSeek(wxFileOffset pos, wxSeekMode mode)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxStreamBase::OnSysSeek\n");
    php_printf("===========================================\n");
    #endif

    zval* params[2];
    zval arguments[2];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "OnSysSeek");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    ZVAL_LONG(&arguments[0], pos);
    ZVAL_LONG(&arguments[1], mode);
    
    for(int i=0; i<2; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "OnSysSeek");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "OnSysSeek",
            9,
            &function_return_value,
            2,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<2; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Returning userspace value.\n");
        #endif

        return (wxFileOffset) Z_LVAL(function_return_value);
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Calling original method\n");
    php_printf("===========================================\n\n");
    #endif

    //Call original method
    return wxStreamBase::OnSysSeek(
        pos, mode    );
}
/* }}} */

/* {{{ proto int wxStreamBase::OnSysTell()
   Internal function. */
wxFileOffset wxStreamBase_php::OnSysTell()const
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxStreamBase::OnSysTell\n");
    php_printf("===========================================\n");
    #endif

    zval* params[1];
    zval arguments[1];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "OnSysTell");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "OnSysTell");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "OnSysTell",
            9,
            &function_return_value,
            0,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Returning userspace value.\n");
        #endif

        return (wxFileOffset) Z_LVAL(function_return_value);
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Calling original method\n");
    php_printf("===========================================\n\n");
    #endif

    //Call original method
    return wxStreamBase::OnSysTell(
            );
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxOutputStream_free(void *object)
{
    zo_wxOutputStream* custom_object = (zo_wxOutputStream*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxOutputStream_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxOutputStream done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxOutputStream_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxOutputStream_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxOutputStream* custom_object;

    custom_object = (zo_wxOutputStream*) ecalloc(
        1,
        sizeof(zo_wxOutputStream)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxOutputStream_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXOUTPUTSTREAM_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxOutputStream::wxOutputStream()
   Creates a dummy wxOutputStream object. */
PHP_METHOD(php_wxOutputStream, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxOutputStream::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxOutputStream* current_object;
    wxOutputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxOutputStream_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxOutputStream_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxOutputStream::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto wxOutputStream wxOutputStream::Write(void buffer, int size)
   Writes up to the specified amount of bytes using the data of buffer. */
PHP_METHOD(php_wxOutputStream, Write)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxOutputStream::Write\n");
    php_printf("===========================================\n");
    #endif

    zo_wxOutputStream* current_object;
    wxphp_object_type current_object_type;
    wxOutputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxOutputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxOutputStream::Write call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXOUTPUTSTREAM_TYPE){
                references = &((wxOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* buffer0;
    size_t buffer_len0;
    long size0;
    bool overload0_called = false;

    //Parameters for overload 1
    zval* stream_in1;
    wxInputStream* object_pointer1_0 = 0;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sl' (&buffer0, &buffer_len0, &size0)\n");
        #endif

        char parse_parameters_string[] = "sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &buffer0, &buffer_len0, &size0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'o' (&stream_in1)\n");
        #endif

        char parse_parameters_string[] = "o";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &stream_in1 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(stream_in1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxInputStream_P(stream_in1)->object_type;
                    argument_native_object = (void*) Z_wxInputStream_P(stream_in1)->native_object;
                    object_pointer1_0 = (wxInputStream*) argument_native_object;
                    if (!object_pointer1_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'stream_in' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(stream_in1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'stream_in' not null, could not be retreived correctly.");
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxOutputStream::Write((const void*) buffer0, (size_t) size0) to return object reference\n\n");
                #endif

                wxOutputStream_php* value_to_return2;
                value_to_return2 = (wxOutputStream_php*) &((wxOutputStream_php*)native_object)->Write((const void*) buffer0, (size_t) size0);

                if(value_to_return2->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return2->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return2->phpObj);
                        zval_add_ref(&value_to_return2->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxOutputStream_entry);
                    Z_wxOutputStream_P(return_value)->native_object = (wxOutputStream_php*) value_to_return2;
                }

                if((void*)value_to_return2 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxOutputStream::Write at call 6 with 2 argument(s)");
                }


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxOutputStream::Write(*(wxInputStream*) object_pointer1_0) to return object reference\n\n");
                #endif

                wxOutputStream_php* value_to_return1;
                value_to_return1 = (wxOutputStream_php*) &((wxOutputStream_php*)native_object)->Write(*(wxInputStream*) object_pointer1_0);

                if(value_to_return1->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return1->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return1->phpObj);
                        zval_add_ref(&value_to_return1->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxOutputStream_entry);
                    Z_wxOutputStream_P(return_value)->native_object = (wxOutputStream_php*) value_to_return1;
                }

                if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxOutputStream::Write at call 6 with 1 argument(s)");
                }

                references->AddReference(stream_in1, "wxOutputStream::Write at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxOutputStream::Write\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxOutputStream::TellO()
   Returns the current stream position. */
PHP_METHOD(php_wxOutputStream, TellO)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxOutputStream::TellO\n");
    php_printf("===========================================\n");
    #endif

    zo_wxOutputStream* current_object;
    wxphp_object_type current_object_type;
    wxOutputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxOutputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxOutputStream::TellO call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXOUTPUTSTREAM_TYPE){
                references = &((wxOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxOutputStream::TellO())\n\n");
                #endif

                RETVAL_LONG(((wxOutputStream_php*)native_object)->TellO());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxOutputStream::TellO\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxOutputStream::SeekO(int pos, wxSeekMode mode)
   Changes the stream current position. */
PHP_METHOD(php_wxOutputStream, SeekO)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxOutputStream::SeekO\n");
    php_printf("===========================================\n");
    #endif

    zo_wxOutputStream* current_object;
    wxphp_object_type current_object_type;
    wxOutputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxOutputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxOutputStream::SeekO call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXOUTPUTSTREAM_TYPE){
                references = &((wxOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long pos0;
    long mode0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l|l' (&pos0, &mode0)\n");
        #endif

        char parse_parameters_string[] = "l|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pos0, &mode0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxOutputStream::SeekO((wxFileOffset) pos0))\n\n");
                #endif

                RETVAL_LONG(((wxOutputStream_php*)native_object)->SeekO((wxFileOffset) pos0));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxOutputStream::SeekO((wxFileOffset) pos0, (wxSeekMode) mode0))\n\n");
                #endif

                RETVAL_LONG(((wxOutputStream_php*)native_object)->SeekO((wxFileOffset) pos0, (wxSeekMode) mode0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxOutputStream::SeekO\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxOutputStream::PutC(string c)
   Puts the specified character in the output queue and increments the stream position. */
PHP_METHOD(php_wxOutputStream, PutC)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxOutputStream::PutC\n");
    php_printf("===========================================\n");
    #endif

    zo_wxOutputStream* current_object;
    wxphp_object_type current_object_type;
    wxOutputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxOutputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxOutputStream::PutC call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXOUTPUTSTREAM_TYPE){
                references = &((wxOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long c0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&c0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &c0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxOutputStream::PutC((char) c0)\n\n");
                #endif

                ((wxOutputStream_php*)native_object)->PutC((char) c0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxOutputStream::PutC\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxOutputStream::Close()
   Closes the stream, returning false if an error occurs. */
PHP_METHOD(php_wxOutputStream, Close)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxOutputStream::Close\n");
    php_printf("===========================================\n");
    #endif

    zo_wxOutputStream* current_object;
    wxphp_object_type current_object_type;
    wxOutputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxOutputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxOutputStream::Close call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXOUTPUTSTREAM_TYPE){
                references = &((wxOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxOutputStream::Close())\n\n");
                #endif

                RETVAL_BOOL(((wxOutputStream_php*)native_object)->Close());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxOutputStream::Close\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxOutputStream::LastWrite()
   Returns the number of bytes written during the last Write(). */
PHP_METHOD(php_wxOutputStream, LastWrite)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxOutputStream::LastWrite\n");
    php_printf("===========================================\n");
    #endif

    zo_wxOutputStream* current_object;
    wxphp_object_type current_object_type;
    wxOutputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxOutputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxOutputStream::LastWrite call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXOUTPUTSTREAM_TYPE){
                references = &((wxOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEOUTPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxOutputStream::LastWrite())\n\n");
                #endif

                RETVAL_LONG(((wxOutputStream_php*)native_object)->LastWrite());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxOutputStream::LastWrite\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxInputStream_free(void *object)
{
    zo_wxInputStream* custom_object = (zo_wxInputStream*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxInputStream_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxInputStream done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxInputStream_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxInputStream_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxInputStream* custom_object;

    custom_object = (zo_wxInputStream*) ecalloc(
        1,
        sizeof(zo_wxInputStream)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxInputStream_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXINPUTSTREAM_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxInputStream::wxInputStream()
   Creates a dummy input stream. */
PHP_METHOD(php_wxInputStream, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxInputStream::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxInputStream* current_object;
    wxInputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxInputStream_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxInputStream_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxInputStream::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto int wxInputStream::Ungetch(void buffer, int size)
   This function is only useful in read mode. */
PHP_METHOD(php_wxInputStream, Ungetch)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxInputStream::Ungetch\n");
    php_printf("===========================================\n");
    #endif

    zo_wxInputStream* current_object;
    wxphp_object_type current_object_type;
    wxInputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxInputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxInputStream::Ungetch call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXINPUTSTREAM_TYPE){
                references = &((wxInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* buffer0;
    size_t buffer_len0;
    long size0;
    bool overload0_called = false;

    //Parameters for overload 1
    long c1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sl' (&buffer0, &buffer_len0, &size0)\n");
        #endif

        char parse_parameters_string[] = "sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &buffer0, &buffer_len0, &size0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&c1)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &c1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxInputStream::Ungetch((const void*) buffer0, (size_t) size0))\n\n");
                #endif

                RETVAL_LONG(((wxInputStream_php*)native_object)->Ungetch((const void*) buffer0, (size_t) size0));


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxInputStream::Ungetch((char) c1))\n\n");
                #endif

                RETVAL_BOOL(((wxInputStream_php*)native_object)->Ungetch((char) c1));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxInputStream::Ungetch\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxInputStream::TellI()
   Returns the current stream position or wxInvalidOffset if it's not available (e.g. */
PHP_METHOD(php_wxInputStream, TellI)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxInputStream::TellI\n");
    php_printf("===========================================\n");
    #endif

    zo_wxInputStream* current_object;
    wxphp_object_type current_object_type;
    wxInputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxInputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxInputStream::TellI call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXINPUTSTREAM_TYPE){
                references = &((wxInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxInputStream::TellI())\n\n");
                #endif

                RETVAL_LONG(((wxInputStream_php*)native_object)->TellI());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxInputStream::TellI\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxInputStream::SeekI(int pos, wxSeekMode mode)
   Changes the stream current position. */
PHP_METHOD(php_wxInputStream, SeekI)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxInputStream::SeekI\n");
    php_printf("===========================================\n");
    #endif

    zo_wxInputStream* current_object;
    wxphp_object_type current_object_type;
    wxInputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxInputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxInputStream::SeekI call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXINPUTSTREAM_TYPE){
                references = &((wxInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long pos0;
    long mode0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l|l' (&pos0, &mode0)\n");
        #endif

        char parse_parameters_string[] = "l|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pos0, &mode0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxInputStream::SeekI((wxFileOffset) pos0))\n\n");
                #endif

                RETVAL_LONG(((wxInputStream_php*)native_object)->SeekI((wxFileOffset) pos0));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxInputStream::SeekI((wxFileOffset) pos0, (wxSeekMode) mode0))\n\n");
                #endif

                RETVAL_LONG(((wxInputStream_php*)native_object)->SeekI((wxFileOffset) pos0, (wxSeekMode) mode0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxInputStream::SeekI\n"
        );
    }
}
/* }}} */

/* {{{ proto wxInputStream wxInputStream::Read(void buffer, int size)
   Reads the specified amount of bytes and stores the data in buffer. */
PHP_METHOD(php_wxInputStream, Read)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxInputStream::Read\n");
    php_printf("===========================================\n");
    #endif

    zo_wxInputStream* current_object;
    wxphp_object_type current_object_type;
    wxInputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxInputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxInputStream::Read call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXINPUTSTREAM_TYPE){
                references = &((wxInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* buffer0;
    size_t buffer_len0;
    zval buffer0_ref;
    long size0;
    bool overload0_called = false;

    //Parameters for overload 1
    zval* stream_out1;
    wxOutputStream* object_pointer1_0 = 0;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sl' (&buffer0, &buffer_len0, &size0)\n");
        #endif

        char parse_parameters_string[] = "sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &buffer0, &buffer_len0, &size0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;

            char parse_references_string[] = "zz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, buffer0_ref, dummy );
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'o' (&stream_out1)\n");
        #endif

        char parse_parameters_string[] = "o";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &stream_out1 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(stream_out1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxOutputStream_P(stream_out1)->object_type;
                    argument_native_object = (void*) Z_wxOutputStream_P(stream_out1)->native_object;
                    object_pointer1_0 = (wxOutputStream*) argument_native_object;
                    if (!object_pointer1_0 || (argument_type != PHP_WXOUTPUTSTREAM_TYPE && argument_type != PHP_WXFFILEOUTPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEOUTPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'stream_out' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(stream_out1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'stream_out' not null, could not be retreived correctly.");
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxInputStream::Read((void*) buffer0, (size_t) size0) to return object reference\n\n");
                #endif

                wxInputStream_php* value_to_return2;
                value_to_return2 = (wxInputStream_php*) &((wxInputStream_php*)native_object)->Read((void*) buffer0, (size_t) size0);

                if(value_to_return2->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return2->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return2->phpObj);
                        zval_add_ref(&value_to_return2->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxInputStream_entry);
                    Z_wxInputStream_P(return_value)->native_object = (wxInputStream_php*) value_to_return2;
                }

                if((void*)value_to_return2 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxInputStream::Read at call 6 with 2 argument(s)");
                }

                ZVAL_STRING(&buffer0_ref, (char*) buffer0);

                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxInputStream::Read(*(wxOutputStream*) object_pointer1_0) to return object reference\n\n");
                #endif

                wxInputStream_php* value_to_return1;
                value_to_return1 = (wxInputStream_php*) &((wxInputStream_php*)native_object)->Read(*(wxOutputStream*) object_pointer1_0);

                if(value_to_return1->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return1->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return1->phpObj);
                        zval_add_ref(&value_to_return1->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxInputStream_entry);
                    Z_wxInputStream_P(return_value)->native_object = (wxInputStream_php*) value_to_return1;
                }

                if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
                    references->AddReference(return_value, "wxInputStream::Read at call 6 with 1 argument(s)");
                }

                references->AddReference(stream_out1, "wxInputStream::Read at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxInputStream::Read\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxInputStream::Peek()
   Returns the first character in the input queue without removing it. */
PHP_METHOD(php_wxInputStream, Peek)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxInputStream::Peek\n");
    php_printf("===========================================\n");
    #endif

    zo_wxInputStream* current_object;
    wxphp_object_type current_object_type;
    wxInputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxInputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxInputStream::Peek call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXINPUTSTREAM_TYPE){
                references = &((wxInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxInputStream::Peek().ToUTF8().data(), 1)\n\n");
                #endif

                char* value_to_return0;
                char value_to_return_temp0 = ((wxInputStream_php*)native_object)->Peek();
                value_to_return0 = &value_to_return_temp0;
                RETVAL_STRING(value_to_return0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxInputStream::Peek\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxInputStream::OnSysRead(void buffer, int bufsize)
   Internal function. */
size_t wxInputStream_php::OnSysRead(void* buffer, size_t bufsize)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxInputStream::OnSysRead\n");
    php_printf("===========================================\n");
    #endif

    zval* params[2];
    zval arguments[2];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "OnSysRead");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
        ZVAL_LONG(&arguments[1], bufsize);
    
    for(int i=0; i<2; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "OnSysRead");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "OnSysRead",
            9,
            &function_return_value,
            2,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    if(function_called != FAILURE)
    {
        memcpy ((void*) buffer, (void*) Z_STRVAL(arguments[0]), Z_STRLEN(arguments[0]));
    }

    //Delete already used parameters from memory
    for(int i=0; i<2; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxInputStream::OnSysRead'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return (size_t) Z_LVAL(function_return_value);

}
/* }}} */

/* {{{ proto int wxInputStream::LastRead()
   Returns the last number of bytes read. */
PHP_METHOD(php_wxInputStream, LastRead)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxInputStream::LastRead\n");
    php_printf("===========================================\n");
    #endif

    zo_wxInputStream* current_object;
    wxphp_object_type current_object_type;
    wxInputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxInputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxInputStream::LastRead call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXINPUTSTREAM_TYPE){
                references = &((wxInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxInputStream::LastRead())\n\n");
                #endif

                RETVAL_LONG(((wxInputStream_php*)native_object)->LastRead());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxInputStream::LastRead\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxInputStream::GetC()
   Returns the first character in the input queue and removes it, blocking until it appears if necessary. */
PHP_METHOD(php_wxInputStream, GetC)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxInputStream::GetC\n");
    php_printf("===========================================\n");
    #endif

    zo_wxInputStream* current_object;
    wxphp_object_type current_object_type;
    wxInputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxInputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxInputStream::GetC call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXINPUTSTREAM_TYPE){
                references = &((wxInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxInputStream::GetC())\n\n");
                #endif

                RETVAL_LONG(((wxInputStream_php*)native_object)->GetC());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxInputStream::GetC\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxInputStream::Eof()
   Returns true after an attempt has been made to read past the end of the stream. */
PHP_METHOD(php_wxInputStream, Eof)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxInputStream::Eof\n");
    php_printf("===========================================\n");
    #endif

    zo_wxInputStream* current_object;
    wxphp_object_type current_object_type;
    wxInputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxInputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxInputStream::Eof call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXINPUTSTREAM_TYPE){
                references = &((wxInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxInputStream::Eof())\n\n");
                #endif

                RETVAL_BOOL(((wxInputStream_php*)native_object)->Eof());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxInputStream::Eof\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxInputStream::CanRead()
   Returns true if some data is available in the stream right now, so that calling Read() wouldn't block. */
PHP_METHOD(php_wxInputStream, CanRead)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxInputStream::CanRead\n");
    php_printf("===========================================\n");
    #endif

    zo_wxInputStream* current_object;
    wxphp_object_type current_object_type;
    wxInputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxInputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxInputStream::CanRead call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXINPUTSTREAM_TYPE){
                references = &((wxInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILEINPUTSTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxInputStream::CanRead())\n\n");
                #endif

                RETVAL_BOOL(((wxInputStream_php*)native_object)->CanRead());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxInputStream::CanRead\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFFileOutputStream_free(void *object)
{
    zo_wxFFileOutputStream* custom_object = (zo_wxFFileOutputStream*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFFileOutputStream_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxFFileOutputStream done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxFFileOutputStream_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFFileOutputStream_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxFFileOutputStream* custom_object;

    custom_object = (zo_wxFFileOutputStream*) ecalloc(
        1,
        sizeof(zo_wxFFileOutputStream)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxFFileOutputStream_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFFILEOUTPUTSTREAM_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto bool wxFFileOutputStream::IsOk()
   Returns true if the stream is initialized and ready. */
PHP_METHOD(php_wxFFileOutputStream, IsOk)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFFileOutputStream::IsOk\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFFileOutputStream* current_object;
    wxphp_object_type current_object_type;
    wxFFileOutputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFFileOutputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFFileOutputStream::IsOk call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFFILEOUTPUTSTREAM_TYPE){
                references = &((wxFFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFFileOutputStream::IsOk())\n\n");
                #endif

                RETVAL_BOOL(((wxFFileOutputStream_php*)native_object)->IsOk());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFFileOutputStream::IsOk\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFFileOutputStream::wxFFileOutputStream(string filename, string mode)
   Open the given file filename with mode mode. */
PHP_METHOD(php_wxFFileOutputStream, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFFileOutputStream::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFFileOutputStream* current_object;
    wxFFileOutputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    char* filename0;
    size_t filename_len0;
    char* mode0;
    size_t mode_len0;
    bool overload0_called = false;

    //Parameters for overload 1
    zval* file1;
    wxFFile* object_pointer1_0 = 0;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|s' (&filename0, &filename_len0, &mode0, &mode_len0)\n");
        #endif

        char parse_parameters_string[] = "s|s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &filename0, &filename_len0, &mode0, &mode_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&file1, php_wxFFile_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &file1, php_wxFFile_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(file1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxFFile_P(file1)->object_type;
                    argument_native_object = (void*) Z_wxFFile_P(file1)->native_object;
                    object_pointer1_0 = (wxFFile*) argument_native_object;
                    if (!object_pointer1_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'file' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(file1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'file' not null, could not be retreived correctly.");
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(filename0, wxConvUTF8))\n");
                #endif

                native_object = new wxFFileOutputStream_php(wxString(filename0, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(filename0, wxConvUTF8), wxString(mode0, wxConvUTF8))\n");
                #endif

                native_object = new wxFFileOutputStream_php(wxString(filename0, wxConvUTF8), wxString(mode0, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxFFile*) object_pointer1_0)\n");
                #endif

                native_object = new wxFFileOutputStream_php(*(wxFFile*) object_pointer1_0);

                native_object->references.Initialize();
                ((wxFFileOutputStream_php*) native_object)->references.AddReference(file1, "wxFFileOutputStream::wxFFileOutputStream at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxFFileOutputStream_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxFFileOutputStream::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFileOutputStream_free(void *object)
{
    zo_wxFileOutputStream* custom_object = (zo_wxFileOutputStream*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFileOutputStream_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxFileOutputStream done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxFileOutputStream_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFileOutputStream_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxFileOutputStream* custom_object;

    custom_object = (zo_wxFileOutputStream*) ecalloc(
        1,
        sizeof(zo_wxFileOutputStream)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxFileOutputStream_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFILEOUTPUTSTREAM_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto bool wxFileOutputStream::IsOk()
   Returns true if the stream is initialized and ready. */
PHP_METHOD(php_wxFileOutputStream, IsOk)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileOutputStream::IsOk\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileOutputStream* current_object;
    wxphp_object_type current_object_type;
    wxFileOutputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileOutputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileOutputStream::IsOk call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILEOUTPUTSTREAM_TYPE){
                references = &((wxFileOutputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileOutputStream::IsOk())\n\n");
                #endif

                RETVAL_BOOL(((wxFileOutputStream_php*)native_object)->IsOk());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileOutputStream::IsOk\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileOutputStream::wxFileOutputStream(string ofileName)
   Creates a new file with ofileName name and initializes the stream in write-only mode. */
PHP_METHOD(php_wxFileOutputStream, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileOutputStream::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileOutputStream* current_object;
    wxFileOutputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    char* ofileName0;
    size_t ofileName_len0;
    bool overload0_called = false;

    //Parameters for overload 1
    zval* file1;
    wxFile* object_pointer1_0 = 0;
    bool overload1_called = false;

    //Parameters for overload 2
    long fd2;
    bool overload2_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&ofileName0, &ofileName_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &ofileName0, &ofileName_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&file1, php_wxFile_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &file1, php_wxFile_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(file1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxFile_P(file1)->object_type;
                    argument_native_object = (void*) Z_wxFile_P(file1)->native_object;
                    object_pointer1_0 = (wxFile*) argument_native_object;
                    if (!object_pointer1_0 )
                    {
                        goto overload2;
                    }
                }
                else if(Z_TYPE_P(file1) != IS_NULL)
                {
                    goto overload2;
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&fd2)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &fd2 ) == SUCCESS)
        {
            overload2_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(ofileName0, wxConvUTF8))\n");
                #endif

                native_object = new wxFileOutputStream_php(wxString(ofileName0, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxFile*) object_pointer1_0)\n");
                #endif

                native_object = new wxFileOutputStream_php(*(wxFile*) object_pointer1_0);

                native_object->references.Initialize();
                ((wxFileOutputStream_php*) native_object)->references.AddReference(file1, "wxFileOutputStream::wxFileOutputStream at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) fd2)\n");
                #endif

                native_object = new wxFileOutputStream_php((int) fd2);

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxFileOutputStream_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxFileOutputStream::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFileInputStream_free(void *object)
{
    zo_wxFileInputStream* custom_object = (zo_wxFileInputStream*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFileInputStream_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxFileInputStream done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxFileInputStream_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFileInputStream_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxFileInputStream* custom_object;

    custom_object = (zo_wxFileInputStream*) ecalloc(
        1,
        sizeof(zo_wxFileInputStream)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxFileInputStream_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFILEINPUTSTREAM_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto bool wxFileInputStream::IsOk()
   Returns true if the stream is initialized and ready. */
PHP_METHOD(php_wxFileInputStream, IsOk)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileInputStream::IsOk\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileInputStream* current_object;
    wxphp_object_type current_object_type;
    wxFileInputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileInputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileInputStream::IsOk call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILEINPUTSTREAM_TYPE){
                references = &((wxFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileInputStream::IsOk())\n\n");
                #endif

                RETVAL_BOOL(((wxFileInputStream_php*)native_object)->IsOk());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileInputStream::IsOk\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileInputStream::wxFileInputStream(string ifileName)
   Opens the specified file using its ifileName name in read-only mode. */
PHP_METHOD(php_wxFileInputStream, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileInputStream::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileInputStream* current_object;
    wxFileInputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    char* ifileName0;
    size_t ifileName_len0;
    bool overload0_called = false;

    //Parameters for overload 1
    zval* file1;
    wxFile* object_pointer1_0 = 0;
    bool overload1_called = false;

    //Parameters for overload 2
    long fd2;
    bool overload2_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&ifileName0, &ifileName_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &ifileName0, &ifileName_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&file1, php_wxFile_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &file1, php_wxFile_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(file1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxFile_P(file1)->object_type;
                    argument_native_object = (void*) Z_wxFile_P(file1)->native_object;
                    object_pointer1_0 = (wxFile*) argument_native_object;
                    if (!object_pointer1_0 )
                    {
                        goto overload2;
                    }
                }
                else if(Z_TYPE_P(file1) != IS_NULL)
                {
                    goto overload2;
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&fd2)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &fd2 ) == SUCCESS)
        {
            overload2_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(ifileName0, wxConvUTF8))\n");
                #endif

                native_object = new wxFileInputStream_php(wxString(ifileName0, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxFile*) object_pointer1_0)\n");
                #endif

                native_object = new wxFileInputStream_php(*(wxFile*) object_pointer1_0);

                native_object->references.Initialize();
                ((wxFileInputStream_php*) native_object)->references.AddReference(file1, "wxFileInputStream::wxFileInputStream at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) fd2)\n");
                #endif

                native_object = new wxFileInputStream_php((int) fd2);

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxFileInputStream_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxFileInputStream::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFFileInputStream_free(void *object)
{
    zo_wxFFileInputStream* custom_object = (zo_wxFFileInputStream*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFFileInputStream_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxFFileInputStream done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxFFileInputStream_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFFileInputStream_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxFFileInputStream* custom_object;

    custom_object = (zo_wxFFileInputStream*) ecalloc(
        1,
        sizeof(zo_wxFFileInputStream)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxFFileInputStream_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFFILEINPUTSTREAM_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxFFileInputStream::wxFFileInputStream(string filename, string mode)
   Opens the specified file using its filename name using the specified mode. */
PHP_METHOD(php_wxFFileInputStream, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFFileInputStream::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFFileInputStream* current_object;
    wxFFileInputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    char* filename0;
    size_t filename_len0;
    char* mode0;
    size_t mode_len0;
    bool overload0_called = false;

    //Parameters for overload 1
    zval* file1;
    wxFFile* object_pointer1_0 = 0;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|s' (&filename0, &filename_len0, &mode0, &mode_len0)\n");
        #endif

        char parse_parameters_string[] = "s|s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &filename0, &filename_len0, &mode0, &mode_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&file1, php_wxFFile_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &file1, php_wxFFile_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(file1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxFFile_P(file1)->object_type;
                    argument_native_object = (void*) Z_wxFFile_P(file1)->native_object;
                    object_pointer1_0 = (wxFFile*) argument_native_object;
                    if (!object_pointer1_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'file' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(file1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'file' not null, could not be retreived correctly.");
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(filename0, wxConvUTF8))\n");
                #endif

                native_object = new wxFFileInputStream_php(wxString(filename0, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(filename0, wxConvUTF8), wxString(mode0, wxConvUTF8))\n");
                #endif

                native_object = new wxFFileInputStream_php(wxString(filename0, wxConvUTF8), wxString(mode0, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxFFile*) object_pointer1_0)\n");
                #endif

                native_object = new wxFFileInputStream_php(*(wxFFile*) object_pointer1_0);

                native_object->references.Initialize();
                ((wxFFileInputStream_php*) native_object)->references.AddReference(file1, "wxFFileInputStream::wxFFileInputStream at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxFFileInputStream_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxFFileInputStream::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto bool wxFFileInputStream::IsOk()
   Returns true if the stream is initialized and ready. */
PHP_METHOD(php_wxFFileInputStream, IsOk)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFFileInputStream::IsOk\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFFileInputStream* current_object;
    wxphp_object_type current_object_type;
    wxFFileInputStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFFileInputStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFFileInputStream::IsOk call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFFILEINPUTSTREAM_TYPE){
                references = &((wxFFileInputStream_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFFILESTREAM_TYPE) && (!reference_type_found)){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFFileInputStream::IsOk())\n\n");
                #endif

                RETVAL_BOOL(((wxFFileInputStream_php*)native_object)->IsOk());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFFileInputStream::IsOk\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFFileStream_free(void *object)
{
    zo_wxFFileStream* custom_object = (zo_wxFFileStream*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFFileStream_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxFFileStream done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxFFileStream_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFFileStream_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxFFileStream* custom_object;

    custom_object = (zo_wxFFileStream*) ecalloc(
        1,
        sizeof(zo_wxFFileStream)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxFFileStream_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFFILESTREAM_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto bool wxFFileStream::IsOk()
   Returns true if the stream is initialized and ready. */
PHP_METHOD(php_wxFFileStream, IsOk)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFFileStream::IsOk\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFFileStream* current_object;
    wxphp_object_type current_object_type;
    wxFFileStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFFileStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFFileStream::IsOk call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFFILESTREAM_TYPE){
                references = &((wxFFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFFileStream::IsOk())\n\n");
                #endif

                RETVAL_BOOL(((wxFFileStream_php*)native_object)->IsOk());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFFileStream::IsOk\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFFileStream::wxFFileStream(string iofileName, string mode)
   Initializes a new file stream in the given mode using the specified iofileName name. */
PHP_METHOD(php_wxFFileStream, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFFileStream::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFFileStream* current_object;
    wxFFileStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    char* iofileName0;
    size_t iofileName_len0;
    char* mode0;
    size_t mode_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|s' (&iofileName0, &iofileName_len0, &mode0, &mode_len0)\n");
        #endif

        char parse_parameters_string[] = "s|s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &iofileName0, &iofileName_len0, &mode0, &mode_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(iofileName0, wxConvUTF8))\n");
                #endif

                native_object = new wxFFileStream_php(wxString(iofileName0, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(iofileName0, wxConvUTF8), wxString(mode0, wxConvUTF8))\n");
                #endif

                native_object = new wxFFileStream_php(wxString(iofileName0, wxConvUTF8), wxString(mode0, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxFFileStream_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxFFileStream::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFileStream_free(void *object)
{
    zo_wxFileStream* custom_object = (zo_wxFileStream*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFileStream_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxFileStream done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxFileStream_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFileStream_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxFileStream* custom_object;

    custom_object = (zo_wxFileStream*) ecalloc(
        1,
        sizeof(zo_wxFileStream)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxFileStream_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFILESTREAM_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto bool wxFileStream::IsOk()
   Returns true if the stream is initialized and ready. */
PHP_METHOD(php_wxFileStream, IsOk)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileStream::IsOk\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileStream* current_object;
    wxphp_object_type current_object_type;
    wxFileStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileStream_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileStream::IsOk call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILESTREAM_TYPE){
                references = &((wxFileStream_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileStream::IsOk())\n\n");
                #endif

                RETVAL_BOOL(((wxFileStream_php*)native_object)->IsOk());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileStream::IsOk\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileStream::wxFileStream(string iofileName)
   Initializes a new file stream in read-write mode using the specified iofileName name. */
PHP_METHOD(php_wxFileStream, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileStream::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileStream* current_object;
    wxFileStream_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    char* iofileName0;
    size_t iofileName_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&iofileName0, &iofileName_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &iofileName0, &iofileName_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(iofileName0, wxConvUTF8))\n");
                #endif

                native_object = new wxFileStream_php(wxString(iofileName0, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxFileStream_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxFileStream::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

