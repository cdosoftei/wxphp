/*
 * @author Mário Soares
 * @contributors Jefferson González
 * @contributors René Vögeli / Rangee GmbH
 * 
 * @license 
 * This file is part of wxPHP check the LICENSE file for information.
 * 
 * @note
 * This file was auto-generated by the wxPHP source maker
*/

#include "php_wxwidgets.h"
#include "appmanagement.h"
#include "cfg.h"
#include "bookctrl.h"
#include "dnd.h"
#include "cmndlg.h"
#include "containers.h"
#include "ctrl.h"
#include "data.h"
#include "dc.h"
#include "docview.h"
#include "events.h"
#include "file.h"
#include "gdi.h"
#include "grid.h"
#include "html.h"
#include "help.h"
#include "logging.h"
#include "managedwnd.h"
#include "menus.h"
#include "misc.h"
#include "miscwnd.h"
#include "media.h"
#include "net.h"
#include "pickers.h"
#include "printing.h"
#include "ribbon.h"
#include "richtext.h"
#include "rtti.h"
#include "stc.h"
#include "streams.h"
#include "threading.h"
#include "validator.h"
#include "vfs.h"
#include "aui.h"
#include "winlayout.h"
#include "xml.h"
#include "xrc.h"
#include "dvc.h"
#include "others.h"


BEGIN_EXTERN_C()
void php_wxConfigBase_free(zend_object *object)
{
    zo_wxConfigBase* custom_object = php_wxConfigBase_fetch_object(object);

    if (custom_object->is_user_initialized && (custom_object->native_object != NULL)) {
        custom_object->native_object->zo = NULL;
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxConfigBase_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxConfigBase done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
}

wxConfigBase_php::~wxConfigBase_php()
{
    if (zo) {
        zo->native_object = NULL;
    }
}

zend_object* php_wxConfigBase_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxConfigBase_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxConfigBase* custom_object;

    custom_object = (zo_wxConfigBase*) ecalloc(
        1,
        sizeof(zo_wxConfigBase)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    memcpy(&wxphp_wxConfigBase_object_handlers, zend_get_std_object_handlers(), sizeof wxphp_wxConfigBase_object_handlers);
    wxphp_wxConfigBase_object_handlers.offset = XtOffsetOf(zo_wxConfigBase, zo);
    wxphp_wxConfigBase_object_handlers.free_obj = php_wxConfigBase_free;
    custom_object->zo.handlers = &wxphp_wxConfigBase_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXCONFIGBASE_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto wxConfigBase wxConfigBase::Create()
   Create a new config object and sets it as the current one. */
PHP_METHOD(php_wxConfigBase, Create)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxConfigBase::Create\n");
    php_printf("===========================================\n");
    #endif

    zo_wxConfigBase* current_object;
    wxphp_object_type current_object_type;
    wxConfigBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxConfigBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxConfigBase::Create call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCONFIGBASE_TYPE){
                references = &((wxConfigBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILECONFIG_TYPE) && (!reference_type_found)){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxConfigBase::Create() to return object pointer\n\n");
                #endif

                wxConfigBase_php* value_to_return0;
                value_to_return0 = (wxConfigBase_php*) wxConfigBase::Create();
                if(value_to_return0 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxConfigBase_entry);
                    Z_wxConfigBase_P(return_value)->native_object = (wxConfigBase_php*) value_to_return0;
                }



                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxConfigBase::Create\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxConfigBase::DeleteAll()
   Delete the whole underlying object (disk file, registry key, ...). */
bool wxConfigBase_php::DeleteAll()
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxConfigBase::DeleteAll\n");
    php_printf("===========================================\n");
    #endif

    zval* params[1];
    zval arguments[1];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "DeleteAll");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "DeleteAll");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "DeleteAll",
            9,
            &function_return_value,
            0,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxConfigBase::DeleteAll'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return Z_TYPE(function_return_value) == IS_TRUE;

}
/* }}} */

/* {{{ proto bool wxConfigBase::DeleteEntry(string key, bool bDeleteGroupIfEmpty)
   Deletes the specified entry and the group it belongs to if it was the last key in it and the second parameter is true. */
bool wxConfigBase_php::DeleteEntry(const wxString& key, bool bDeleteGroupIfEmpty)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxConfigBase::DeleteEntry\n");
    php_printf("===========================================\n");
    #endif

    zval* params[2];
    zval arguments[2];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "DeleteEntry");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    ZVAL_STRING(&arguments[0], key.ToUTF8().data());
    ZVAL_BOOL(&arguments[1], bDeleteGroupIfEmpty);
    
    for(int i=0; i<2; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "DeleteEntry");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "DeleteEntry",
            11,
            &function_return_value,
            2,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<2; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxConfigBase::DeleteEntry'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return Z_TYPE(function_return_value) == IS_TRUE;

}
/* }}} */

/* {{{ proto bool wxConfigBase::DeleteGroup(string key)
   Delete the group (with all subgroups). */
bool wxConfigBase_php::DeleteGroup(const wxString& key)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxConfigBase::DeleteGroup\n");
    php_printf("===========================================\n");
    #endif

    zval* params[1];
    zval arguments[1];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "DeleteGroup");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    ZVAL_STRING(&arguments[0], key.ToUTF8().data());
    
    for(int i=0; i<1; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "DeleteGroup");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "DeleteGroup",
            11,
            &function_return_value,
            1,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<1; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxConfigBase::DeleteGroup'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return Z_TYPE(function_return_value) == IS_TRUE;

}
/* }}} */

/* {{{ proto  wxConfigBase::DontCreateOnDemand()
   Calling this function will prevent Get() from automatically creating a new config object if the current one is NULL. */
PHP_METHOD(php_wxConfigBase, DontCreateOnDemand)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxConfigBase::DontCreateOnDemand\n");
    php_printf("===========================================\n");
    #endif

    zo_wxConfigBase* current_object;
    wxphp_object_type current_object_type;
    wxConfigBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxConfigBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxConfigBase::DontCreateOnDemand call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCONFIGBASE_TYPE){
                references = &((wxConfigBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILECONFIG_TYPE) && (!reference_type_found)){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxConfigBase::DontCreateOnDemand()\n\n");
                #endif

                wxConfigBase::DontCreateOnDemand();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxConfigBase::DontCreateOnDemand\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxConfigBase::Exists(string strName) */
PHP_METHOD(php_wxConfigBase, Exists)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxConfigBase::Exists\n");
    php_printf("===========================================\n");
    #endif

    zo_wxConfigBase* current_object;
    wxphp_object_type current_object_type;
    wxConfigBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxConfigBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxConfigBase::Exists call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCONFIGBASE_TYPE){
                references = &((wxConfigBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILECONFIG_TYPE) && (!reference_type_found)){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* strName0;
    size_t strName_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&strName0, &strName_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &strName0, &strName_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxConfigBase::Exists(wxString(strName0, wxConvUTF8)))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->Exists(wxString(strName0, wxConvUTF8)));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxConfigBase_php*)native_object)->Exists(wxString(strName0, wxConvUTF8)));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxConfigBase::Exists\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxConfigBase::Flush(bool bCurrentOnly)
   Permanently writes all changes (otherwise, they're only written from object's destructor). */
bool wxConfigBase_php::Flush(bool bCurrentOnly)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxConfigBase::Flush\n");
    php_printf("===========================================\n");
    #endif

    zval* params[1];
    zval arguments[1];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "Flush");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    ZVAL_BOOL(&arguments[0], bCurrentOnly);
    
    for(int i=0; i<1; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "Flush");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "Flush",
            5,
            &function_return_value,
            1,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<1; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxConfigBase::Flush'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return Z_TYPE(function_return_value) == IS_TRUE;

}
/* }}} */

/* {{{ proto wxConfigBase wxConfigBase::Get(bool CreateOnDemand)
   Get the current config object. */
PHP_METHOD(php_wxConfigBase, Get)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxConfigBase::Get\n");
    php_printf("===========================================\n");
    #endif

    zo_wxConfigBase* current_object;
    wxphp_object_type current_object_type;
    wxConfigBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxConfigBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxConfigBase::Get call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCONFIGBASE_TYPE){
                references = &((wxConfigBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILECONFIG_TYPE) && (!reference_type_found)){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool CreateOnDemand0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|b' (&CreateOnDemand0)\n");
        #endif

        char parse_parameters_string[] = "|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &CreateOnDemand0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxConfigBase::Get() to return object pointer\n\n");
                #endif

                wxConfigBase_php* value_to_return0;
                value_to_return0 = (wxConfigBase_php*) wxConfigBase::Get();
                if(value_to_return0 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxConfigBase_entry);
                    Z_wxConfigBase_P(return_value)->native_object = (wxConfigBase_php*) value_to_return0;
                }



                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxConfigBase::Get(CreateOnDemand0) to return object pointer\n\n");
                #endif

                wxConfigBase_php* value_to_return1;
                value_to_return1 = (wxConfigBase_php*) wxConfigBase::Get(CreateOnDemand0);
                if(value_to_return1 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return1->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return1->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return1->phpObj);
                        zval_add_ref(&value_to_return1->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxConfigBase_entry);
                    Z_wxConfigBase_P(return_value)->native_object = (wxConfigBase_php*) value_to_return1;
                }



                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxConfigBase::Get\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxConfigBase::GetAppName()
   Returns the application name. */
PHP_METHOD(php_wxConfigBase, GetAppName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxConfigBase::GetAppName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxConfigBase* current_object;
    wxphp_object_type current_object_type;
    wxConfigBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxConfigBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxConfigBase::GetAppName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCONFIGBASE_TYPE){
                references = &((wxConfigBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILECONFIG_TYPE) && (!reference_type_found)){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxConfigBase::GetAppName().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    value_to_return0 = ((wxFileConfig_php*)native_object)->GetAppName();
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    value_to_return0 = ((wxConfigBase_php*)native_object)->GetAppName();
                }
                WXPHP_RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxConfigBase::GetAppName\n"
        );
    }
}
/* }}} */

/* {{{ proto wxConfigBase::EntryType wxConfigBase::GetEntryType(string name)
   Returns the type of the given entry or Unknown if the entry doesn't exist. */
PHP_METHOD(php_wxConfigBase, GetEntryType)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxConfigBase::GetEntryType\n");
    php_printf("===========================================\n");
    #endif

    zo_wxConfigBase* current_object;
    wxphp_object_type current_object_type;
    wxConfigBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxConfigBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxConfigBase::GetEntryType call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCONFIGBASE_TYPE){
                references = &((wxConfigBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILECONFIG_TYPE) && (!reference_type_found)){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxConfigBase::GetEntryType(wxString(name0, wxConvUTF8)))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_LONG(((wxFileConfig_php*)native_object)->GetEntryType(wxString(name0, wxConvUTF8)));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_LONG(((wxConfigBase_php*)native_object)->GetEntryType(wxString(name0, wxConvUTF8)));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxConfigBase::GetEntryType\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxConfigBase::GetFirstEntry(string &str, int &index)
   Gets the first entry. */
bool wxConfigBase_php::GetFirstEntry(wxString& str, long& index)const
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxConfigBase::GetFirstEntry\n");
    php_printf("===========================================\n");
    #endif

    zval* params[2];
    zval arguments[2];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "GetFirstEntry");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    ZVAL_STRING(&arguments[0], str.ToUTF8().data());
    ZVAL_LONG(&arguments[1], index);
    
    for(int i=0; i<2; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "GetFirstEntry");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "GetFirstEntry",
            13,
            &function_return_value,
            2,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<2; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxConfigBase::GetFirstEntry'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return Z_TYPE(function_return_value) == IS_TRUE;

}
/* }}} */

/* {{{ proto bool wxConfigBase::GetFirstGroup(string &str, int &index)
   Gets the first group. */
bool wxConfigBase_php::GetFirstGroup(wxString& str, long& index)const
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxConfigBase::GetFirstGroup\n");
    php_printf("===========================================\n");
    #endif

    zval* params[2];
    zval arguments[2];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "GetFirstGroup");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    ZVAL_STRING(&arguments[0], str.ToUTF8().data());
    ZVAL_LONG(&arguments[1], index);
    
    for(int i=0; i<2; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "GetFirstGroup");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "GetFirstGroup",
            13,
            &function_return_value,
            2,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<2; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxConfigBase::GetFirstGroup'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return Z_TYPE(function_return_value) == IS_TRUE;

}
/* }}} */

/* {{{ proto bool wxConfigBase::GetNextEntry(string &str, int &index)
   Gets the next entry. */
bool wxConfigBase_php::GetNextEntry(wxString& str, long& index)const
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxConfigBase::GetNextEntry\n");
    php_printf("===========================================\n");
    #endif

    zval* params[2];
    zval arguments[2];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "GetNextEntry");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    ZVAL_STRING(&arguments[0], str.ToUTF8().data());
    ZVAL_LONG(&arguments[1], index);
    
    for(int i=0; i<2; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "GetNextEntry");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "GetNextEntry",
            12,
            &function_return_value,
            2,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<2; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxConfigBase::GetNextEntry'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return Z_TYPE(function_return_value) == IS_TRUE;

}
/* }}} */

/* {{{ proto bool wxConfigBase::GetNextGroup(string &str, int &index)
   Gets the next group. */
bool wxConfigBase_php::GetNextGroup(wxString& str, long& index)const
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxConfigBase::GetNextGroup\n");
    php_printf("===========================================\n");
    #endif

    zval* params[2];
    zval arguments[2];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "GetNextGroup");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    ZVAL_STRING(&arguments[0], str.ToUTF8().data());
    ZVAL_LONG(&arguments[1], index);
    
    for(int i=0; i<2; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "GetNextGroup");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "GetNextGroup",
            12,
            &function_return_value,
            2,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<2; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxConfigBase::GetNextGroup'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return Z_TYPE(function_return_value) == IS_TRUE;

}
/* }}} */

/* {{{ proto int wxConfigBase::GetNumberOfEntries(bool bRecursive)
   Get number of entries in the current group. */
size_t wxConfigBase_php::GetNumberOfEntries(bool bRecursive)const
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxConfigBase::GetNumberOfEntries\n");
    php_printf("===========================================\n");
    #endif

    zval* params[1];
    zval arguments[1];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "GetNumberOfEntries");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    ZVAL_BOOL(&arguments[0], bRecursive);
    
    for(int i=0; i<1; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "GetNumberOfEntries");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "GetNumberOfEntries",
            18,
            &function_return_value,
            1,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<1; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxConfigBase::GetNumberOfEntries'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return (size_t) Z_LVAL(function_return_value);

}
/* }}} */

/* {{{ proto int wxConfigBase::GetNumberOfGroups(bool bRecursive)
   Get number of entries/subgroups in the current group, with or without its subgroups. */
size_t wxConfigBase_php::GetNumberOfGroups(bool bRecursive)const
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxConfigBase::GetNumberOfGroups\n");
    php_printf("===========================================\n");
    #endif

    zval* params[1];
    zval arguments[1];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "GetNumberOfGroups");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    ZVAL_BOOL(&arguments[0], bRecursive);
    
    for(int i=0; i<1; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "GetNumberOfGroups");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "GetNumberOfGroups",
            17,
            &function_return_value,
            1,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<1; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxConfigBase::GetNumberOfGroups'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return (size_t) Z_LVAL(function_return_value);

}
/* }}} */

/* {{{ proto string wxConfigBase::GetPath()
   Retrieve the current path (always as absolute path). */
const wxString& wxConfigBase_php::GetPath()const
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxConfigBase::GetPath\n");
    php_printf("===========================================\n");
    #endif

    zval* params[1];
    zval arguments[1];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "GetPath");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "GetPath");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "GetPath",
            7,
            &function_return_value,
            0,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxConfigBase::GetPath'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return wxString(Z_STRVAL(function_return_value), wxConvUTF8);

}
/* }}} */

/* {{{ proto string wxConfigBase::GetVendorName()
   Returns the vendor name. */
PHP_METHOD(php_wxConfigBase, GetVendorName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxConfigBase::GetVendorName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxConfigBase* current_object;
    wxphp_object_type current_object_type;
    wxConfigBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxConfigBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxConfigBase::GetVendorName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCONFIGBASE_TYPE){
                references = &((wxConfigBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILECONFIG_TYPE) && (!reference_type_found)){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxConfigBase::GetVendorName().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    value_to_return0 = ((wxFileConfig_php*)native_object)->GetVendorName();
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    value_to_return0 = ((wxConfigBase_php*)native_object)->GetVendorName();
                }
                WXPHP_RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxConfigBase::GetVendorName\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxConfigBase::HasEntry(string strName) */
bool wxConfigBase_php::HasEntry(const wxString& strName)const
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxConfigBase::HasEntry\n");
    php_printf("===========================================\n");
    #endif

    zval* params[1];
    zval arguments[1];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "HasEntry");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    ZVAL_STRING(&arguments[0], strName.ToUTF8().data());
    
    for(int i=0; i<1; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "HasEntry");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "HasEntry",
            8,
            &function_return_value,
            1,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<1; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxConfigBase::HasEntry'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return Z_TYPE(function_return_value) == IS_TRUE;

}
/* }}} */

/* {{{ proto bool wxConfigBase::HasGroup(string strName) */
bool wxConfigBase_php::HasGroup(const wxString& strName)const
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxConfigBase::HasGroup\n");
    php_printf("===========================================\n");
    #endif

    zval* params[1];
    zval arguments[1];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "HasGroup");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    ZVAL_STRING(&arguments[0], strName.ToUTF8().data());
    
    for(int i=0; i<1; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "HasGroup");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "HasGroup",
            8,
            &function_return_value,
            1,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<1; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxConfigBase::HasGroup'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return Z_TYPE(function_return_value) == IS_TRUE;

}
/* }}} */

/* {{{ proto bool wxConfigBase::IsExpandingEnvVars()
   Returns true if we are expanding environment variables in key values. */
PHP_METHOD(php_wxConfigBase, IsExpandingEnvVars)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxConfigBase::IsExpandingEnvVars\n");
    php_printf("===========================================\n");
    #endif

    zo_wxConfigBase* current_object;
    wxphp_object_type current_object_type;
    wxConfigBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxConfigBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxConfigBase::IsExpandingEnvVars call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCONFIGBASE_TYPE){
                references = &((wxConfigBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILECONFIG_TYPE) && (!reference_type_found)){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxConfigBase::IsExpandingEnvVars())\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->IsExpandingEnvVars());
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxConfigBase_php*)native_object)->IsExpandingEnvVars());
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxConfigBase::IsExpandingEnvVars\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxConfigBase::IsRecordingDefaults()
   Returns true if we are writing defaults back to the config file. */
PHP_METHOD(php_wxConfigBase, IsRecordingDefaults)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxConfigBase::IsRecordingDefaults\n");
    php_printf("===========================================\n");
    #endif

    zo_wxConfigBase* current_object;
    wxphp_object_type current_object_type;
    wxConfigBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxConfigBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxConfigBase::IsRecordingDefaults call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCONFIGBASE_TYPE){
                references = &((wxConfigBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILECONFIG_TYPE) && (!reference_type_found)){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxConfigBase::IsRecordingDefaults())\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->IsRecordingDefaults());
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxConfigBase_php*)native_object)->IsRecordingDefaults());
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxConfigBase::IsRecordingDefaults\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxConfigBase::Read(string key, string &str)
   Read a string from the key, returning true if the value was read. */
PHP_METHOD(php_wxConfigBase, Read)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxConfigBase::Read\n");
    php_printf("===========================================\n");
    #endif

    zo_wxConfigBase* current_object;
    wxphp_object_type current_object_type;
    wxConfigBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxConfigBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxConfigBase::Read call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCONFIGBASE_TYPE){
                references = &((wxConfigBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILECONFIG_TYPE) && (!reference_type_found)){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* key0;
    size_t key_len0;
    char* str0;
    size_t str_len0;
    zval str0_ref;
    bool overload0_called = false;

    //Parameters for overload 1
    char* key1;
    size_t key_len1;
    char* str1;
    size_t str_len1;
    zval str1_ref;
    char* defaultVal1;
    size_t defaultVal_len1;
    bool overload1_called = false;

    //Parameters for overload 2
    char* key2;
    size_t key_len2;
    char* defaultVal2;
    size_t defaultVal_len2;
    bool overload2_called = false;

    //Parameters for overload 3
    char* key3;
    size_t key_len3;
    long* l3;
    zval l3_ref;
    bool overload3_called = false;

    //Parameters for overload 4
    char* key4;
    size_t key_len4;
    long* l4;
    zval l4_ref;
    long defaultVal4;
    bool overload4_called = false;

    //Parameters for overload 5
    char* key5;
    size_t key_len5;
    long* value5;
    zval value5_ref;
    bool overload5_called = false;

    //Parameters for overload 6
    char* key6;
    size_t key_len6;
    long* value6;
    zval value6_ref;
    long defaultVal6;
    bool overload6_called = false;

    //Parameters for overload 7
    char* key7;
    size_t key_len7;
    double* d7;
    zval d7_ref;
    bool overload7_called = false;

    //Parameters for overload 8
    char* key8;
    size_t key_len8;
    double* d8;
    zval d8_ref;
    double defaultVal8;
    bool overload8_called = false;

    //Parameters for overload 9
    char* key9;
    size_t key_len9;
    double* f9;
    zval f9_ref;
    bool overload9_called = false;

    //Parameters for overload 10
    char* key10;
    size_t key_len10;
    double* f10;
    zval f10_ref;
    double defaultVal10;
    bool overload10_called = false;

    //Parameters for overload 11
    char* key11;
    size_t key_len11;
    bool* b11;
    zval b11_ref;
    bool overload11_called = false;

    //Parameters for overload 12
    char* key12;
    size_t key_len12;
    bool* d12;
    zval d12_ref;
    bool defaultVal12;
    bool overload12_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ss' (&key0, &key_len0, &str0, &str_len0)\n");
        #endif

        char parse_parameters_string[] = "ss";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key0, &key_len0, &str0, &str_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;

            char parse_references_string[] = "zz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, str0_ref );
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sss' (&key1, &key_len1, &str1, &str_len1, &defaultVal1, &defaultVal_len1)\n");
        #endif

        char parse_parameters_string[] = "sss";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key1, &key_len1, &str1, &str_len1, &defaultVal1, &defaultVal_len1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;

            char parse_references_string[] = "zzz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, str1_ref, dummy );
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ss' (&key2, &key_len2, &defaultVal2, &defaultVal_len2)\n");
        #endif

        char parse_parameters_string[] = "ss";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key2, &key_len2, &defaultVal2, &defaultVal_len2 ) == SUCCESS)
        {
            overload2_called = true;
            already_called = true;
        }
    }

    //Overload 3
    overload3:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sl' (&key3, &key_len3, l3)\n");
        #endif

        char parse_parameters_string[] = "sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key3, &key_len3, l3 ) == SUCCESS)
        {
            overload3_called = true;
            already_called = true;

            char parse_references_string[] = "zz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, l3_ref );
        }
    }

    //Overload 4
    overload4:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sll' (&key4, &key_len4, l4, &defaultVal4)\n");
        #endif

        char parse_parameters_string[] = "sll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key4, &key_len4, l4, &defaultVal4 ) == SUCCESS)
        {
            overload4_called = true;
            already_called = true;

            char parse_references_string[] = "zzz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, l4_ref, dummy );
        }
    }

    //Overload 5
    overload5:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sl' (&key5, &key_len5, value5)\n");
        #endif

        char parse_parameters_string[] = "sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key5, &key_len5, value5 ) == SUCCESS)
        {
            overload5_called = true;
            already_called = true;

            char parse_references_string[] = "zz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, value5_ref );
        }
    }

    //Overload 6
    overload6:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sll' (&key6, &key_len6, value6, &defaultVal6)\n");
        #endif

        char parse_parameters_string[] = "sll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key6, &key_len6, value6, &defaultVal6 ) == SUCCESS)
        {
            overload6_called = true;
            already_called = true;

            char parse_references_string[] = "zzz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, value6_ref, dummy );
        }
    }

    //Overload 7
    overload7:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sd' (&key7, &key_len7, d7)\n");
        #endif

        char parse_parameters_string[] = "sd";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key7, &key_len7, d7 ) == SUCCESS)
        {
            overload7_called = true;
            already_called = true;

            char parse_references_string[] = "zz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, d7_ref );
        }
    }

    //Overload 8
    overload8:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sdd' (&key8, &key_len8, d8, &defaultVal8)\n");
        #endif

        char parse_parameters_string[] = "sdd";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key8, &key_len8, d8, &defaultVal8 ) == SUCCESS)
        {
            overload8_called = true;
            already_called = true;

            char parse_references_string[] = "zzz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, d8_ref, dummy );
        }
    }

    //Overload 9
    overload9:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sd' (&key9, &key_len9, f9)\n");
        #endif

        char parse_parameters_string[] = "sd";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key9, &key_len9, f9 ) == SUCCESS)
        {
            overload9_called = true;
            already_called = true;

            char parse_references_string[] = "zz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, f9_ref );
        }
    }

    //Overload 10
    overload10:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sdd' (&key10, &key_len10, f10, &defaultVal10)\n");
        #endif

        char parse_parameters_string[] = "sdd";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key10, &key_len10, f10, &defaultVal10 ) == SUCCESS)
        {
            overload10_called = true;
            already_called = true;

            char parse_references_string[] = "zzz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, f10_ref, dummy );
        }
    }

    //Overload 11
    overload11:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sb' (&key11, &key_len11, b11)\n");
        #endif

        char parse_parameters_string[] = "sb";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key11, &key_len11, b11 ) == SUCCESS)
        {
            overload11_called = true;
            already_called = true;

            char parse_references_string[] = "zz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, b11_ref );
        }
    }

    //Overload 12
    overload12:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sbb' (&key12, &key_len12, d12, &defaultVal12)\n");
        #endif

        char parse_parameters_string[] = "sbb";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key12, &key_len12, d12, &defaultVal12 ) == SUCCESS)
        {
            overload12_called = true;
            already_called = true;

            char parse_references_string[] = "zzz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, d12_ref, dummy );
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                wxString string_arg0_1 = wxString(str0, wxConvUTF8);
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxConfigBase::Read(wxString(key0, wxConvUTF8), &string_arg0_1))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->Read(wxString(key0, wxConvUTF8), &string_arg0_1));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxConfigBase_php*)native_object)->Read(wxString(key0, wxConvUTF8), &string_arg0_1));
                }

                ZVAL_STRING(&str0_ref, string_arg0_1.ToUTF8().data());

                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                wxString string_arg1_1 = wxString(str1, wxConvUTF8);
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxConfigBase::Read(wxString(key1, wxConvUTF8), &string_arg1_1, wxString(defaultVal1, wxConvUTF8)))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->Read(wxString(key1, wxConvUTF8), &string_arg1_1, wxString(defaultVal1, wxConvUTF8)));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxConfigBase_php*)native_object)->Read(wxString(key1, wxConvUTF8), &string_arg1_1, wxString(defaultVal1, wxConvUTF8)));
                }

                ZVAL_STRING(&str1_ref, string_arg1_1.ToUTF8().data());

                return;
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxConfigBase::Read(wxString(key2, wxConvUTF8), wxString(defaultVal2, wxConvUTF8)).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return2;
                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    value_to_return2 = ((wxFileConfig_php*)native_object)->Read(wxString(key2, wxConvUTF8), wxString(defaultVal2, wxConvUTF8));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    value_to_return2 = ((wxConfigBase_php*)native_object)->Read(wxString(key2, wxConvUTF8), wxString(defaultVal2, wxConvUTF8));
                }
                WXPHP_RETVAL_STRING(value_to_return2.ToUTF8().data());


                return;
                break;
            }
        }
    }

    if(overload3_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxConfigBase::Read(wxString(key3, wxConvUTF8), (long*) l3))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->Read(wxString(key3, wxConvUTF8), (long*) l3));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxConfigBase_php*)native_object)->Read(wxString(key3, wxConvUTF8), (long*) l3));
                }

                size_t elements_returned3_1 = sizeof(l3)/sizeof(*l3);
                array_init(&l3_ref);
                for(size_t i=0; i<elements_returned3_1; i++)
                {
                    add_next_index_long(&l3_ref, l3[i]);
                }

                return;
                break;
            }
        }
    }

    if(overload4_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxConfigBase::Read(wxString(key4, wxConvUTF8), (long*) l4, (long) defaultVal4))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->Read(wxString(key4, wxConvUTF8), (long*) l4, (long) defaultVal4));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxConfigBase_php*)native_object)->Read(wxString(key4, wxConvUTF8), (long*) l4, (long) defaultVal4));
                }

                size_t elements_returned4_1 = sizeof(l4)/sizeof(*l4);
                array_init(&l4_ref);
                for(size_t i=0; i<elements_returned4_1; i++)
                {
                    add_next_index_long(&l4_ref, l4[i]);
                }

                return;
                break;
            }
        }
    }

    if(overload5_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxConfigBase::Read(wxString(key5, wxConvUTF8), (size_t*) value5))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->Read(wxString(key5, wxConvUTF8), (size_t*) value5));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxConfigBase_php*)native_object)->Read(wxString(key5, wxConvUTF8), (size_t*) value5));
                }

                size_t elements_returned5_1 = sizeof(value5)/sizeof(*value5);
                array_init(&value5_ref);
                for(size_t i=0; i<elements_returned5_1; i++)
                {
                    add_next_index_long(&value5_ref, value5[i]);
                }

                return;
                break;
            }
        }
    }

    if(overload6_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxConfigBase::Read(wxString(key6, wxConvUTF8), (size_t*) value6, (size_t) defaultVal6))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->Read(wxString(key6, wxConvUTF8), (size_t*) value6, (size_t) defaultVal6));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxConfigBase_php*)native_object)->Read(wxString(key6, wxConvUTF8), (size_t*) value6, (size_t) defaultVal6));
                }

                size_t elements_returned6_1 = sizeof(value6)/sizeof(*value6);
                array_init(&value6_ref);
                for(size_t i=0; i<elements_returned6_1; i++)
                {
                    add_next_index_long(&value6_ref, value6[i]);
                }

                return;
                break;
            }
        }
    }

    if(overload7_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxConfigBase::Read(wxString(key7, wxConvUTF8), d7))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->Read(wxString(key7, wxConvUTF8), d7));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxConfigBase_php*)native_object)->Read(wxString(key7, wxConvUTF8), d7));
                }

                size_t elements_returned7_1 = sizeof(d7)/sizeof(*d7);
                array_init(&d7_ref);
                for(size_t i=0; i<elements_returned7_1; i++)
                {
                    add_next_index_long(&d7_ref, d7[i]);
                }

                return;
                break;
            }
        }
    }

    if(overload8_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxConfigBase::Read(wxString(key8, wxConvUTF8), d8, defaultVal8))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->Read(wxString(key8, wxConvUTF8), d8, defaultVal8));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxConfigBase_php*)native_object)->Read(wxString(key8, wxConvUTF8), d8, defaultVal8));
                }

                size_t elements_returned8_1 = sizeof(d8)/sizeof(*d8);
                array_init(&d8_ref);
                for(size_t i=0; i<elements_returned8_1; i++)
                {
                    add_next_index_long(&d8_ref, d8[i]);
                }

                return;
                break;
            }
        }
    }

    if(overload9_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxConfigBase::Read(wxString(key9, wxConvUTF8), f9))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->Read(wxString(key9, wxConvUTF8), f9));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxConfigBase_php*)native_object)->Read(wxString(key9, wxConvUTF8), f9));
                }

                size_t elements_returned9_1 = sizeof(f9)/sizeof(*f9);
                array_init(&f9_ref);
                for(size_t i=0; i<elements_returned9_1; i++)
                {
                    add_next_index_long(&f9_ref, f9[i]);
                }

                return;
                break;
            }
        }
    }

    if(overload10_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxConfigBase::Read(wxString(key10, wxConvUTF8), f10, defaultVal10))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->Read(wxString(key10, wxConvUTF8), f10, defaultVal10));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxConfigBase_php*)native_object)->Read(wxString(key10, wxConvUTF8), f10, defaultVal10));
                }

                size_t elements_returned10_1 = sizeof(f10)/sizeof(*f10);
                array_init(&f10_ref);
                for(size_t i=0; i<elements_returned10_1; i++)
                {
                    add_next_index_long(&f10_ref, f10[i]);
                }

                return;
                break;
            }
        }
    }

    if(overload11_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxConfigBase::Read(wxString(key11, wxConvUTF8), b11))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->Read(wxString(key11, wxConvUTF8), b11));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxConfigBase_php*)native_object)->Read(wxString(key11, wxConvUTF8), b11));
                }

                size_t elements_returned11_1 = sizeof(b11)/sizeof(*b11);
                array_init(&b11_ref);
                for(size_t i=0; i<elements_returned11_1; i++)
                {
                    add_next_index_long(&b11_ref, b11[i]);
                }

                return;
                break;
            }
        }
    }

    if(overload12_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxConfigBase::Read(wxString(key12, wxConvUTF8), d12, defaultVal12))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->Read(wxString(key12, wxConvUTF8), d12, defaultVal12));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxConfigBase_php*)native_object)->Read(wxString(key12, wxConvUTF8), d12, defaultVal12));
                }

                size_t elements_returned12_1 = sizeof(d12)/sizeof(*d12);
                array_init(&d12_ref);
                for(size_t i=0; i<elements_returned12_1; i++)
                {
                    add_next_index_long(&d12_ref, d12[i]);
                }

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxConfigBase::Read\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxConfigBase::ReadBool(string key, bool defaultVal)
   Reads a bool value from the key and returns it. */
PHP_METHOD(php_wxConfigBase, ReadBool)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxConfigBase::ReadBool\n");
    php_printf("===========================================\n");
    #endif

    zo_wxConfigBase* current_object;
    wxphp_object_type current_object_type;
    wxConfigBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxConfigBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxConfigBase::ReadBool call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCONFIGBASE_TYPE){
                references = &((wxConfigBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILECONFIG_TYPE) && (!reference_type_found)){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* key0;
    size_t key_len0;
    bool defaultVal0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sb' (&key0, &key_len0, &defaultVal0)\n");
        #endif

        char parse_parameters_string[] = "sb";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key0, &key_len0, &defaultVal0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxConfigBase::ReadBool(wxString(key0, wxConvUTF8), defaultVal0))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->ReadBool(wxString(key0, wxConvUTF8), defaultVal0));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxConfigBase_php*)native_object)->ReadBool(wxString(key0, wxConvUTF8), defaultVal0));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxConfigBase::ReadBool\n"
        );
    }
}
/* }}} */

/* {{{ proto float wxConfigBase::ReadDouble(string key, float defaultVal)
   Reads a double value from the key and returns it. */
PHP_METHOD(php_wxConfigBase, ReadDouble)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxConfigBase::ReadDouble\n");
    php_printf("===========================================\n");
    #endif

    zo_wxConfigBase* current_object;
    wxphp_object_type current_object_type;
    wxConfigBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxConfigBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxConfigBase::ReadDouble call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCONFIGBASE_TYPE){
                references = &((wxConfigBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILECONFIG_TYPE) && (!reference_type_found)){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* key0;
    size_t key_len0;
    double defaultVal0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sd' (&key0, &key_len0, &defaultVal0)\n");
        #endif

        char parse_parameters_string[] = "sd";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key0, &key_len0, &defaultVal0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxConfigBase::ReadDouble(wxString(key0, wxConvUTF8), defaultVal0))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_DOUBLE(((wxFileConfig_php*)native_object)->ReadDouble(wxString(key0, wxConvUTF8), defaultVal0));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_DOUBLE(((wxConfigBase_php*)native_object)->ReadDouble(wxString(key0, wxConvUTF8), defaultVal0));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxConfigBase::ReadDouble\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxConfigBase::ReadLong(string key, int defaultVal)
   Reads a long value from the key and returns it. */
PHP_METHOD(php_wxConfigBase, ReadLong)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxConfigBase::ReadLong\n");
    php_printf("===========================================\n");
    #endif

    zo_wxConfigBase* current_object;
    wxphp_object_type current_object_type;
    wxConfigBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxConfigBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxConfigBase::ReadLong call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCONFIGBASE_TYPE){
                references = &((wxConfigBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILECONFIG_TYPE) && (!reference_type_found)){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* key0;
    size_t key_len0;
    long defaultVal0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sl' (&key0, &key_len0, &defaultVal0)\n");
        #endif

        char parse_parameters_string[] = "sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key0, &key_len0, &defaultVal0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxConfigBase::ReadLong(wxString(key0, wxConvUTF8), (long) defaultVal0))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_LONG(((wxFileConfig_php*)native_object)->ReadLong(wxString(key0, wxConvUTF8), (long) defaultVal0));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_LONG(((wxConfigBase_php*)native_object)->ReadLong(wxString(key0, wxConvUTF8), (long) defaultVal0));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxConfigBase::ReadLong\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxConfigBase::RenameEntry(string oldName, string newName)
   Renames an entry in the current group. */
bool wxConfigBase_php::RenameEntry(const wxString& oldName, const wxString& newName)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxConfigBase::RenameEntry\n");
    php_printf("===========================================\n");
    #endif

    zval* params[2];
    zval arguments[2];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "RenameEntry");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    ZVAL_STRING(&arguments[0], oldName.ToUTF8().data());
    ZVAL_STRING(&arguments[1], newName.ToUTF8().data());
    
    for(int i=0; i<2; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "RenameEntry");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "RenameEntry",
            11,
            &function_return_value,
            2,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<2; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxConfigBase::RenameEntry'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return Z_TYPE(function_return_value) == IS_TRUE;

}
/* }}} */

/* {{{ proto bool wxConfigBase::RenameGroup(string oldName, string newName)
   Renames a subgroup of the current group. */
bool wxConfigBase_php::RenameGroup(const wxString& oldName, const wxString& newName)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxConfigBase::RenameGroup\n");
    php_printf("===========================================\n");
    #endif

    zval* params[2];
    zval arguments[2];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "RenameGroup");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    ZVAL_STRING(&arguments[0], oldName.ToUTF8().data());
    ZVAL_STRING(&arguments[1], newName.ToUTF8().data());
    
    for(int i=0; i<2; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "RenameGroup");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "RenameGroup",
            11,
            &function_return_value,
            2,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<2; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxConfigBase::RenameGroup'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return Z_TYPE(function_return_value) == IS_TRUE;

}
/* }}} */

/* {{{ proto wxConfigBase wxConfigBase::Set(wxConfigBase &pConfig)
   Sets the config object as the current one, returns the pointer to the previous current object (both the parameter and returned value may be NULL). */
PHP_METHOD(php_wxConfigBase, Set)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxConfigBase::Set\n");
    php_printf("===========================================\n");
    #endif

    zo_wxConfigBase* current_object;
    wxphp_object_type current_object_type;
    wxConfigBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxConfigBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxConfigBase::Set call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCONFIGBASE_TYPE){
                references = &((wxConfigBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILECONFIG_TYPE) && (!reference_type_found)){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* pConfig0;
    wxConfigBase* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&pConfig0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pConfig0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(pConfig0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxConfigBase_P(pConfig0)->object_type;
                    argument_native_object = (void*) Z_wxConfigBase_P(pConfig0)->native_object;
                    object_pointer0_0 = (wxConfigBase*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXCONFIGBASE_TYPE && argument_type != PHP_WXFILECONFIG_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'pConfig' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(pConfig0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'pConfig' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxConfigBase::Set((wxConfigBase*) object_pointer0_0) to return object pointer\n\n");
                #endif

                wxConfigBase_php* value_to_return1;
                value_to_return1 = (wxConfigBase_php*) wxConfigBase::Set((wxConfigBase*) object_pointer0_0);
                if(value_to_return1 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return1->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return1->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return1->phpObj);
                        zval_add_ref(&value_to_return1->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxConfigBase_entry);
                    Z_wxConfigBase_P(return_value)->native_object = (wxConfigBase_php*) value_to_return1;
                }



                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxConfigBase::Set\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxConfigBase::SetExpandEnvVars(bool bDoIt)
   Determine whether we wish to expand environment variables in key values. */
PHP_METHOD(php_wxConfigBase, SetExpandEnvVars)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxConfigBase::SetExpandEnvVars\n");
    php_printf("===========================================\n");
    #endif

    zo_wxConfigBase* current_object;
    wxphp_object_type current_object_type;
    wxConfigBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxConfigBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxConfigBase::SetExpandEnvVars call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCONFIGBASE_TYPE){
                references = &((wxConfigBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILECONFIG_TYPE) && (!reference_type_found)){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool bDoIt0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|b' (&bDoIt0)\n");
        #endif

        char parse_parameters_string[] = "|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bDoIt0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxConfigBase::SetExpandEnvVars()\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    ((wxFileConfig_php*)native_object)->SetExpandEnvVars();
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    ((wxConfigBase_php*)native_object)->SetExpandEnvVars();
                }


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxConfigBase::SetExpandEnvVars(bDoIt0)\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    ((wxFileConfig_php*)native_object)->SetExpandEnvVars(bDoIt0);
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    ((wxConfigBase_php*)native_object)->SetExpandEnvVars(bDoIt0);
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxConfigBase::SetExpandEnvVars\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxConfigBase::SetPath(string strPath)
   Set current path: if the first character is '/', it is the absolute path, otherwise it is a relative path. */
void wxConfigBase_php::SetPath(const wxString& strPath)
{
    static zend_function* cached_function = NULL;
    static bool is_php_user_space_implemented = true;

    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking virtual wxConfigBase::SetPath\n");
    php_printf("===========================================\n");
    #endif

    zval* params[1];
    zval arguments[1];

    zval function_return_value;
    zval function_name;
    ZVAL_STRING(&function_name, "SetPath");
    char* temp_string;
    void* return_object;
    int function_called;

    //Parameters for conversion
    ZVAL_STRING(&arguments[0], strPath.ToUTF8().data());
    
    for(int i=0; i<1; i++)
    {
        params[i] = &arguments[i];
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Trying to call user defined method '%s'", "SetPath");

    if (this->phpObj.value.obj->ce == NULL) {
    php_printf(" on NULL!\n");
    } else {
    php_printf(" on %s\n", ZSTR_VAL(this->phpObj.value.obj->ce->name));
    }
    #endif

    if(is_php_user_space_implemented)
    {
        function_called = wxphp_call_method(
            (zval*)&this->phpObj,
            NULL,
            &cached_function,
            "SetPath",
            7,
            &function_return_value,
            1,
            params
        );
    }
    else
    {
        function_called = FAILURE;
    }

    
    //Delete already used parameters from memory
    for(int i=0; i<1; i++)
    {
        zval_ptr_dtor(&arguments[i]);
    }

    if(function_called == FAILURE)
    {
        is_php_user_space_implemented = false;

        #ifdef USE_WXPHP_DEBUG
        php_printf("Invocation of user defined method failed\n");
        #endif

        wxMessageBox(
            "Failed to call virtual method "
                "'wxConfigBase::SetPath'!",
            "Error",
            wxOK|wxICON_ERROR
        );
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf("Returning userspace value.\n");
    #endif

    return;

}
/* }}} */

/* {{{ proto  wxConfigBase::SetRecordDefaults(bool bDoIt)
   Sets whether defaults are recorded to the config file whenever an attempt to read the value which is not present in it is done. */
PHP_METHOD(php_wxConfigBase, SetRecordDefaults)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxConfigBase::SetRecordDefaults\n");
    php_printf("===========================================\n");
    #endif

    zo_wxConfigBase* current_object;
    wxphp_object_type current_object_type;
    wxConfigBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxConfigBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxConfigBase::SetRecordDefaults call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCONFIGBASE_TYPE){
                references = &((wxConfigBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILECONFIG_TYPE) && (!reference_type_found)){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool bDoIt0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|b' (&bDoIt0)\n");
        #endif

        char parse_parameters_string[] = "|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bDoIt0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxConfigBase::SetRecordDefaults()\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    ((wxFileConfig_php*)native_object)->SetRecordDefaults();
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    ((wxConfigBase_php*)native_object)->SetRecordDefaults();
                }


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxConfigBase::SetRecordDefaults(bDoIt0)\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    ((wxFileConfig_php*)native_object)->SetRecordDefaults(bDoIt0);
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    ((wxConfigBase_php*)native_object)->SetRecordDefaults(bDoIt0);
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxConfigBase::SetRecordDefaults\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxConfigBase::Write(string key, string value)
   Writes the wxString value to the config file and returns true on success. */
PHP_METHOD(php_wxConfigBase, Write)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxConfigBase::Write\n");
    php_printf("===========================================\n");
    #endif

    zo_wxConfigBase* current_object;
    wxphp_object_type current_object_type;
    wxConfigBase_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxConfigBase_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxConfigBase::Write call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXCONFIGBASE_TYPE){
                references = &((wxConfigBase_php*)native_object)->references;
                reference_type_found = true;
            }
            if((current_object_type == PHP_WXFILECONFIG_TYPE) && (!reference_type_found)){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* key0;
    size_t key_len0;
    char* value0;
    size_t value_len0;
    bool overload0_called = false;

    //Parameters for overload 1
    char* key1;
    size_t key_len1;
    long value1;
    bool overload1_called = false;

    //Parameters for overload 2
    char* key2;
    size_t key_len2;
    double value2;
    bool overload2_called = false;

    //Parameters for overload 3
    char* key3;
    size_t key_len3;
    bool value3;
    bool overload3_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ss' (&key0, &key_len0, &value0, &value_len0)\n");
        #endif

        char parse_parameters_string[] = "ss";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key0, &key_len0, &value0, &value_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sl' (&key1, &key_len1, &value1)\n");
        #endif

        char parse_parameters_string[] = "sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key1, &key_len1, &value1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sd' (&key2, &key_len2, &value2)\n");
        #endif

        char parse_parameters_string[] = "sd";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key2, &key_len2, &value2 ) == SUCCESS)
        {
            overload2_called = true;
            already_called = true;
        }
    }

    //Overload 3
    overload3:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sb' (&key3, &key_len3, &value3)\n");
        #endif

        char parse_parameters_string[] = "sb";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key3, &key_len3, &value3 ) == SUCCESS)
        {
            overload3_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxConfigBase::Write(wxString(key0, wxConvUTF8), wxString(value0, wxConvUTF8)))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->Write(wxString(key0, wxConvUTF8), wxString(value0, wxConvUTF8)));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxConfigBase_php*)native_object)->Write(wxString(key0, wxConvUTF8), wxString(value0, wxConvUTF8)));
                }


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxConfigBase::Write(wxString(key1, wxConvUTF8), (long) value1))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->Write(wxString(key1, wxConvUTF8), (long) value1));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxConfigBase_php*)native_object)->Write(wxString(key1, wxConvUTF8), (long) value1));
                }


                return;
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxConfigBase::Write(wxString(key2, wxConvUTF8), value2))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->Write(wxString(key2, wxConvUTF8), value2));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxConfigBase_php*)native_object)->Write(wxString(key2, wxConvUTF8), value2));
                }


                return;
                break;
            }
        }
    }

    if(overload3_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxConfigBase::Write(wxString(key3, wxConvUTF8), value3))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->Write(wxString(key3, wxConvUTF8), value3));
                }
                else if(current_object_type == PHP_WXCONFIGBASE_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxConfigBase_php*)native_object)->Write(wxString(key3, wxConvUTF8), value3));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxConfigBase::Write\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxDisplay_free(zend_object *object)
{
    zo_wxDisplay* custom_object = php_wxDisplay_fetch_object(object);

    if (custom_object->is_user_initialized && (custom_object->native_object != NULL)) {
        custom_object->native_object->zo = NULL;
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxDisplay_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxDisplay done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
}

wxDisplay_php::~wxDisplay_php()
{
    if (zo) {
        zo->native_object = NULL;
    }
}

zend_object* php_wxDisplay_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxDisplay_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxDisplay* custom_object;

    custom_object = (zo_wxDisplay*) ecalloc(
        1,
        sizeof(zo_wxDisplay)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    memcpy(&wxphp_wxDisplay_object_handlers, zend_get_std_object_handlers(), sizeof wxphp_wxDisplay_object_handlers);
    wxphp_wxDisplay_object_handlers.offset = XtOffsetOf(zo_wxDisplay, zo);
    wxphp_wxDisplay_object_handlers.free_obj = php_wxDisplay_free;
    custom_object->zo.handlers = &wxphp_wxDisplay_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXDISPLAY_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto bool wxDisplay::ChangeMode(wxVideoMode mode)
   Changes the video mode of this display to the mode specified in the mode parameter. */
PHP_METHOD(php_wxDisplay, ChangeMode)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDisplay::ChangeMode\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDisplay* current_object;
    wxphp_object_type current_object_type;
    wxDisplay_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxDisplay_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxDisplay::ChangeMode call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXDISPLAY_TYPE){
                references = &((wxDisplay_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* mode0;
    wxVideoMode* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|O' (&mode0, php_wxVideoMode_entry)\n");
        #endif

        char parse_parameters_string[] = "|O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &mode0, php_wxVideoMode_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(mode0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxVideoMode_P(mode0)->object_type;
                    argument_native_object = (void*) Z_wxVideoMode_P(mode0)->native_object;
                    object_pointer0_0 = (wxVideoMode*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'mode' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(mode0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'mode' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxDisplay::ChangeMode())\n\n");
                #endif

                WXPHP_RETVAL_BOOL(((wxDisplay_php*)native_object)->ChangeMode());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxDisplay::ChangeMode(*(wxVideoMode*) object_pointer0_0))\n\n");
                #endif

                WXPHP_RETVAL_BOOL(((wxDisplay_php*)native_object)->ChangeMode(*(wxVideoMode*) object_pointer0_0));

                references->AddReference(mode0, "wxDisplay::ChangeMode at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxDisplay::ChangeMode\n"
        );
    }
}
/* }}} */

/* {{{ proto wxRect wxDisplay::GetClientArea()
   Returns the client area of the display. */
PHP_METHOD(php_wxDisplay, GetClientArea)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDisplay::GetClientArea\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDisplay* current_object;
    wxphp_object_type current_object_type;
    wxDisplay_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxDisplay_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxDisplay::GetClientArea call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXDISPLAY_TYPE){
                references = &((wxDisplay_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxDisplay::GetClientArea() to return new object\n\n");
                #endif

                wxRect value_to_return0;
                value_to_return0 = ((wxDisplay_php*)native_object)->GetClientArea();
                void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxRect));
                object_init_ex(return_value, php_wxRect_entry);
                ((wxRect_php*)ptr)->phpObj = *return_value;
                zo_wxRect* zo0 = Z_wxRect_P(return_value);
                zo0->native_object = (wxRect_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxDisplay::GetClientArea\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxDisplay::GetCount()
   Returns the number of connected displays. */
PHP_METHOD(php_wxDisplay, GetCount)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDisplay::GetCount\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDisplay* current_object;
    wxphp_object_type current_object_type;
    wxDisplay_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxDisplay_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxDisplay::GetCount call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXDISPLAY_TYPE){
                references = &((wxDisplay_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_LONG(wxDisplay::GetCount())\n\n");
                #endif

                WXPHP_RETVAL_LONG(wxDisplay::GetCount());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxDisplay::GetCount\n"
        );
    }
}
/* }}} */

/* {{{ proto wxVideoMode wxDisplay::GetCurrentMode()
   Returns the current video mode that this display is in. */
PHP_METHOD(php_wxDisplay, GetCurrentMode)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDisplay::GetCurrentMode\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDisplay* current_object;
    wxphp_object_type current_object_type;
    wxDisplay_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxDisplay_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxDisplay::GetCurrentMode call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXDISPLAY_TYPE){
                references = &((wxDisplay_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxDisplay::GetCurrentMode() to return new object\n\n");
                #endif

                wxVideoMode value_to_return0;
                value_to_return0 = ((wxDisplay_php*)native_object)->GetCurrentMode();
                void* ptr = safe_emalloc(1, sizeof(wxVideoMode_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxVideoMode));
                object_init_ex(return_value, php_wxVideoMode_entry);
                ((wxVideoMode_php*)ptr)->phpObj = *return_value;
                zo_wxVideoMode* zo0 = Z_wxVideoMode_P(return_value);
                zo0->native_object = (wxVideoMode_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxDisplay::GetCurrentMode\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxDisplay::GetFromPoint(wxPoint pt)
   Returns the index of the display on which the given point lies, or wxNOT_FOUND if the point is not on any connected display. */
PHP_METHOD(php_wxDisplay, GetFromPoint)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDisplay::GetFromPoint\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDisplay* current_object;
    wxphp_object_type current_object_type;
    wxDisplay_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxDisplay_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxDisplay::GetFromPoint call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXDISPLAY_TYPE){
                references = &((wxDisplay_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* pt0;
    wxPoint* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&pt0, php_wxPoint_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pt0, php_wxPoint_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(pt0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxPoint_P(pt0)->object_type;
                    argument_native_object = (void*) Z_wxPoint_P(pt0)->native_object;
                    object_pointer0_0 = (wxPoint*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'pt' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(pt0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'pt' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_LONG(wxDisplay::GetFromPoint(*(wxPoint*) object_pointer0_0))\n\n");
                #endif

                WXPHP_RETVAL_LONG(wxDisplay::GetFromPoint(*(wxPoint*) object_pointer0_0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxDisplay::GetFromPoint\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxDisplay::GetFromWindow(wxWindow win)
   Returns the index of the display on which the given window lies. */
PHP_METHOD(php_wxDisplay, GetFromWindow)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDisplay::GetFromWindow\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDisplay* current_object;
    wxphp_object_type current_object_type;
    wxDisplay_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxDisplay_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxDisplay::GetFromWindow call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXDISPLAY_TYPE){
                references = &((wxDisplay_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* win0;
    wxWindow* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&win0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &win0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(win0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxWindow_P(win0)->object_type;
                    argument_native_object = (void*) Z_wxWindow_P(win0)->native_object;
                    object_pointer0_0 = (wxWindow*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'win' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(win0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'win' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_LONG(wxDisplay::GetFromWindow((const wxWindow*) object_pointer0_0))\n\n");
                #endif

                WXPHP_RETVAL_LONG(wxDisplay::GetFromWindow((const wxWindow*) object_pointer0_0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxDisplay::GetFromWindow\n"
        );
    }
}
/* }}} */

/* {{{ proto wxRect wxDisplay::GetGeometry()
   Returns the bounding rectangle of the display whose index was passed to the constructor. */
PHP_METHOD(php_wxDisplay, GetGeometry)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDisplay::GetGeometry\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDisplay* current_object;
    wxphp_object_type current_object_type;
    wxDisplay_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxDisplay_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxDisplay::GetGeometry call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXDISPLAY_TYPE){
                references = &((wxDisplay_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxDisplay::GetGeometry() to return new object\n\n");
                #endif

                wxRect value_to_return0;
                value_to_return0 = ((wxDisplay_php*)native_object)->GetGeometry();
                void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
                memcpy(ptr, (void*) &value_to_return0, sizeof(wxRect));
                object_init_ex(return_value, php_wxRect_entry);
                ((wxRect_php*)ptr)->phpObj = *return_value;
                zo_wxRect* zo0 = Z_wxRect_P(return_value);
                zo0->native_object = (wxRect_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxDisplay::GetGeometry\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxDisplay::GetName()
   Returns the display's name. */
PHP_METHOD(php_wxDisplay, GetName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDisplay::GetName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDisplay* current_object;
    wxphp_object_type current_object_type;
    wxDisplay_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxDisplay_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxDisplay::GetName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXDISPLAY_TYPE){
                references = &((wxDisplay_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxDisplay::GetName().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxDisplay_php*)native_object)->GetName();
                WXPHP_RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxDisplay::GetName\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxDisplay::IsPrimary()
   Returns true if the display is the primary display. */
PHP_METHOD(php_wxDisplay, IsPrimary)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDisplay::IsPrimary\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDisplay* current_object;
    wxphp_object_type current_object_type;
    wxDisplay_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxDisplay_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxDisplay::IsPrimary call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXDISPLAY_TYPE){
                references = &((wxDisplay_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxDisplay::IsPrimary())\n\n");
                #endif

                WXPHP_RETVAL_BOOL(((wxDisplay_php*)native_object)->IsPrimary());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxDisplay::IsPrimary\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxDisplay::wxDisplay()
   Default constructor creating wxDisplay object representing the primary display. */
PHP_METHOD(php_wxDisplay, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxDisplay::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxDisplay* current_object;
    wxDisplay_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    long index1;
    bool overload1_called = false;

    //Parameters for overload 2
    zval* window2;
    wxWindow* object_pointer2_0 = 0;
    bool overload2_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&index1)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &index1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&window2)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &window2 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(window2) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxWindow_P(window2)->object_type;
                    argument_native_object = (void*) Z_wxWindow_P(window2)->native_object;
                    object_pointer2_0 = (wxWindow*) argument_native_object;
                    if (!object_pointer2_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'window' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(window2) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'window' not null, could not be retreived correctly.");
                }
            }

            overload2_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxDisplay_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((unsigned int) index1)\n");
                #endif

                native_object = new wxDisplay_php((unsigned int) index1);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((const wxWindow*) object_pointer2_0)\n");
                #endif

                native_object = new wxDisplay_php((const wxWindow*) object_pointer2_0);

                native_object->references.Initialize();
                ((wxDisplay_php*) native_object)->references.AddReference(window2, "wxDisplay::wxDisplay at call 2 with 1 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxDisplay_P(getThis());

        current_object->native_object = native_object;
        native_object->zo = current_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxDisplay::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFileConfig_free(zend_object *object)
{
    zo_wxFileConfig* custom_object = php_wxFileConfig_fetch_object(object);

    if (custom_object->is_user_initialized && (custom_object->native_object != NULL)) {
        custom_object->native_object->zo = NULL;
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFileConfig_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxFileConfig done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
}

wxFileConfig_php::~wxFileConfig_php()
{
    if (zo) {
        zo->native_object = NULL;
    }
}

zend_object* php_wxFileConfig_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFileConfig_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* custom_object;

    custom_object = (zo_wxFileConfig*) ecalloc(
        1,
        sizeof(zo_wxFileConfig)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    memcpy(&wxphp_wxFileConfig_object_handlers, zend_get_std_object_handlers(), sizeof wxphp_wxFileConfig_object_handlers);
    wxphp_wxFileConfig_object_handlers.offset = XtOffsetOf(zo_wxFileConfig, zo);
    wxphp_wxFileConfig_object_handlers.free_obj = php_wxFileConfig_free;
    custom_object->zo.handlers = &wxphp_wxFileConfig_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFILECONFIG_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto bool wxFileConfig::DeleteAll()
   Delete the whole underlying object (disk file, registry key, ...). */
PHP_METHOD(php_wxFileConfig, DeleteAll)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileConfig::DeleteAll\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* current_object;
    wxphp_object_type current_object_type;
    wxFileConfig_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileConfig_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileConfig::DeleteAll call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILECONFIG_TYPE){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileConfig::DeleteAll())\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->DeleteAll());
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileConfig::DeleteAll\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileConfig::DeleteEntry(string key, bool bDeleteGroupIfEmpty)
   Deletes the specified entry and the group it belongs to if it was the last key in it and the second parameter is true. */
PHP_METHOD(php_wxFileConfig, DeleteEntry)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileConfig::DeleteEntry\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* current_object;
    wxphp_object_type current_object_type;
    wxFileConfig_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileConfig_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileConfig::DeleteEntry call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILECONFIG_TYPE){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* key0;
    size_t key_len0;
    bool bDeleteGroupIfEmpty0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|b' (&key0, &key_len0, &bDeleteGroupIfEmpty0)\n");
        #endif

        char parse_parameters_string[] = "s|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key0, &key_len0, &bDeleteGroupIfEmpty0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileConfig::DeleteEntry(wxString(key0, wxConvUTF8)))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->DeleteEntry(wxString(key0, wxConvUTF8)));
                }


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileConfig::DeleteEntry(wxString(key0, wxConvUTF8), bDeleteGroupIfEmpty0))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->DeleteEntry(wxString(key0, wxConvUTF8), bDeleteGroupIfEmpty0));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileConfig::DeleteEntry\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileConfig::DeleteGroup(string key)
   Delete the group (with all subgroups). */
PHP_METHOD(php_wxFileConfig, DeleteGroup)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileConfig::DeleteGroup\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* current_object;
    wxphp_object_type current_object_type;
    wxFileConfig_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileConfig_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileConfig::DeleteGroup call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILECONFIG_TYPE){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* key0;
    size_t key_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&key0, &key_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &key0, &key_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileConfig::DeleteGroup(wxString(key0, wxConvUTF8)))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->DeleteGroup(wxString(key0, wxConvUTF8)));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileConfig::DeleteGroup\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileConfig::Flush(bool bCurrentOnly)
   Permanently writes all changes (otherwise, they're only written from object's destructor). */
PHP_METHOD(php_wxFileConfig, Flush)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileConfig::Flush\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* current_object;
    wxphp_object_type current_object_type;
    wxFileConfig_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileConfig_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileConfig::Flush call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILECONFIG_TYPE){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool bCurrentOnly0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|b' (&bCurrentOnly0)\n");
        #endif

        char parse_parameters_string[] = "|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bCurrentOnly0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileConfig::Flush())\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->Flush());
                }


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileConfig::Flush(bCurrentOnly0))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->Flush(bCurrentOnly0));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileConfig::Flush\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileConfig::GetFirstEntry(string &str, int &index)
   Gets the first entry. */
PHP_METHOD(php_wxFileConfig, GetFirstEntry)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileConfig::GetFirstEntry\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* current_object;
    wxphp_object_type current_object_type;
    wxFileConfig_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileConfig_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileConfig::GetFirstEntry call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILECONFIG_TYPE){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* str0;
    size_t str_len0;
    zval str0_ref;
    long index0;
    zval index0_ref;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sl' (&str0, &str_len0, &index0)\n");
        #endif

        char parse_parameters_string[] = "sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &str0, &str_len0, &index0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;

            char parse_references_string[] = "zz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, str0_ref, index0_ref );
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                wxString string_arg0_0 = wxString(str0, wxConvUTF8);
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileConfig::GetFirstEntry(string_arg0_0, (long&) index0))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->GetFirstEntry(string_arg0_0, (long&) index0));
                }

                ZVAL_STRING(&str0_ref, string_arg0_0.ToUTF8().data());
                ZVAL_LONG(&index0_ref, index0);

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileConfig::GetFirstEntry\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileConfig::GetFirstGroup(string &str, int &index)
   Gets the first group. */
PHP_METHOD(php_wxFileConfig, GetFirstGroup)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileConfig::GetFirstGroup\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* current_object;
    wxphp_object_type current_object_type;
    wxFileConfig_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileConfig_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileConfig::GetFirstGroup call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILECONFIG_TYPE){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* str0;
    size_t str_len0;
    zval str0_ref;
    long index0;
    zval index0_ref;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sl' (&str0, &str_len0, &index0)\n");
        #endif

        char parse_parameters_string[] = "sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &str0, &str_len0, &index0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;

            char parse_references_string[] = "zz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, str0_ref, index0_ref );
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                wxString string_arg0_0 = wxString(str0, wxConvUTF8);
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileConfig::GetFirstGroup(string_arg0_0, (long&) index0))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->GetFirstGroup(string_arg0_0, (long&) index0));
                }

                ZVAL_STRING(&str0_ref, string_arg0_0.ToUTF8().data());
                ZVAL_LONG(&index0_ref, index0);

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileConfig::GetFirstGroup\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFileName wxFileConfig::GetGlobalFile(string basename)
   Return the full path to the file which would be used by wxFileConfig as global, system-wide, file if it were constructed with basename as "global filename" parameter in the constructor. */
PHP_METHOD(php_wxFileConfig, GetGlobalFile)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileConfig::GetGlobalFile\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* current_object;
    wxphp_object_type current_object_type;
    wxFileConfig_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileConfig_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileConfig::GetGlobalFile call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILECONFIG_TYPE){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* basename0;
    size_t basename_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&basename0, &basename_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &basename0, &basename_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFileConfig::GetGlobalFile(wxString(basename0, wxConvUTF8)) to return new object\n\n");
                #endif

                wxFileName value_to_return1;
                value_to_return1 = wxFileConfig::GetGlobalFile(wxString(basename0, wxConvUTF8));
                void* ptr = safe_emalloc(1, sizeof(wxFileName_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxFileName));
                object_init_ex(return_value, php_wxFileName_entry);
                ((wxFileName_php*)ptr)->phpObj = *return_value;
                zo_wxFileName* zo1 = Z_wxFileName_P(return_value);
                zo1->native_object = (wxFileName_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileConfig::GetGlobalFile\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileConfig::GetGlobalFileName(string szFile) */
PHP_METHOD(php_wxFileConfig, GetGlobalFileName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileConfig::GetGlobalFileName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* current_object;
    wxphp_object_type current_object_type;
    wxFileConfig_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileConfig_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileConfig::GetGlobalFileName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILECONFIG_TYPE){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* szFile0;
    size_t szFile_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&szFile0, &szFile_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &szFile0, &szFile_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileConfig::GetGlobalFileName(wxString(szFile0, wxConvUTF8)).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = wxFileConfig::GetGlobalFileName(wxString(szFile0, wxConvUTF8));
                WXPHP_RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileConfig::GetGlobalFileName\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFileName wxFileConfig::GetLocalFile(string basename, int style)
   Return the full path to the file which would be used by wxFileConfig as local, user-specific, file if it were constructed with basename as "local filename" parameter in the constructor. */
PHP_METHOD(php_wxFileConfig, GetLocalFile)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileConfig::GetLocalFile\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* current_object;
    wxphp_object_type current_object_type;
    wxFileConfig_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileConfig_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileConfig::GetLocalFile call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILECONFIG_TYPE){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* basename0;
    size_t basename_len0;
    long style0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|l' (&basename0, &basename_len0, &style0)\n");
        #endif

        char parse_parameters_string[] = "s|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &basename0, &basename_len0, &style0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFileConfig::GetLocalFile(wxString(basename0, wxConvUTF8)) to return new object\n\n");
                #endif

                wxFileName value_to_return1;
                value_to_return1 = wxFileConfig::GetLocalFile(wxString(basename0, wxConvUTF8));
                void* ptr = safe_emalloc(1, sizeof(wxFileName_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxFileName));
                object_init_ex(return_value, php_wxFileName_entry);
                ((wxFileName_php*)ptr)->phpObj = *return_value;
                zo_wxFileName* zo1 = Z_wxFileName_P(return_value);
                zo1->native_object = (wxFileName_php*) ptr;


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFileConfig::GetLocalFile(wxString(basename0, wxConvUTF8), (int) style0) to return new object\n\n");
                #endif

                wxFileName value_to_return2;
                value_to_return2 = wxFileConfig::GetLocalFile(wxString(basename0, wxConvUTF8), (int) style0);
                void* ptr = safe_emalloc(1, sizeof(wxFileName_php), 0);
                memcpy(ptr, (void*) &value_to_return2, sizeof(wxFileName));
                object_init_ex(return_value, php_wxFileName_entry);
                ((wxFileName_php*)ptr)->phpObj = *return_value;
                zo_wxFileName* zo2 = Z_wxFileName_P(return_value);
                zo2->native_object = (wxFileName_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileConfig::GetLocalFile\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileConfig::GetLocalFileName(string szFile, int style) */
PHP_METHOD(php_wxFileConfig, GetLocalFileName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileConfig::GetLocalFileName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* current_object;
    wxphp_object_type current_object_type;
    wxFileConfig_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileConfig_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileConfig::GetLocalFileName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILECONFIG_TYPE){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* szFile0;
    size_t szFile_len0;
    long style0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|l' (&szFile0, &szFile_len0, &style0)\n");
        #endif

        char parse_parameters_string[] = "s|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &szFile0, &szFile_len0, &style0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileConfig::GetLocalFileName(wxString(szFile0, wxConvUTF8)).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = wxFileConfig::GetLocalFileName(wxString(szFile0, wxConvUTF8));
                WXPHP_RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileConfig::GetLocalFileName(wxString(szFile0, wxConvUTF8), (int) style0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return2;
                value_to_return2 = wxFileConfig::GetLocalFileName(wxString(szFile0, wxConvUTF8), (int) style0);
                WXPHP_RETVAL_STRING(value_to_return2.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileConfig::GetLocalFileName\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileConfig::GetNextEntry(string &str, int &index)
   Gets the next entry. */
PHP_METHOD(php_wxFileConfig, GetNextEntry)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileConfig::GetNextEntry\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* current_object;
    wxphp_object_type current_object_type;
    wxFileConfig_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileConfig_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileConfig::GetNextEntry call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILECONFIG_TYPE){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* str0;
    size_t str_len0;
    zval str0_ref;
    long index0;
    zval index0_ref;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sl' (&str0, &str_len0, &index0)\n");
        #endif

        char parse_parameters_string[] = "sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &str0, &str_len0, &index0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;

            char parse_references_string[] = "zz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, str0_ref, index0_ref );
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                wxString string_arg0_0 = wxString(str0, wxConvUTF8);
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileConfig::GetNextEntry(string_arg0_0, (long&) index0))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->GetNextEntry(string_arg0_0, (long&) index0));
                }

                ZVAL_STRING(&str0_ref, string_arg0_0.ToUTF8().data());
                ZVAL_LONG(&index0_ref, index0);

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileConfig::GetNextEntry\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileConfig::GetNextGroup(string &str, int &index)
   Gets the next group. */
PHP_METHOD(php_wxFileConfig, GetNextGroup)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileConfig::GetNextGroup\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* current_object;
    wxphp_object_type current_object_type;
    wxFileConfig_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileConfig_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileConfig::GetNextGroup call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILECONFIG_TYPE){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* str0;
    size_t str_len0;
    zval str0_ref;
    long index0;
    zval index0_ref;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sl' (&str0, &str_len0, &index0)\n");
        #endif

        char parse_parameters_string[] = "sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &str0, &str_len0, &index0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;

            char parse_references_string[] = "zz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, str0_ref, index0_ref );
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                wxString string_arg0_0 = wxString(str0, wxConvUTF8);
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileConfig::GetNextGroup(string_arg0_0, (long&) index0))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->GetNextGroup(string_arg0_0, (long&) index0));
                }

                ZVAL_STRING(&str0_ref, string_arg0_0.ToUTF8().data());
                ZVAL_LONG(&index0_ref, index0);

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileConfig::GetNextGroup\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxFileConfig::GetNumberOfEntries(bool bRecursive)
   Get number of entries in the current group. */
PHP_METHOD(php_wxFileConfig, GetNumberOfEntries)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileConfig::GetNumberOfEntries\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* current_object;
    wxphp_object_type current_object_type;
    wxFileConfig_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileConfig_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileConfig::GetNumberOfEntries call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILECONFIG_TYPE){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool bRecursive0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|b' (&bRecursive0)\n");
        #endif

        char parse_parameters_string[] = "|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bRecursive0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFileConfig::GetNumberOfEntries())\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_LONG(((wxFileConfig_php*)native_object)->GetNumberOfEntries());
                }


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFileConfig::GetNumberOfEntries(bRecursive0))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_LONG(((wxFileConfig_php*)native_object)->GetNumberOfEntries(bRecursive0));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileConfig::GetNumberOfEntries\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxFileConfig::GetNumberOfGroups(bool bRecursive)
   Get number of entries/subgroups in the current group, with or without its subgroups. */
PHP_METHOD(php_wxFileConfig, GetNumberOfGroups)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileConfig::GetNumberOfGroups\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* current_object;
    wxphp_object_type current_object_type;
    wxFileConfig_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileConfig_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileConfig::GetNumberOfGroups call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILECONFIG_TYPE){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool bRecursive0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|b' (&bRecursive0)\n");
        #endif

        char parse_parameters_string[] = "|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &bRecursive0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFileConfig::GetNumberOfGroups())\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_LONG(((wxFileConfig_php*)native_object)->GetNumberOfGroups());
                }


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFileConfig::GetNumberOfGroups(bRecursive0))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_LONG(((wxFileConfig_php*)native_object)->GetNumberOfGroups(bRecursive0));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileConfig::GetNumberOfGroups\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileConfig::GetPath()
   Retrieve the current path (always as absolute path). */
PHP_METHOD(php_wxFileConfig, GetPath)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileConfig::GetPath\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* current_object;
    wxphp_object_type current_object_type;
    wxFileConfig_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileConfig_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileConfig::GetPath call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILECONFIG_TYPE){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileConfig::GetPath().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    value_to_return0 = ((wxFileConfig_php*)native_object)->GetPath();
                }
                WXPHP_RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileConfig::GetPath\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileConfig::HasEntry(string strName) */
PHP_METHOD(php_wxFileConfig, HasEntry)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileConfig::HasEntry\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* current_object;
    wxphp_object_type current_object_type;
    wxFileConfig_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileConfig_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileConfig::HasEntry call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILECONFIG_TYPE){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* strName0;
    size_t strName_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&strName0, &strName_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &strName0, &strName_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileConfig::HasEntry(wxString(strName0, wxConvUTF8)))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->HasEntry(wxString(strName0, wxConvUTF8)));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileConfig::HasEntry\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileConfig::HasGroup(string strName) */
PHP_METHOD(php_wxFileConfig, HasGroup)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileConfig::HasGroup\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* current_object;
    wxphp_object_type current_object_type;
    wxFileConfig_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileConfig_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileConfig::HasGroup call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILECONFIG_TYPE){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* strName0;
    size_t strName_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&strName0, &strName_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &strName0, &strName_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileConfig::HasGroup(wxString(strName0, wxConvUTF8)))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->HasGroup(wxString(strName0, wxConvUTF8)));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileConfig::HasGroup\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileConfig::RenameEntry(string oldName, string newName)
   Renames an entry in the current group. */
PHP_METHOD(php_wxFileConfig, RenameEntry)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileConfig::RenameEntry\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* current_object;
    wxphp_object_type current_object_type;
    wxFileConfig_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileConfig_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileConfig::RenameEntry call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILECONFIG_TYPE){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* oldName0;
    size_t oldName_len0;
    char* newName0;
    size_t newName_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ss' (&oldName0, &oldName_len0, &newName0, &newName_len0)\n");
        #endif

        char parse_parameters_string[] = "ss";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &oldName0, &oldName_len0, &newName0, &newName_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileConfig::RenameEntry(wxString(oldName0, wxConvUTF8), wxString(newName0, wxConvUTF8)))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->RenameEntry(wxString(oldName0, wxConvUTF8), wxString(newName0, wxConvUTF8)));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileConfig::RenameEntry\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileConfig::RenameGroup(string oldName, string newName)
   Renames a subgroup of the current group. */
PHP_METHOD(php_wxFileConfig, RenameGroup)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileConfig::RenameGroup\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* current_object;
    wxphp_object_type current_object_type;
    wxFileConfig_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileConfig_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileConfig::RenameGroup call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILECONFIG_TYPE){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* oldName0;
    size_t oldName_len0;
    char* newName0;
    size_t newName_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ss' (&oldName0, &oldName_len0, &newName0, &newName_len0)\n");
        #endif

        char parse_parameters_string[] = "ss";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &oldName0, &oldName_len0, &newName0, &newName_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileConfig::RenameGroup(wxString(oldName0, wxConvUTF8), wxString(newName0, wxConvUTF8)))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    WXPHP_RETVAL_BOOL(((wxFileConfig_php*)native_object)->RenameGroup(wxString(oldName0, wxConvUTF8), wxString(newName0, wxConvUTF8)));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileConfig::RenameGroup\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileConfig::SetPath(string strPath)
   Set current path: if the first character is '/', it is the absolute path, otherwise it is a relative path. */
PHP_METHOD(php_wxFileConfig, SetPath)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileConfig::SetPath\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* current_object;
    wxphp_object_type current_object_type;
    wxFileConfig_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileConfig_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileConfig::SetPath call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILECONFIG_TYPE){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* strPath0;
    size_t strPath_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&strPath0, &strPath_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &strPath0, &strPath_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileConfig::SetPath(wxString(strPath0, wxConvUTF8))\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    ((wxFileConfig_php*)native_object)->SetPath(wxString(strPath0, wxConvUTF8));
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileConfig::SetPath\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileConfig::SetUmask(int mode)
   Allows setting the mode to be used for the config file creation. */
PHP_METHOD(php_wxFileConfig, SetUmask)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileConfig::SetUmask\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileConfig* current_object;
    wxphp_object_type current_object_type;
    wxFileConfig_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileConfig_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileConfig::SetUmask call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILECONFIG_TYPE){
                references = &((wxFileConfig_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long mode0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&mode0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &mode0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileConfig::SetUmask((int) mode0)\n\n");
                #endif

                if(current_object_type == PHP_WXFILECONFIG_TYPE)
                {
                    ((wxFileConfig_php*)native_object)->SetUmask((int) mode0);
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileConfig::SetUmask\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFontMapper_free(zend_object *object)
{
    zo_wxFontMapper* custom_object = php_wxFontMapper_fetch_object(object);

    if (custom_object->is_user_initialized && (custom_object->native_object != NULL)) {
        custom_object->native_object->zo = NULL;
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFontMapper_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxFontMapper done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
}

wxFontMapper_php::~wxFontMapper_php()
{
    if (zo) {
        zo->native_object = NULL;
    }
}

zend_object* php_wxFontMapper_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFontMapper_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxFontMapper* custom_object;

    custom_object = (zo_wxFontMapper*) ecalloc(
        1,
        sizeof(zo_wxFontMapper)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    memcpy(&wxphp_wxFontMapper_object_handlers, zend_get_std_object_handlers(), sizeof wxphp_wxFontMapper_object_handlers);
    wxphp_wxFontMapper_object_handlers.offset = XtOffsetOf(zo_wxFontMapper, zo);
    wxphp_wxFontMapper_object_handlers.free_obj = php_wxFontMapper_free;
    custom_object->zo.handlers = &wxphp_wxFontMapper_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFONTMAPPER_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto wxFontEncoding wxFontMapper::CharsetToEncoding(string charset, bool interactive)
   Returns the encoding for the given charset (in the form of RFC 2046) or wxFONTENCODING_SYSTEM if couldn't decode it. */
PHP_METHOD(php_wxFontMapper, CharsetToEncoding)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFontMapper::CharsetToEncoding\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFontMapper* current_object;
    wxphp_object_type current_object_type;
    wxFontMapper_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFontMapper_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFontMapper::CharsetToEncoding call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONTMAPPER_TYPE){
                references = &((wxFontMapper_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* charset0;
    size_t charset_len0;
    bool interactive0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|b' (&charset0, &charset_len0, &interactive0)\n");
        #endif

        char parse_parameters_string[] = "s|b";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &charset0, &charset_len0, &interactive0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFontMapper::CharsetToEncoding(wxString(charset0, wxConvUTF8)))\n\n");
                #endif

                WXPHP_RETVAL_LONG(((wxFontMapper_php*)native_object)->CharsetToEncoding(wxString(charset0, wxConvUTF8)));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFontMapper::CharsetToEncoding(wxString(charset0, wxConvUTF8), interactive0))\n\n");
                #endif

                WXPHP_RETVAL_LONG(((wxFontMapper_php*)native_object)->CharsetToEncoding(wxString(charset0, wxConvUTF8), interactive0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFontMapper::CharsetToEncoding\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFontMapper wxFontMapper::Get()
   Get the current font mapper object. */
PHP_METHOD(php_wxFontMapper, Get)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFontMapper::Get\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFontMapper* current_object;
    wxphp_object_type current_object_type;
    wxFontMapper_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFontMapper_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFontMapper::Get call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONTMAPPER_TYPE){
                references = &((wxFontMapper_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFontMapper::Get() to return object pointer\n\n");
                #endif

                wxFontMapper_php* value_to_return0;
                value_to_return0 = (wxFontMapper_php*) wxFontMapper::Get();
                if(value_to_return0 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFontMapper_entry);
                    Z_wxFontMapper_P(return_value)->native_object = (wxFontMapper_php*) value_to_return0;
                }



                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFontMapper::Get\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFontMapper::GetAltForEncoding(wxFontEncoding encoding, wxFontEncoding &alt_encoding, string facename, bool interactive)
   Find an alternative for the given encoding (which is supposed to not be available on this system). */
PHP_METHOD(php_wxFontMapper, GetAltForEncoding)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFontMapper::GetAltForEncoding\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFontMapper* current_object;
    wxphp_object_type current_object_type;
    wxFontMapper_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFontMapper_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFontMapper::GetAltForEncoding call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONTMAPPER_TYPE){
                references = &((wxFontMapper_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long encoding0;
    long* alt_encoding0;
    zval alt_encoding0_ref;
    char* facename0;
    size_t facename_len0;
    bool interactive0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 2  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll|sb' (&encoding0, alt_encoding0, &facename0, &facename_len0, &interactive0)\n");
        #endif

        char parse_parameters_string[] = "ll|sb";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &encoding0, alt_encoding0, &facename0, &facename_len0, &interactive0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;

            char parse_references_string[] = "zz|zz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, alt_encoding0_ref, dummy, dummy );
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFontMapper::GetAltForEncoding((wxFontEncoding) encoding0, (wxFontEncoding*) alt_encoding0))\n\n");
                #endif

                WXPHP_RETVAL_BOOL(((wxFontMapper_php*)native_object)->GetAltForEncoding((wxFontEncoding) encoding0, (wxFontEncoding*) alt_encoding0));

                size_t elements_returned0_1 = sizeof(alt_encoding0)/sizeof(*alt_encoding0);
                array_init(&alt_encoding0_ref);
                for(size_t i=0; i<elements_returned0_1; i++)
                {
                    add_next_index_long(&alt_encoding0_ref, alt_encoding0[i]);
                }

                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFontMapper::GetAltForEncoding((wxFontEncoding) encoding0, (wxFontEncoding*) alt_encoding0, wxString(facename0, wxConvUTF8)))\n\n");
                #endif

                WXPHP_RETVAL_BOOL(((wxFontMapper_php*)native_object)->GetAltForEncoding((wxFontEncoding) encoding0, (wxFontEncoding*) alt_encoding0, wxString(facename0, wxConvUTF8)));

                size_t elements_returned0_1 = sizeof(alt_encoding0)/sizeof(*alt_encoding0);
                array_init(&alt_encoding0_ref);
                for(size_t i=0; i<elements_returned0_1; i++)
                {
                    add_next_index_long(&alt_encoding0_ref, alt_encoding0[i]);
                }

                return;
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFontMapper::GetAltForEncoding((wxFontEncoding) encoding0, (wxFontEncoding*) alt_encoding0, wxString(facename0, wxConvUTF8), interactive0))\n\n");
                #endif

                WXPHP_RETVAL_BOOL(((wxFontMapper_php*)native_object)->GetAltForEncoding((wxFontEncoding) encoding0, (wxFontEncoding*) alt_encoding0, wxString(facename0, wxConvUTF8), interactive0));

                size_t elements_returned0_1 = sizeof(alt_encoding0)/sizeof(*alt_encoding0);
                array_init(&alt_encoding0_ref);
                for(size_t i=0; i<elements_returned0_1; i++)
                {
                    add_next_index_long(&alt_encoding0_ref, alt_encoding0[i]);
                }

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFontMapper::GetAltForEncoding\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFontEncoding wxFontMapper::GetEncoding(int n)
   Returns the n-th supported encoding. */
PHP_METHOD(php_wxFontMapper, GetEncoding)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFontMapper::GetEncoding\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFontMapper* current_object;
    wxphp_object_type current_object_type;
    wxFontMapper_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFontMapper_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFontMapper::GetEncoding call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONTMAPPER_TYPE){
                references = &((wxFontMapper_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long n0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&n0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &n0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_LONG(wxFontMapper::GetEncoding((size_t) n0))\n\n");
                #endif

                WXPHP_RETVAL_LONG(wxFontMapper::GetEncoding((size_t) n0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFontMapper::GetEncoding\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFontMapper::GetEncodingDescription(wxFontEncoding encoding)
   Return user-readable string describing the given encoding. */
PHP_METHOD(php_wxFontMapper, GetEncodingDescription)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFontMapper::GetEncodingDescription\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFontMapper* current_object;
    wxphp_object_type current_object_type;
    wxFontMapper_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFontMapper_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFontMapper::GetEncodingDescription call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONTMAPPER_TYPE){
                references = &((wxFontMapper_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long encoding0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&encoding0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &encoding0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFontMapper::GetEncodingDescription((wxFontEncoding) encoding0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = wxFontMapper::GetEncodingDescription((wxFontEncoding) encoding0);
                WXPHP_RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFontMapper::GetEncodingDescription\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFontEncoding wxFontMapper::GetEncodingFromName(string encoding)
   Return the encoding corresponding to the given internal name. */
PHP_METHOD(php_wxFontMapper, GetEncodingFromName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFontMapper::GetEncodingFromName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFontMapper* current_object;
    wxphp_object_type current_object_type;
    wxFontMapper_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFontMapper_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFontMapper::GetEncodingFromName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONTMAPPER_TYPE){
                references = &((wxFontMapper_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* encoding0;
    size_t encoding_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&encoding0, &encoding_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &encoding0, &encoding_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_LONG(wxFontMapper::GetEncodingFromName(wxString(encoding0, wxConvUTF8)))\n\n");
                #endif

                WXPHP_RETVAL_LONG(wxFontMapper::GetEncodingFromName(wxString(encoding0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFontMapper::GetEncodingFromName\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFontMapper::GetEncodingName(wxFontEncoding encoding)
   Return internal string identifier for the encoding (see also wxFontMapper::GetEncodingDescription). */
PHP_METHOD(php_wxFontMapper, GetEncodingName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFontMapper::GetEncodingName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFontMapper* current_object;
    wxphp_object_type current_object_type;
    wxFontMapper_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFontMapper_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFontMapper::GetEncodingName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONTMAPPER_TYPE){
                references = &((wxFontMapper_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long encoding0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&encoding0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &encoding0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFontMapper::GetEncodingName((wxFontEncoding) encoding0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = wxFontMapper::GetEncodingName((wxFontEncoding) encoding0);
                WXPHP_RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFontMapper::GetEncodingName\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxFontMapper::GetSupportedEncodingsCount()
   Returns the number of the font encodings supported by this class. */
PHP_METHOD(php_wxFontMapper, GetSupportedEncodingsCount)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFontMapper::GetSupportedEncodingsCount\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFontMapper* current_object;
    wxphp_object_type current_object_type;
    wxFontMapper_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFontMapper_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFontMapper::GetSupportedEncodingsCount call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONTMAPPER_TYPE){
                references = &((wxFontMapper_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_LONG(wxFontMapper::GetSupportedEncodingsCount())\n\n");
                #endif

                WXPHP_RETVAL_LONG(wxFontMapper::GetSupportedEncodingsCount());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFontMapper::GetSupportedEncodingsCount\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFontMapper::IsEncodingAvailable(wxFontEncoding encoding, string facename)
   Check whether given encoding is available in given face or not. */
PHP_METHOD(php_wxFontMapper, IsEncodingAvailable)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFontMapper::IsEncodingAvailable\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFontMapper* current_object;
    wxphp_object_type current_object_type;
    wxFontMapper_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFontMapper_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFontMapper::IsEncodingAvailable call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONTMAPPER_TYPE){
                references = &((wxFontMapper_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long encoding0;
    char* facename0;
    size_t facename_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l|s' (&encoding0, &facename0, &facename_len0)\n");
        #endif

        char parse_parameters_string[] = "l|s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &encoding0, &facename0, &facename_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFontMapper::IsEncodingAvailable((wxFontEncoding) encoding0))\n\n");
                #endif

                WXPHP_RETVAL_BOOL(((wxFontMapper_php*)native_object)->IsEncodingAvailable((wxFontEncoding) encoding0));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFontMapper::IsEncodingAvailable((wxFontEncoding) encoding0, wxString(facename0, wxConvUTF8)))\n\n");
                #endif

                WXPHP_RETVAL_BOOL(((wxFontMapper_php*)native_object)->IsEncodingAvailable((wxFontEncoding) encoding0, wxString(facename0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFontMapper::IsEncodingAvailable\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFontMapper wxFontMapper::Set(wxFontMapper &mapper)
   Set the current font mapper object and return previous one (may be NULL). */
PHP_METHOD(php_wxFontMapper, Set)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFontMapper::Set\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFontMapper* current_object;
    wxphp_object_type current_object_type;
    wxFontMapper_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFontMapper_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFontMapper::Set call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONTMAPPER_TYPE){
                references = &((wxFontMapper_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* mapper0;
    wxFontMapper* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&mapper0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &mapper0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(mapper0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxFontMapper_P(mapper0)->object_type;
                    argument_native_object = (void*) Z_wxFontMapper_P(mapper0)->native_object;
                    object_pointer0_0 = (wxFontMapper*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXFONTMAPPER_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'mapper' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(mapper0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'mapper' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFontMapper::Set((wxFontMapper*) object_pointer0_0) to return object pointer\n\n");
                #endif

                wxFontMapper_php* value_to_return1;
                value_to_return1 = (wxFontMapper_php*) wxFontMapper::Set((wxFontMapper*) object_pointer0_0);
                if(value_to_return1 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return1->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return1->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return1->phpObj);
                        zval_add_ref(&value_to_return1->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxFontMapper_entry);
                    Z_wxFontMapper_P(return_value)->native_object = (wxFontMapper_php*) value_to_return1;
                }



                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFontMapper::Set\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFontMapper::SetConfigPath(string prefix)
   Set the root config path to use (should be an absolute path). */
PHP_METHOD(php_wxFontMapper, SetConfigPath)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFontMapper::SetConfigPath\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFontMapper* current_object;
    wxphp_object_type current_object_type;
    wxFontMapper_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFontMapper_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFontMapper::SetConfigPath call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONTMAPPER_TYPE){
                references = &((wxFontMapper_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* prefix0;
    size_t prefix_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&prefix0, &prefix_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &prefix0, &prefix_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFontMapper::SetConfigPath(wxString(prefix0, wxConvUTF8))\n\n");
                #endif

                ((wxFontMapper_php*)native_object)->SetConfigPath(wxString(prefix0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFontMapper::SetConfigPath\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFontMapper::SetDialogParent(wxWindow &parent)
   The parent window for modal dialogs. */
PHP_METHOD(php_wxFontMapper, SetDialogParent)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFontMapper::SetDialogParent\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFontMapper* current_object;
    wxphp_object_type current_object_type;
    wxFontMapper_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFontMapper_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFontMapper::SetDialogParent call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONTMAPPER_TYPE){
                references = &((wxFontMapper_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* parent0;
    wxWindow* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&parent0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &parent0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(parent0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxWindow_P(parent0)->object_type;
                    argument_native_object = (void*) Z_wxWindow_P(parent0)->native_object;
                    object_pointer0_0 = (wxWindow*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'parent' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(parent0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'parent' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFontMapper::SetDialogParent((wxWindow*) object_pointer0_0)\n\n");
                #endif

                ((wxFontMapper_php*)native_object)->SetDialogParent((wxWindow*) object_pointer0_0);

                references->AddReference(parent0, "wxFontMapper::SetDialogParent at call 1 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFontMapper::SetDialogParent\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFontMapper::SetDialogTitle(string title)
   The title for the dialogs (note that default is quite reasonable). */
PHP_METHOD(php_wxFontMapper, SetDialogTitle)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFontMapper::SetDialogTitle\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFontMapper* current_object;
    wxphp_object_type current_object_type;
    wxFontMapper_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFontMapper_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFontMapper::SetDialogTitle call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFONTMAPPER_TYPE){
                references = &((wxFontMapper_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* title0;
    size_t title_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&title0, &title_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &title0, &title_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFontMapper::SetDialogTitle(wxString(title0, wxConvUTF8))\n\n");
                #endif

                ((wxFontMapper_php*)native_object)->SetDialogTitle(wxString(title0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFontMapper::SetDialogTitle\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFontMapper::wxFontMapper()
   Default ctor. */
PHP_METHOD(php_wxFontMapper, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFontMapper::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFontMapper* current_object;
    wxFontMapper_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxFontMapper_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxFontMapper_P(getThis());

        current_object->native_object = native_object;
        native_object->zo = current_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxFontMapper::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxPlatformInfo_free(zend_object *object)
{
    zo_wxPlatformInfo* custom_object = php_wxPlatformInfo_fetch_object(object);

    if (custom_object->is_user_initialized && (custom_object->native_object != NULL)) {
        custom_object->native_object->zo = NULL;
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxPlatformInfo_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxPlatformInfo done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
}

wxPlatformInfo_php::~wxPlatformInfo_php()
{
    if (zo) {
        zo->native_object = NULL;
    }
}

zend_object* php_wxPlatformInfo_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxPlatformInfo_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* custom_object;

    custom_object = (zo_wxPlatformInfo*) ecalloc(
        1,
        sizeof(zo_wxPlatformInfo)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    memcpy(&wxphp_wxPlatformInfo_object_handlers, zend_get_std_object_handlers(), sizeof wxphp_wxPlatformInfo_object_handlers);
    wxphp_wxPlatformInfo_object_handlers.offset = XtOffsetOf(zo_wxPlatformInfo, zo);
    wxphp_wxPlatformInfo_object_handlers.free_obj = php_wxPlatformInfo_free;
    custom_object->zo.handlers = &wxphp_wxPlatformInfo_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXPLATFORMINFO_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxPlatformInfo::wxPlatformInfo()
   Initializes the instance with the values corresponding to the currently running platform. */
PHP_METHOD(php_wxPlatformInfo, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    long pid1;
    long tkMajor1;
    long tkMinor1;
    long id1;
    long osMajor1;
    long osMinor1;
    long bitness1;
    long endian1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 1  && arguments_received <= 8)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l|lllllll' (&pid1, &tkMajor1, &tkMinor1, &id1, &osMajor1, &osMinor1, &bitness1, &endian1)\n");
        #endif

        char parse_parameters_string[] = "l|lllllll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pid1, &tkMajor1, &tkMinor1, &id1, &osMajor1, &osMinor1, &bitness1, &endian1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxPlatformInfo_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxPortId) pid1)\n");
                #endif

                native_object = new wxPlatformInfo_php((wxPortId) pid1);

                native_object->references.Initialize();
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxPortId) pid1, (int) tkMajor1)\n");
                #endif

                native_object = new wxPlatformInfo_php((wxPortId) pid1, (int) tkMajor1);

                native_object->references.Initialize();
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxPortId) pid1, (int) tkMajor1, (int) tkMinor1)\n");
                #endif

                native_object = new wxPlatformInfo_php((wxPortId) pid1, (int) tkMajor1, (int) tkMinor1);

                native_object->references.Initialize();
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxPortId) pid1, (int) tkMajor1, (int) tkMinor1, (wxOperatingSystemId) id1)\n");
                #endif

                native_object = new wxPlatformInfo_php((wxPortId) pid1, (int) tkMajor1, (int) tkMinor1, (wxOperatingSystemId) id1);

                native_object->references.Initialize();
                break;
            }
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxPortId) pid1, (int) tkMajor1, (int) tkMinor1, (wxOperatingSystemId) id1, (int) osMajor1)\n");
                #endif

                native_object = new wxPlatformInfo_php((wxPortId) pid1, (int) tkMajor1, (int) tkMinor1, (wxOperatingSystemId) id1, (int) osMajor1);

                native_object->references.Initialize();
                break;
            }
            case 6:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxPortId) pid1, (int) tkMajor1, (int) tkMinor1, (wxOperatingSystemId) id1, (int) osMajor1, (int) osMinor1)\n");
                #endif

                native_object = new wxPlatformInfo_php((wxPortId) pid1, (int) tkMajor1, (int) tkMinor1, (wxOperatingSystemId) id1, (int) osMajor1, (int) osMinor1);

                native_object->references.Initialize();
                break;
            }
            case 7:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxPortId) pid1, (int) tkMajor1, (int) tkMinor1, (wxOperatingSystemId) id1, (int) osMajor1, (int) osMinor1, (wxBitness) bitness1)\n");
                #endif

                native_object = new wxPlatformInfo_php((wxPortId) pid1, (int) tkMajor1, (int) tkMinor1, (wxOperatingSystemId) id1, (int) osMajor1, (int) osMinor1, (wxBitness) bitness1);

                native_object->references.Initialize();
                break;
            }
            case 8:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxPortId) pid1, (int) tkMajor1, (int) tkMinor1, (wxOperatingSystemId) id1, (int) osMajor1, (int) osMinor1, (wxBitness) bitness1, (wxEndianness) endian1)\n");
                #endif

                native_object = new wxPlatformInfo_php((wxPortId) pid1, (int) tkMajor1, (int) tkMinor1, (wxOperatingSystemId) id1, (int) osMajor1, (int) osMinor1, (wxBitness) bitness1, (wxEndianness) endian1);

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxPlatformInfo_P(getThis());

        current_object->native_object = native_object;
        native_object->zo = current_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxPlatformInfo::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto bool wxPlatformInfo::CheckOSVersion(int major, int minor, int micro)
   Returns true if the OS version is at least major.minor.micro. */
PHP_METHOD(php_wxPlatformInfo, CheckOSVersion)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::CheckOSVersion\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::CheckOSVersion call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long major0;
    long minor0;
    long micro0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll|l' (&major0, &minor0, &micro0)\n");
        #endif

        char parse_parameters_string[] = "ll|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &major0, &minor0, &micro0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxPlatformInfo::CheckOSVersion((int) major0, (int) minor0))\n\n");
                #endif

                WXPHP_RETVAL_BOOL(((wxPlatformInfo_php*)native_object)->CheckOSVersion((int) major0, (int) minor0));


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxPlatformInfo::CheckOSVersion((int) major0, (int) minor0, (int) micro0))\n\n");
                #endif

                WXPHP_RETVAL_BOOL(((wxPlatformInfo_php*)native_object)->CheckOSVersion((int) major0, (int) minor0, (int) micro0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::CheckOSVersion\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxPlatformInfo::CheckToolkitVersion(int major, int minor, int micro)
   Returns true if the toolkit version is at least major.minor.micro. */
PHP_METHOD(php_wxPlatformInfo, CheckToolkitVersion)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::CheckToolkitVersion\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::CheckToolkitVersion call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long major0;
    long minor0;
    long micro0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll|l' (&major0, &minor0, &micro0)\n");
        #endif

        char parse_parameters_string[] = "ll|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &major0, &minor0, &micro0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxPlatformInfo::CheckToolkitVersion((int) major0, (int) minor0))\n\n");
                #endif

                WXPHP_RETVAL_BOOL(((wxPlatformInfo_php*)native_object)->CheckToolkitVersion((int) major0, (int) minor0));


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxPlatformInfo::CheckToolkitVersion((int) major0, (int) minor0, (int) micro0))\n\n");
                #endif

                WXPHP_RETVAL_BOOL(((wxPlatformInfo_php*)native_object)->CheckToolkitVersion((int) major0, (int) minor0, (int) micro0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::CheckToolkitVersion\n"
        );
    }
}
/* }}} */

/* {{{ proto wxPlatformInfo wxPlatformInfo::Get()
   Returns the global wxPlatformInfo object, initialized with the values for the currently running platform. */
PHP_METHOD(php_wxPlatformInfo, Get)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::Get\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::Get call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxPlatformInfo::Get() to return object reference\n\n");
                #endif

                wxPlatformInfo_php* value_to_return0;
                value_to_return0 = (wxPlatformInfo_php*) &wxPlatformInfo::Get();
                if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxPlatformInfo_entry);
                    Z_wxPlatformInfo_P(return_value)->native_object = (wxPlatformInfo_php*) value_to_return0;
                }



                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::Get\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxPlatformInfo::GetDesktopEnvironment()
   Returns the desktop environment associated with this wxPlatformInfo instance. */
PHP_METHOD(php_wxPlatformInfo, GetDesktopEnvironment)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::GetDesktopEnvironment\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::GetDesktopEnvironment call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxPlatformInfo::GetDesktopEnvironment().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxPlatformInfo_php*)native_object)->GetDesktopEnvironment();
                WXPHP_RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::GetDesktopEnvironment\n"
        );
    }
}
/* }}} */

/* {{{ proto wxEndianness wxPlatformInfo::GetEndianness(string end)
   Converts the given string to a wxEndianness enum value or to wxENDIAN_INVALID if the given string is not a valid endianness string (i.e. */
PHP_METHOD(php_wxPlatformInfo, GetEndianness)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::GetEndianness\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::GetEndianness call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* end0;
    size_t end_len0;
    bool overload0_called = false;

    //Parameters for overload 1
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&end0, &end_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &end0, &end_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload1_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_LONG(wxPlatformInfo::GetEndianness(wxString(end0, wxConvUTF8)))\n\n");
                #endif

                WXPHP_RETVAL_LONG(wxPlatformInfo::GetEndianness(wxString(end0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPlatformInfo::GetEndianness())\n\n");
                #endif

                WXPHP_RETVAL_LONG(((wxPlatformInfo_php*)native_object)->GetEndianness());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::GetEndianness\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxPlatformInfo::GetEndiannessName(wxEndianness end)
   Returns name for the given wxEndianness enumeration value. */
PHP_METHOD(php_wxPlatformInfo, GetEndiannessName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::GetEndiannessName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::GetEndiannessName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long end0;
    bool overload0_called = false;

    //Parameters for overload 1
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&end0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &end0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload1_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxPlatformInfo::GetEndiannessName((wxEndianness) end0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = wxPlatformInfo::GetEndiannessName((wxEndianness) end0);
                WXPHP_RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxPlatformInfo::GetEndiannessName().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxPlatformInfo_php*)native_object)->GetEndiannessName();
                WXPHP_RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::GetEndiannessName\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxPlatformInfo::GetOSMajorVersion()
   Returns the run-time major version of the OS associated with this wxPlatformInfo instance. */
PHP_METHOD(php_wxPlatformInfo, GetOSMajorVersion)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::GetOSMajorVersion\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::GetOSMajorVersion call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPlatformInfo::GetOSMajorVersion())\n\n");
                #endif

                WXPHP_RETVAL_LONG(((wxPlatformInfo_php*)native_object)->GetOSMajorVersion());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::GetOSMajorVersion\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxPlatformInfo::GetOSMinorVersion()
   Returns the run-time minor version of the OS associated with this wxPlatformInfo instance. */
PHP_METHOD(php_wxPlatformInfo, GetOSMinorVersion)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::GetOSMinorVersion\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::GetOSMinorVersion call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPlatformInfo::GetOSMinorVersion())\n\n");
                #endif

                WXPHP_RETVAL_LONG(((wxPlatformInfo_php*)native_object)->GetOSMinorVersion());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::GetOSMinorVersion\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxPlatformInfo::GetOperatingSystemDescription()
   Returns the description of the operating system of this wxPlatformInfo instance. */
PHP_METHOD(php_wxPlatformInfo, GetOperatingSystemDescription)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::GetOperatingSystemDescription\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::GetOperatingSystemDescription call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxPlatformInfo::GetOperatingSystemDescription().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxPlatformInfo_php*)native_object)->GetOperatingSystemDescription();
                WXPHP_RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::GetOperatingSystemDescription\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxPlatformInfo::GetOperatingSystemDirectory()
   Returns the operating system directory. */
PHP_METHOD(php_wxPlatformInfo, GetOperatingSystemDirectory)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::GetOperatingSystemDirectory\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::GetOperatingSystemDirectory call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxPlatformInfo::GetOperatingSystemDirectory().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = wxPlatformInfo::GetOperatingSystemDirectory();
                WXPHP_RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::GetOperatingSystemDirectory\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxPlatformInfo::GetOperatingSystemFamilyName(wxOperatingSystemId os)
   Returns the operating system family name for the given wxOperatingSystemId enumeration value: Unix for wxOS_UNIX, OSX for wxOS_MAC_OS, Windows for wxOS_WINDOWS. */
PHP_METHOD(php_wxPlatformInfo, GetOperatingSystemFamilyName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::GetOperatingSystemFamilyName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::GetOperatingSystemFamilyName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long os0;
    bool overload0_called = false;

    //Parameters for overload 1
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&os0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &os0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload1_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxPlatformInfo::GetOperatingSystemFamilyName((wxOperatingSystemId) os0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = wxPlatformInfo::GetOperatingSystemFamilyName((wxOperatingSystemId) os0);
                WXPHP_RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxPlatformInfo::GetOperatingSystemFamilyName().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxPlatformInfo_php*)native_object)->GetOperatingSystemFamilyName();
                WXPHP_RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::GetOperatingSystemFamilyName\n"
        );
    }
}
/* }}} */

/* {{{ proto wxOperatingSystemId wxPlatformInfo::GetOperatingSystemId(string name)
   Converts the given string to a wxOperatingSystemId enum value or to wxOS_UNKNOWN if the given string is not a valid operating system name. */
PHP_METHOD(php_wxPlatformInfo, GetOperatingSystemId)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::GetOperatingSystemId\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::GetOperatingSystemId call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    bool overload0_called = false;

    //Parameters for overload 1
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload1_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_LONG(wxPlatformInfo::GetOperatingSystemId(wxString(name0, wxConvUTF8)))\n\n");
                #endif

                WXPHP_RETVAL_LONG(wxPlatformInfo::GetOperatingSystemId(wxString(name0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPlatformInfo::GetOperatingSystemId())\n\n");
                #endif

                WXPHP_RETVAL_LONG(((wxPlatformInfo_php*)native_object)->GetOperatingSystemId());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::GetOperatingSystemId\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxPlatformInfo::GetOperatingSystemIdName(wxOperatingSystemId os)
   Returns the name for the given operating system ID value. */
PHP_METHOD(php_wxPlatformInfo, GetOperatingSystemIdName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::GetOperatingSystemIdName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::GetOperatingSystemIdName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long os0;
    bool overload0_called = false;

    //Parameters for overload 1
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&os0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &os0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload1_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxPlatformInfo::GetOperatingSystemIdName((wxOperatingSystemId) os0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = wxPlatformInfo::GetOperatingSystemIdName((wxOperatingSystemId) os0);
                WXPHP_RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxPlatformInfo::GetOperatingSystemIdName().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxPlatformInfo_php*)native_object)->GetOperatingSystemIdName();
                WXPHP_RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::GetOperatingSystemIdName\n"
        );
    }
}
/* }}} */

/* {{{ proto wxPortId wxPlatformInfo::GetPortId(string portname)
   Converts the given string to a wxWidgets port ID value or to wxPORT_UNKNOWN if the given string does not match any of the wxWidgets canonical name ports ("wxGTK", "wxMSW", etc) nor any of the short wxWidgets name ports ("gtk", "msw", etc). */
PHP_METHOD(php_wxPlatformInfo, GetPortId)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::GetPortId\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::GetPortId call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* portname0;
    size_t portname_len0;
    bool overload0_called = false;

    //Parameters for overload 1
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&portname0, &portname_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &portname0, &portname_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload1_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_LONG(wxPlatformInfo::GetPortId(wxString(portname0, wxConvUTF8)))\n\n");
                #endif

                WXPHP_RETVAL_LONG(wxPlatformInfo::GetPortId(wxString(portname0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPlatformInfo::GetPortId())\n\n");
                #endif

                WXPHP_RETVAL_LONG(((wxPlatformInfo_php*)native_object)->GetPortId());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::GetPortId\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxPlatformInfo::GetPortIdName(wxPortId port, bool usingUniversal)
   Returns the name of the given wxWidgets port ID value. */
PHP_METHOD(php_wxPlatformInfo, GetPortIdName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::GetPortIdName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::GetPortIdName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long port0;
    bool usingUniversal0;
    bool overload0_called = false;

    //Parameters for overload 1
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'lb' (&port0, &usingUniversal0)\n");
        #endif

        char parse_parameters_string[] = "lb";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &port0, &usingUniversal0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload1_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxPlatformInfo::GetPortIdName((wxPortId) port0, usingUniversal0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return2;
                value_to_return2 = wxPlatformInfo::GetPortIdName((wxPortId) port0, usingUniversal0);
                WXPHP_RETVAL_STRING(value_to_return2.ToUTF8().data());


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxPlatformInfo::GetPortIdName().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxPlatformInfo_php*)native_object)->GetPortIdName();
                WXPHP_RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::GetPortIdName\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxPlatformInfo::GetPortIdShortName(wxPortId port, bool usingUniversal)
   Returns the short name of the given wxWidgets port ID value. */
PHP_METHOD(php_wxPlatformInfo, GetPortIdShortName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::GetPortIdShortName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::GetPortIdShortName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long port0;
    bool usingUniversal0;
    bool overload0_called = false;

    //Parameters for overload 1
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'lb' (&port0, &usingUniversal0)\n");
        #endif

        char parse_parameters_string[] = "lb";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &port0, &usingUniversal0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload1_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxPlatformInfo::GetPortIdShortName((wxPortId) port0, usingUniversal0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return2;
                value_to_return2 = wxPlatformInfo::GetPortIdShortName((wxPortId) port0, usingUniversal0);
                WXPHP_RETVAL_STRING(value_to_return2.ToUTF8().data());


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxPlatformInfo::GetPortIdShortName().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxPlatformInfo_php*)native_object)->GetPortIdShortName();
                WXPHP_RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::GetPortIdShortName\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxPlatformInfo::GetToolkitMajorVersion()
   Returns the run-time major version of the toolkit associated with this wxPlatformInfo instance. */
PHP_METHOD(php_wxPlatformInfo, GetToolkitMajorVersion)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::GetToolkitMajorVersion\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::GetToolkitMajorVersion call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPlatformInfo::GetToolkitMajorVersion())\n\n");
                #endif

                WXPHP_RETVAL_LONG(((wxPlatformInfo_php*)native_object)->GetToolkitMajorVersion());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::GetToolkitMajorVersion\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxPlatformInfo::GetToolkitMinorVersion()
   Returns the run-time minor version of the toolkit associated with this wxPlatformInfo instance. */
PHP_METHOD(php_wxPlatformInfo, GetToolkitMinorVersion)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::GetToolkitMinorVersion\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::GetToolkitMinorVersion call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxPlatformInfo::GetToolkitMinorVersion())\n\n");
                #endif

                WXPHP_RETVAL_LONG(((wxPlatformInfo_php*)native_object)->GetToolkitMinorVersion());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::GetToolkitMinorVersion\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxPlatformInfo::IsOk()
   Returns true if this instance is fully initialized with valid values. */
PHP_METHOD(php_wxPlatformInfo, IsOk)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::IsOk\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::IsOk call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxPlatformInfo::IsOk())\n\n");
                #endif

                WXPHP_RETVAL_BOOL(((wxPlatformInfo_php*)native_object)->IsOk());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::IsOk\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxPlatformInfo::IsUsingUniversalWidgets()
   Returns true if this wxPlatformInfo describes wxUniversal build. */
PHP_METHOD(php_wxPlatformInfo, IsUsingUniversalWidgets)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::IsUsingUniversalWidgets\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::IsUsingUniversalWidgets call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxPlatformInfo::IsUsingUniversalWidgets())\n\n");
                #endif

                WXPHP_RETVAL_BOOL(((wxPlatformInfo_php*)native_object)->IsUsingUniversalWidgets());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::IsUsingUniversalWidgets\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPlatformInfo::SetDesktopEnvironment(string de)
   Sets the desktop environment associated with this wxPlatformInfo instance. */
PHP_METHOD(php_wxPlatformInfo, SetDesktopEnvironment)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::SetDesktopEnvironment\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::SetDesktopEnvironment call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* de0;
    size_t de_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&de0, &de_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &de0, &de_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPlatformInfo::SetDesktopEnvironment(wxString(de0, wxConvUTF8))\n\n");
                #endif

                ((wxPlatformInfo_php*)native_object)->SetDesktopEnvironment(wxString(de0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::SetDesktopEnvironment\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPlatformInfo::SetEndianness(wxEndianness n)
   Sets the endianness enum value associated with this wxPlatformInfo instance. */
PHP_METHOD(php_wxPlatformInfo, SetEndianness)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::SetEndianness\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::SetEndianness call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long n0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&n0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &n0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPlatformInfo::SetEndianness((wxEndianness) n0)\n\n");
                #endif

                ((wxPlatformInfo_php*)native_object)->SetEndianness((wxEndianness) n0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::SetEndianness\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPlatformInfo::SetOSVersion(int major, int minor, int micro)
   Sets the version of the operating system associated with this wxPlatformInfo instance. */
PHP_METHOD(php_wxPlatformInfo, SetOSVersion)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::SetOSVersion\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::SetOSVersion call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long major0;
    long minor0;
    long micro0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll|l' (&major0, &minor0, &micro0)\n");
        #endif

        char parse_parameters_string[] = "ll|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &major0, &minor0, &micro0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPlatformInfo::SetOSVersion((int) major0, (int) minor0)\n\n");
                #endif

                ((wxPlatformInfo_php*)native_object)->SetOSVersion((int) major0, (int) minor0);


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPlatformInfo::SetOSVersion((int) major0, (int) minor0, (int) micro0)\n\n");
                #endif

                ((wxPlatformInfo_php*)native_object)->SetOSVersion((int) major0, (int) minor0, (int) micro0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::SetOSVersion\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPlatformInfo::SetOperatingSystemDescription(string desc)
   Sets the operating system description associated with this wxPlatformInfo instance. */
PHP_METHOD(php_wxPlatformInfo, SetOperatingSystemDescription)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::SetOperatingSystemDescription\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::SetOperatingSystemDescription call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* desc0;
    size_t desc_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&desc0, &desc_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &desc0, &desc_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPlatformInfo::SetOperatingSystemDescription(wxString(desc0, wxConvUTF8))\n\n");
                #endif

                ((wxPlatformInfo_php*)native_object)->SetOperatingSystemDescription(wxString(desc0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::SetOperatingSystemDescription\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPlatformInfo::SetOperatingSystemId(wxOperatingSystemId n)
   Sets the operating system associated with this wxPlatformInfo instance. */
PHP_METHOD(php_wxPlatformInfo, SetOperatingSystemId)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::SetOperatingSystemId\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::SetOperatingSystemId call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long n0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&n0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &n0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPlatformInfo::SetOperatingSystemId((wxOperatingSystemId) n0)\n\n");
                #endif

                ((wxPlatformInfo_php*)native_object)->SetOperatingSystemId((wxOperatingSystemId) n0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::SetOperatingSystemId\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPlatformInfo::SetPortId(wxPortId n)
   Sets the wxWidgets port ID associated with this wxPlatformInfo instance. */
PHP_METHOD(php_wxPlatformInfo, SetPortId)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::SetPortId\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::SetPortId call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long n0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&n0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &n0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPlatformInfo::SetPortId((wxPortId) n0)\n\n");
                #endif

                ((wxPlatformInfo_php*)native_object)->SetPortId((wxPortId) n0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::SetPortId\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPlatformInfo::SetToolkitVersion(int major, int minor, int micro)
   Sets the version of the toolkit associated with this wxPlatformInfo instance. */
PHP_METHOD(php_wxPlatformInfo, SetToolkitVersion)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPlatformInfo::SetToolkitVersion\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPlatformInfo* current_object;
    wxphp_object_type current_object_type;
    wxPlatformInfo_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPlatformInfo_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPlatformInfo::SetToolkitVersion call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPLATFORMINFO_TYPE){
                references = &((wxPlatformInfo_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long major0;
    long minor0;
    long micro0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'll|l' (&major0, &minor0, &micro0)\n");
        #endif

        char parse_parameters_string[] = "ll|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &major0, &minor0, &micro0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPlatformInfo::SetToolkitVersion((int) major0, (int) minor0)\n\n");
                #endif

                ((wxPlatformInfo_php*)native_object)->SetToolkitVersion((int) major0, (int) minor0);


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPlatformInfo::SetToolkitVersion((int) major0, (int) minor0, (int) micro0)\n\n");
                #endif

                ((wxPlatformInfo_php*)native_object)->SetToolkitVersion((int) major0, (int) minor0, (int) micro0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPlatformInfo::SetToolkitVersion\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxSystemSettings_free(zend_object *object)
{
    zo_wxSystemSettings* custom_object = php_wxSystemSettings_fetch_object(object);

    if (custom_object->is_user_initialized && (custom_object->native_object != NULL)) {
        custom_object->native_object->zo = NULL;
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxSystemSettings_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxSystemSettings done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
}

wxSystemSettings_php::~wxSystemSettings_php()
{
    if (zo) {
        zo->native_object = NULL;
    }
}

zend_object* php_wxSystemSettings_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxSystemSettings_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxSystemSettings* custom_object;

    custom_object = (zo_wxSystemSettings*) ecalloc(
        1,
        sizeof(zo_wxSystemSettings)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    memcpy(&wxphp_wxSystemSettings_object_handlers, zend_get_std_object_handlers(), sizeof wxphp_wxSystemSettings_object_handlers);
    wxphp_wxSystemSettings_object_handlers.offset = XtOffsetOf(zo_wxSystemSettings, zo);
    wxphp_wxSystemSettings_object_handlers.free_obj = php_wxSystemSettings_free;
    custom_object->zo.handlers = &wxphp_wxSystemSettings_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXSYSTEMSETTINGS_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto wxColour wxSystemSettings::GetColour(wxSystemColour index)
   Returns a system colour. */
PHP_METHOD(php_wxSystemSettings, GetColour)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxSystemSettings::GetColour\n");
    php_printf("===========================================\n");
    #endif

    zo_wxSystemSettings* current_object;
    wxphp_object_type current_object_type;
    wxSystemSettings_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxSystemSettings_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxSystemSettings::GetColour call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSYSTEMSETTINGS_TYPE){
                references = &((wxSystemSettings_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long index0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&index0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &index0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxSystemSettings::GetColour((wxSystemColour) index0) to return new object\n\n");
                #endif

                wxColour value_to_return1;
                value_to_return1 = wxSystemSettings::GetColour((wxSystemColour) index0);
                #if !defined(__WXMSW__) && !defined(__WXMAC__)
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                #endif
                void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxColour));
                object_init_ex(return_value, php_wxColour_entry);
                ((wxColour_php*)ptr)->phpObj = *return_value;
                zo_wxColour* zo1 = Z_wxColour_P(return_value);
                zo1->native_object = (wxColour_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxSystemSettings::GetColour\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFont wxSystemSettings::GetFont(wxSystemFont index)
   Returns a system font. */
PHP_METHOD(php_wxSystemSettings, GetFont)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxSystemSettings::GetFont\n");
    php_printf("===========================================\n");
    #endif

    zo_wxSystemSettings* current_object;
    wxphp_object_type current_object_type;
    wxSystemSettings_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxSystemSettings_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxSystemSettings::GetFont call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSYSTEMSETTINGS_TYPE){
                references = &((wxSystemSettings_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long index0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&index0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &index0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxSystemSettings::GetFont((wxSystemFont) index0) to return new object\n\n");
                #endif

                wxFont value_to_return1;
                value_to_return1 = wxSystemSettings::GetFont((wxSystemFont) index0);
                #if !defined(__WXMSW__) && !defined(__WXMAC__)
                ((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
                #endif
                void* ptr = safe_emalloc(1, sizeof(wxFont_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxFont));
                object_init_ex(return_value, php_wxFont_entry);
                ((wxFont_php*)ptr)->phpObj = *return_value;
                zo_wxFont* zo1 = Z_wxFont_P(return_value);
                zo1->native_object = (wxFont_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxSystemSettings::GetFont\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxSystemSettings::GetMetric(wxSystemMetric index, wxWindow &win)
   Returns the value of a system metric, or -1 if the metric is not supported on the current system. */
PHP_METHOD(php_wxSystemSettings, GetMetric)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxSystemSettings::GetMetric\n");
    php_printf("===========================================\n");
    #endif

    zo_wxSystemSettings* current_object;
    wxphp_object_type current_object_type;
    wxSystemSettings_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxSystemSettings_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxSystemSettings::GetMetric call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSYSTEMSETTINGS_TYPE){
                references = &((wxSystemSettings_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long index0;
    zval* win0;
    wxWindow* object_pointer0_1 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l|z' (&index0, &win0)\n");
        #endif

        char parse_parameters_string[] = "l|z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &index0, &win0 ) == SUCCESS)
        {
            if(arguments_received >= 2){
                if(Z_TYPE_P(win0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxWindow_P(win0)->object_type;
                    argument_native_object = (void*) Z_wxWindow_P(win0)->native_object;
                    object_pointer0_1 = (wxWindow*) argument_native_object;
                    if (!object_pointer0_1 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'win' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(win0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'win' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_LONG(wxSystemSettings::GetMetric((wxSystemMetric) index0))\n\n");
                #endif

                WXPHP_RETVAL_LONG(wxSystemSettings::GetMetric((wxSystemMetric) index0));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_LONG(wxSystemSettings::GetMetric((wxSystemMetric) index0, (wxWindow*) object_pointer0_1))\n\n");
                #endif

                WXPHP_RETVAL_LONG(wxSystemSettings::GetMetric((wxSystemMetric) index0, (wxWindow*) object_pointer0_1));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxSystemSettings::GetMetric\n"
        );
    }
}
/* }}} */

/* {{{ proto wxSystemScreenType wxSystemSettings::GetScreenType()
   Returns the screen type. */
PHP_METHOD(php_wxSystemSettings, GetScreenType)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxSystemSettings::GetScreenType\n");
    php_printf("===========================================\n");
    #endif

    zo_wxSystemSettings* current_object;
    wxphp_object_type current_object_type;
    wxSystemSettings_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxSystemSettings_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxSystemSettings::GetScreenType call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSYSTEMSETTINGS_TYPE){
                references = &((wxSystemSettings_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_LONG(wxSystemSettings::GetScreenType())\n\n");
                #endif

                WXPHP_RETVAL_LONG(wxSystemSettings::GetScreenType());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxSystemSettings::GetScreenType\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxSystemSettings::HasFeature(wxSystemFeature index)
   Returns true if the port has certain feature. */
PHP_METHOD(php_wxSystemSettings, HasFeature)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxSystemSettings::HasFeature\n");
    php_printf("===========================================\n");
    #endif

    zo_wxSystemSettings* current_object;
    wxphp_object_type current_object_type;
    wxSystemSettings_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxSystemSettings_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxSystemSettings::HasFeature call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSYSTEMSETTINGS_TYPE){
                references = &((wxSystemSettings_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long index0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&index0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &index0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxSystemSettings::HasFeature((wxSystemFeature) index0))\n\n");
                #endif

                WXPHP_RETVAL_BOOL(wxSystemSettings::HasFeature((wxSystemFeature) index0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxSystemSettings::HasFeature\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxSystemOptions_free(zend_object *object)
{
    zo_wxSystemOptions* custom_object = php_wxSystemOptions_fetch_object(object);

    if (custom_object->is_user_initialized && (custom_object->native_object != NULL)) {
        custom_object->native_object->zo = NULL;
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxSystemOptions_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxSystemOptions done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
}

wxSystemOptions_php::~wxSystemOptions_php()
{
    if (zo) {
        zo->native_object = NULL;
    }
}

zend_object* php_wxSystemOptions_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxSystemOptions_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxSystemOptions* custom_object;

    custom_object = (zo_wxSystemOptions*) ecalloc(
        1,
        sizeof(zo_wxSystemOptions)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    memcpy(&wxphp_wxSystemOptions_object_handlers, zend_get_std_object_handlers(), sizeof wxphp_wxSystemOptions_object_handlers);
    wxphp_wxSystemOptions_object_handlers.offset = XtOffsetOf(zo_wxSystemOptions, zo);
    wxphp_wxSystemOptions_object_handlers.free_obj = php_wxSystemOptions_free;
    custom_object->zo.handlers = &wxphp_wxSystemOptions_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXSYSTEMOPTIONS_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto string wxSystemOptions::GetOption(string name)
   Gets an option. */
PHP_METHOD(php_wxSystemOptions, GetOption)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxSystemOptions::GetOption\n");
    php_printf("===========================================\n");
    #endif

    zo_wxSystemOptions* current_object;
    wxphp_object_type current_object_type;
    wxSystemOptions_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxSystemOptions_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxSystemOptions::GetOption call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSYSTEMOPTIONS_TYPE){
                references = &((wxSystemOptions_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxSystemOptions::GetOption(wxString(name0, wxConvUTF8)).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = wxSystemOptions::GetOption(wxString(name0, wxConvUTF8));
                WXPHP_RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxSystemOptions::GetOption\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxSystemOptions::GetOptionInt(string name)
   Gets an option as an integer. */
PHP_METHOD(php_wxSystemOptions, GetOptionInt)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxSystemOptions::GetOptionInt\n");
    php_printf("===========================================\n");
    #endif

    zo_wxSystemOptions* current_object;
    wxphp_object_type current_object_type;
    wxSystemOptions_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxSystemOptions_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxSystemOptions::GetOptionInt call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSYSTEMOPTIONS_TYPE){
                references = &((wxSystemOptions_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_LONG(wxSystemOptions::GetOptionInt(wxString(name0, wxConvUTF8)))\n\n");
                #endif

                WXPHP_RETVAL_LONG(wxSystemOptions::GetOptionInt(wxString(name0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxSystemOptions::GetOptionInt\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxSystemOptions::HasOption(string name)
   Returns true if the given option is present. */
PHP_METHOD(php_wxSystemOptions, HasOption)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxSystemOptions::HasOption\n");
    php_printf("===========================================\n");
    #endif

    zo_wxSystemOptions* current_object;
    wxphp_object_type current_object_type;
    wxSystemOptions_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxSystemOptions_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxSystemOptions::HasOption call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSYSTEMOPTIONS_TYPE){
                references = &((wxSystemOptions_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxSystemOptions::HasOption(wxString(name0, wxConvUTF8)))\n\n");
                #endif

                WXPHP_RETVAL_BOOL(wxSystemOptions::HasOption(wxString(name0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxSystemOptions::HasOption\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxSystemOptions::IsFalse(string name)
   Returns true if the option with the given name had been set to 0 value. */
PHP_METHOD(php_wxSystemOptions, IsFalse)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxSystemOptions::IsFalse\n");
    php_printf("===========================================\n");
    #endif

    zo_wxSystemOptions* current_object;
    wxphp_object_type current_object_type;
    wxSystemOptions_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxSystemOptions_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxSystemOptions::IsFalse call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSYSTEMOPTIONS_TYPE){
                references = &((wxSystemOptions_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxSystemOptions::IsFalse(wxString(name0, wxConvUTF8)))\n\n");
                #endif

                WXPHP_RETVAL_BOOL(wxSystemOptions::IsFalse(wxString(name0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxSystemOptions::IsFalse\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxSystemOptions::SetOption(string name, string value)
   Sets an option. */
PHP_METHOD(php_wxSystemOptions, SetOption)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxSystemOptions::SetOption\n");
    php_printf("===========================================\n");
    #endif

    zo_wxSystemOptions* current_object;
    wxphp_object_type current_object_type;
    wxSystemOptions_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxSystemOptions_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxSystemOptions::SetOption call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSYSTEMOPTIONS_TYPE){
                references = &((wxSystemOptions_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    char* value0;
    size_t value_len0;
    bool overload0_called = false;

    //Parameters for overload 1
    char* name1;
    size_t name_len1;
    long value1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ss' (&name0, &name_len0, &value0, &value_len0)\n");
        #endif

        char parse_parameters_string[] = "ss";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0, &value0, &value_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sl' (&name1, &name_len1, &value1)\n");
        #endif

        char parse_parameters_string[] = "sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name1, &name_len1, &value1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxSystemOptions::SetOption(wxString(name0, wxConvUTF8), wxString(value0, wxConvUTF8))\n\n");
                #endif

                wxSystemOptions::SetOption(wxString(name0, wxConvUTF8), wxString(value0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxSystemOptions::SetOption(wxString(name1, wxConvUTF8), (int) value1)\n\n");
                #endif

                wxSystemOptions::SetOption(wxString(name1, wxConvUTF8), (int) value1);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxSystemOptions::SetOption\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxVideoMode_free(zend_object *object)
{
    zo_wxVideoMode* custom_object = php_wxVideoMode_fetch_object(object);

    if (custom_object->is_user_initialized && (custom_object->native_object != NULL)) {
        custom_object->native_object->zo = NULL;
    }

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxVideoMode_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxVideoMode done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
}

wxVideoMode_php::~wxVideoMode_php()
{
    if (zo) {
        zo->native_object = NULL;
    }
}

zend_object* php_wxVideoMode_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxVideoMode_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxVideoMode* custom_object;

    custom_object = (zo_wxVideoMode*) ecalloc(
        1,
        sizeof(zo_wxVideoMode)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    memcpy(&wxphp_wxVideoMode_object_handlers, zend_get_std_object_handlers(), sizeof wxphp_wxVideoMode_object_handlers);
    wxphp_wxVideoMode_object_handlers.offset = XtOffsetOf(zo_wxVideoMode, zo);
    wxphp_wxVideoMode_object_handlers.free_obj = php_wxVideoMode_free;
    custom_object->zo.handlers = &wxphp_wxVideoMode_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXVIDEOMODE_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxVideoMode::wxVideoMode(int width, int height, int depth, int freq)
   Constructs this class using the given parameters. */
PHP_METHOD(php_wxVideoMode, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxVideoMode::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxVideoMode* current_object;
    wxVideoMode_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    long width0;
    long height0;
    long depth0;
    long freq0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|llll' (&width0, &height0, &depth0, &freq0)\n");
        #endif

        char parse_parameters_string[] = "|llll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &width0, &height0, &depth0, &freq0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxVideoMode_php();

                native_object->references.Initialize();
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) width0)\n");
                #endif

                native_object = new wxVideoMode_php((int) width0);

                native_object->references.Initialize();
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) width0, (int) height0)\n");
                #endif

                native_object = new wxVideoMode_php((int) width0, (int) height0);

                native_object->references.Initialize();
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) width0, (int) height0, (int) depth0)\n");
                #endif

                native_object = new wxVideoMode_php((int) width0, (int) height0, (int) depth0);

                native_object->references.Initialize();
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) width0, (int) height0, (int) depth0, (int) freq0)\n");
                #endif

                native_object = new wxVideoMode_php((int) width0, (int) height0, (int) depth0, (int) freq0);

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxVideoMode_P(getThis());

        current_object->native_object = native_object;
        native_object->zo = current_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxVideoMode::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto bool wxVideoMode::Matches(wxVideoMode other)
   Returns true if this mode matches the other one in the sense that all non zero fields of the other mode have the same value in this one (except for refresh which is allowed to have a greater value). */
PHP_METHOD(php_wxVideoMode, Matches)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxVideoMode::Matches\n");
    php_printf("===========================================\n");
    #endif

    zo_wxVideoMode* current_object;
    wxphp_object_type current_object_type;
    wxVideoMode_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxVideoMode_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxVideoMode::Matches call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXVIDEOMODE_TYPE){
                references = &((wxVideoMode_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* other0;
    wxVideoMode* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&other0, php_wxVideoMode_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &other0, php_wxVideoMode_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(other0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxVideoMode_P(other0)->object_type;
                    argument_native_object = (void*) Z_wxVideoMode_P(other0)->native_object;
                    object_pointer0_0 = (wxVideoMode*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'other' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(other0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'other' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxVideoMode::Matches(*(wxVideoMode*) object_pointer0_0))\n\n");
                #endif

                WXPHP_RETVAL_BOOL(((wxVideoMode_php*)native_object)->Matches(*(wxVideoMode*) object_pointer0_0));

                references->AddReference(other0, "wxVideoMode::Matches at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxVideoMode::Matches\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxVideoMode::IsOk()
   Returns true if the object has been initialized. */
PHP_METHOD(php_wxVideoMode, IsOk)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxVideoMode::IsOk\n");
    php_printf("===========================================\n");
    #endif

    zo_wxVideoMode* current_object;
    wxphp_object_type current_object_type;
    wxVideoMode_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxVideoMode_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxVideoMode::IsOk call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXVIDEOMODE_TYPE){
                references = &((wxVideoMode_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxVideoMode::IsOk())\n\n");
                #endif

                WXPHP_RETVAL_BOOL(((wxVideoMode_php*)native_object)->IsOk());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxVideoMode::IsOk\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxVideoMode::GetWidth()
   Returns the screen width in pixels (e.g. 640), 0 means unspecified. */
PHP_METHOD(php_wxVideoMode, GetWidth)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxVideoMode::GetWidth\n");
    php_printf("===========================================\n");
    #endif

    zo_wxVideoMode* current_object;
    wxphp_object_type current_object_type;
    wxVideoMode_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxVideoMode_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxVideoMode::GetWidth call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXVIDEOMODE_TYPE){
                references = &((wxVideoMode_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxVideoMode::GetWidth())\n\n");
                #endif

                WXPHP_RETVAL_LONG(((wxVideoMode_php*)native_object)->GetWidth());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxVideoMode::GetWidth\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxVideoMode::GetHeight()
   Returns the screen height in pixels (e.g. 480), 0 means unspecified. */
PHP_METHOD(php_wxVideoMode, GetHeight)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxVideoMode::GetHeight\n");
    php_printf("===========================================\n");
    #endif

    zo_wxVideoMode* current_object;
    wxphp_object_type current_object_type;
    wxVideoMode_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxVideoMode_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxVideoMode::GetHeight call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXVIDEOMODE_TYPE){
                references = &((wxVideoMode_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxVideoMode::GetHeight())\n\n");
                #endif

                WXPHP_RETVAL_LONG(((wxVideoMode_php*)native_object)->GetHeight());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxVideoMode::GetHeight\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxVideoMode::GetDepth()
   Returns bits per pixel (e.g. 32), 1 is monochrome and 0 means unspecified/known. */
PHP_METHOD(php_wxVideoMode, GetDepth)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxVideoMode::GetDepth\n");
    php_printf("===========================================\n");
    #endif

    zo_wxVideoMode* current_object;
    wxphp_object_type current_object_type;
    wxVideoMode_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxVideoMode_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxVideoMode::GetDepth call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXVIDEOMODE_TYPE){
                references = &((wxVideoMode_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxVideoMode::GetDepth())\n\n");
                #endif

                WXPHP_RETVAL_LONG(((wxVideoMode_php*)native_object)->GetDepth());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxVideoMode::GetDepth\n"
        );
    }
}
/* }}} */

