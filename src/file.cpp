/*
 * @author Mário Soares
 * @contributors Jefferson González
 * @contributors René Vögeli / Rangee GmbH
 * 
 * @license 
 * This file is part of wxPHP check the LICENSE file for information.
 * 
 * @note
 * This file was auto-generated by the wxPHP source maker
*/

#include "php_wxwidgets.h"
#include "appmanagement.h"
#include "cfg.h"
#include "bookctrl.h"
#include "dnd.h"
#include "cmndlg.h"
#include "containers.h"
#include "ctrl.h"
#include "data.h"
#include "dc.h"
#include "docview.h"
#include "events.h"
#include "file.h"
#include "gdi.h"
#include "grid.h"
#include "html.h"
#include "help.h"
#include "logging.h"
#include "managedwnd.h"
#include "menus.h"
#include "misc.h"
#include "miscwnd.h"
#include "media.h"
#include "net.h"
#include "pickers.h"
#include "printing.h"
#include "ribbon.h"
#include "richtext.h"
#include "rtti.h"
#include "stc.h"
#include "streams.h"
#include "threading.h"
#include "validator.h"
#include "vfs.h"
#include "aui.h"
#include "winlayout.h"
#include "xml.h"
#include "xrc.h"
#include "dvc.h"
#include "others.h"


BEGIN_EXTERN_C()
void php_wxFFile_free(void *object)
{
    zo_wxFFile* custom_object = (zo_wxFFile*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFFile_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxFFile done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxFFile_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFFile_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxFFile* custom_object;

    custom_object = (zo_wxFFile*) ecalloc(
        1,
        sizeof(zo_wxFFile)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxFFile_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFFILE_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxFFile::wxFFile() */
PHP_METHOD(php_wxFFile, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFFile::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFFile* current_object;
    wxFFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    char* filename1;
    size_t filename_len1;
    char* mode1;
    size_t mode_len1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|s' (&filename1, &filename_len1, &mode1, &mode_len1)\n");
        #endif

        char parse_parameters_string[] = "s|s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &filename1, &filename_len1, &mode1, &mode_len1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxFFile_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(filename1, wxConvUTF8))\n");
                #endif

                native_object = new wxFFile_php(wxString(filename1, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(filename1, wxConvUTF8), wxString(mode1, wxConvUTF8))\n");
                #endif

                native_object = new wxFFile_php(wxString(filename1, wxConvUTF8), wxString(mode1, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxFFile_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxFFile::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto int wxFFile::Write(void buffer, int count)
   Writes the specified number of bytes from a buffer. */
PHP_METHOD(php_wxFFile, Write)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFFile::Write\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFFile* current_object;
    wxphp_object_type current_object_type;
    wxFFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFFile::Write call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFFILE_TYPE){
                references = &((wxFFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* buffer0;
    size_t buffer_len0;
    long count0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sl' (&buffer0, &buffer_len0, &count0)\n");
        #endif

        char parse_parameters_string[] = "sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &buffer0, &buffer_len0, &count0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFFile::Write((const void*) buffer0, (size_t) count0))\n\n");
                #endif

                RETVAL_LONG(((wxFFile_php*)native_object)->Write((const void*) buffer0, (size_t) count0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFFile::Write\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxFFile::Tell()
   Returns the current position. */
PHP_METHOD(php_wxFFile, Tell)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFFile::Tell\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFFile* current_object;
    wxphp_object_type current_object_type;
    wxFFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFFile::Tell call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFFILE_TYPE){
                references = &((wxFFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFFile::Tell())\n\n");
                #endif

                RETVAL_LONG(((wxFFile_php*)native_object)->Tell());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFFile::Tell\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFFile::SeekEnd(int ofs)
   Moves the file pointer to the specified number of bytes before the end of the file and returns true on success. */
PHP_METHOD(php_wxFFile, SeekEnd)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFFile::SeekEnd\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFFile* current_object;
    wxphp_object_type current_object_type;
    wxFFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFFile::SeekEnd call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFFILE_TYPE){
                references = &((wxFFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long ofs0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&ofs0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &ofs0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFFile::SeekEnd())\n\n");
                #endif

                RETVAL_BOOL(((wxFFile_php*)native_object)->SeekEnd());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFFile::SeekEnd((wxFileOffset) ofs0))\n\n");
                #endif

                RETVAL_BOOL(((wxFFile_php*)native_object)->SeekEnd((wxFileOffset) ofs0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFFile::SeekEnd\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFFile::Seek(int ofs, wxSeekMode mode)
   Seeks to the specified position and returns true on success. */
PHP_METHOD(php_wxFFile, Seek)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFFile::Seek\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFFile* current_object;
    wxphp_object_type current_object_type;
    wxFFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFFile::Seek call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFFILE_TYPE){
                references = &((wxFFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long ofs0;
    long mode0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l|l' (&ofs0, &mode0)\n");
        #endif

        char parse_parameters_string[] = "l|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &ofs0, &mode0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFFile::Seek((wxFileOffset) ofs0))\n\n");
                #endif

                RETVAL_BOOL(((wxFFile_php*)native_object)->Seek((wxFileOffset) ofs0));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFFile::Seek((wxFileOffset) ofs0, (wxSeekMode) mode0))\n\n");
                #endif

                RETVAL_BOOL(((wxFFile_php*)native_object)->Seek((wxFileOffset) ofs0, (wxSeekMode) mode0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFFile::Seek\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxFFile::Read(void buffer, int count)
   Reads the specified number of bytes into a buffer, returning the actual number read. */
PHP_METHOD(php_wxFFile, Read)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFFile::Read\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFFile* current_object;
    wxphp_object_type current_object_type;
    wxFFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFFile::Read call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFFILE_TYPE){
                references = &((wxFFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* buffer0;
    size_t buffer_len0;
    zval buffer0_ref;
    long count0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sl' (&buffer0, &buffer_len0, &count0)\n");
        #endif

        char parse_parameters_string[] = "sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &buffer0, &buffer_len0, &count0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;

            char parse_references_string[] = "zz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, buffer0_ref, dummy );
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFFile::Read((void*) buffer0, (size_t) count0))\n\n");
                #endif

                RETVAL_LONG(((wxFFile_php*)native_object)->Read((void*) buffer0, (size_t) count0));

                ZVAL_STRING(&buffer0_ref, (char*) buffer0);

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFFile::Read\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFFile::Open(string filename, string mode)
   Opens the file, returning true if successful. */
PHP_METHOD(php_wxFFile, Open)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFFile::Open\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFFile* current_object;
    wxphp_object_type current_object_type;
    wxFFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFFile::Open call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFFILE_TYPE){
                references = &((wxFFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* filename0;
    size_t filename_len0;
    char* mode0;
    size_t mode_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|s' (&filename0, &filename_len0, &mode0, &mode_len0)\n");
        #endif

        char parse_parameters_string[] = "s|s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &filename0, &filename_len0, &mode0, &mode_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFFile::Open(wxString(filename0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxFFile_php*)native_object)->Open(wxString(filename0, wxConvUTF8)));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFFile::Open(wxString(filename0, wxConvUTF8), wxString(mode0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxFFile_php*)native_object)->Open(wxString(filename0, wxConvUTF8), wxString(mode0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFFile::Open\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxFFile::Length()
   Returns the length of the file. */
PHP_METHOD(php_wxFFile, Length)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFFile::Length\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFFile* current_object;
    wxphp_object_type current_object_type;
    wxFFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFFile::Length call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFFILE_TYPE){
                references = &((wxFFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFFile::Length())\n\n");
                #endif

                RETVAL_LONG(((wxFFile_php*)native_object)->Length());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFFile::Length\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFFile::IsOpened()
   Returns true if the file is opened. */
PHP_METHOD(php_wxFFile, IsOpened)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFFile::IsOpened\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFFile* current_object;
    wxphp_object_type current_object_type;
    wxFFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFFile::IsOpened call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFFILE_TYPE){
                references = &((wxFFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFFile::IsOpened())\n\n");
                #endif

                RETVAL_BOOL(((wxFFile_php*)native_object)->IsOpened());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFFile::IsOpened\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFileKind wxFFile::GetKind()
   Returns the type of the file. */
PHP_METHOD(php_wxFFile, GetKind)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFFile::GetKind\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFFile* current_object;
    wxphp_object_type current_object_type;
    wxFFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFFile::GetKind call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFFILE_TYPE){
                references = &((wxFFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFFile::GetKind())\n\n");
                #endif

                RETVAL_LONG(((wxFFile_php*)native_object)->GetKind());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFFile::GetKind\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFFile::Flush()
   Flushes the file and returns true on success. */
PHP_METHOD(php_wxFFile, Flush)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFFile::Flush\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFFile* current_object;
    wxphp_object_type current_object_type;
    wxFFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFFile::Flush call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFFILE_TYPE){
                references = &((wxFFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFFile::Flush())\n\n");
                #endif

                RETVAL_BOOL(((wxFFile_php*)native_object)->Flush());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFFile::Flush\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFFile::Error()
   Returns true if an error has occurred on this file, similar to the standard ferror() function. */
PHP_METHOD(php_wxFFile, Error)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFFile::Error\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFFile* current_object;
    wxphp_object_type current_object_type;
    wxFFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFFile::Error call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFFILE_TYPE){
                references = &((wxFFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFFile::Error())\n\n");
                #endif

                RETVAL_BOOL(((wxFFile_php*)native_object)->Error());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFFile::Error\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFFile::Eof()
   Returns true if an attempt has been made to read past the end of the file. */
PHP_METHOD(php_wxFFile, Eof)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFFile::Eof\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFFile* current_object;
    wxphp_object_type current_object_type;
    wxFFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFFile::Eof call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFFILE_TYPE){
                references = &((wxFFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFFile::Eof())\n\n");
                #endif

                RETVAL_BOOL(((wxFFile_php*)native_object)->Eof());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFFile::Eof\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFFile::Close()
   Closes the file and returns true on success. */
PHP_METHOD(php_wxFFile, Close)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFFile::Close\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFFile* current_object;
    wxphp_object_type current_object_type;
    wxFFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFFile::Close call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFFILE_TYPE){
                references = &((wxFFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFFile::Close())\n\n");
                #endif

                RETVAL_BOOL(((wxFFile_php*)native_object)->Close());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFFile::Close\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFile_free(void *object)
{
    zo_wxFile* custom_object = (zo_wxFile*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFile_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxFile done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxFile_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFile_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxFile* custom_object;

    custom_object = (zo_wxFile*) ecalloc(
        1,
        sizeof(zo_wxFile)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxFile_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFILE_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto int wxFile::Seek(int ofs, wxSeekMode mode)
   Seeks to the specified position. */
PHP_METHOD(php_wxFile, Seek)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFile::Seek\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFile* current_object;
    wxphp_object_type current_object_type;
    wxFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFile::Seek call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILE_TYPE){
                references = &((wxFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long ofs0;
    long mode0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l|l' (&ofs0, &mode0)\n");
        #endif

        char parse_parameters_string[] = "l|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &ofs0, &mode0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFile::Seek((wxFileOffset) ofs0))\n\n");
                #endif

                RETVAL_LONG(((wxFile_php*)native_object)->Seek((wxFileOffset) ofs0));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFile::Seek((wxFileOffset) ofs0, (wxSeekMode) mode0))\n\n");
                #endif

                RETVAL_LONG(((wxFile_php*)native_object)->Seek((wxFileOffset) ofs0, (wxSeekMode) mode0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFile::Seek\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxFile::SeekEnd(int ofs)
   Moves the file pointer to the specified number of bytes relative to the end of the file. */
PHP_METHOD(php_wxFile, SeekEnd)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFile::SeekEnd\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFile* current_object;
    wxphp_object_type current_object_type;
    wxFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFile::SeekEnd call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILE_TYPE){
                references = &((wxFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long ofs0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&ofs0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &ofs0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFile::SeekEnd())\n\n");
                #endif

                RETVAL_LONG(((wxFile_php*)native_object)->SeekEnd());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFile::SeekEnd((wxFileOffset) ofs0))\n\n");
                #endif

                RETVAL_LONG(((wxFile_php*)native_object)->SeekEnd((wxFileOffset) ofs0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFile::SeekEnd\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxFile::Tell()
   Returns the current position or wxInvalidOffset if file is not opened or if another error occurred. */
PHP_METHOD(php_wxFile, Tell)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFile::Tell\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFile* current_object;
    wxphp_object_type current_object_type;
    wxFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFile::Tell call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILE_TYPE){
                references = &((wxFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFile::Tell())\n\n");
                #endif

                RETVAL_LONG(((wxFile_php*)native_object)->Tell());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFile::Tell\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxFile::Write(void buffer, int count)
   Write data to the file (descriptor). */
PHP_METHOD(php_wxFile, Write)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFile::Write\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFile* current_object;
    wxphp_object_type current_object_type;
    wxFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFile::Write call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILE_TYPE){
                references = &((wxFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* buffer0;
    size_t buffer_len0;
    long count0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sl' (&buffer0, &buffer_len0, &count0)\n");
        #endif

        char parse_parameters_string[] = "sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &buffer0, &buffer_len0, &count0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFile::Write((const void*) buffer0, (size_t) count0))\n\n");
                #endif

                RETVAL_LONG(((wxFile_php*)native_object)->Write((const void*) buffer0, (size_t) count0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFile::Write\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxFile::fd()
   Returns the file descriptor associated with the file. */
PHP_METHOD(php_wxFile, fd)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFile::fd\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFile* current_object;
    wxphp_object_type current_object_type;
    wxFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFile::fd call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILE_TYPE){
                references = &((wxFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFile::fd())\n\n");
                #endif

                RETVAL_LONG(((wxFile_php*)native_object)->fd());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFile::fd\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFile::wxFile()
   Default constructor. */
PHP_METHOD(php_wxFile, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFile::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFile* current_object;
    wxFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    char* filename1;
    size_t filename_len1;
    long mode1;
    bool overload1_called = false;

    //Parameters for overload 2
    long fd2;
    bool overload2_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|l' (&filename1, &filename_len1, &mode1)\n");
        #endif

        char parse_parameters_string[] = "s|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &filename1, &filename_len1, &mode1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&fd2)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &fd2 ) == SUCCESS)
        {
            overload2_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxFile_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(filename1, wxConvUTF8))\n");
                #endif

                native_object = new wxFile_php(wxString(filename1, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(filename1, wxConvUTF8), (wxFile::OpenMode) mode1)\n");
                #endif

                native_object = new wxFile_php(wxString(filename1, wxConvUTF8), (wxFile::OpenMode) mode1);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((int) fd2)\n");
                #endif

                native_object = new wxFile_php((int) fd2);

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxFile_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxFile::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto bool wxFile::Open(string filename, wxFile::OpenMode mode, int access)
   Opens the file, returning true if successful. */
PHP_METHOD(php_wxFile, Open)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFile::Open\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFile* current_object;
    wxphp_object_type current_object_type;
    wxFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFile::Open call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILE_TYPE){
                references = &((wxFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* filename0;
    size_t filename_len0;
    long mode0;
    long access0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|ll' (&filename0, &filename_len0, &mode0, &access0)\n");
        #endif

        char parse_parameters_string[] = "s|ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &filename0, &filename_len0, &mode0, &access0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFile::Open(wxString(filename0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxFile_php*)native_object)->Open(wxString(filename0, wxConvUTF8)));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFile::Open(wxString(filename0, wxConvUTF8), (wxFile::OpenMode) mode0))\n\n");
                #endif

                RETVAL_BOOL(((wxFile_php*)native_object)->Open(wxString(filename0, wxConvUTF8), (wxFile::OpenMode) mode0));


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFile::Open(wxString(filename0, wxConvUTF8), (wxFile::OpenMode) mode0, (int) access0))\n\n");
                #endif

                RETVAL_BOOL(((wxFile_php*)native_object)->Open(wxString(filename0, wxConvUTF8), (wxFile::OpenMode) mode0, (int) access0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFile::Open\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxFile::Length()
   Returns the length of the file. */
PHP_METHOD(php_wxFile, Length)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFile::Length\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFile* current_object;
    wxphp_object_type current_object_type;
    wxFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFile::Length call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILE_TYPE){
                references = &((wxFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFile::Length())\n\n");
                #endif

                RETVAL_LONG(((wxFile_php*)native_object)->Length());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFile::Length\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFile::IsOpened()
   Returns true if the file has been opened. */
PHP_METHOD(php_wxFile, IsOpened)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFile::IsOpened\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFile* current_object;
    wxphp_object_type current_object_type;
    wxFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFile::IsOpened call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILE_TYPE){
                references = &((wxFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFile::IsOpened())\n\n");
                #endif

                RETVAL_BOOL(((wxFile_php*)native_object)->IsOpened());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFile::IsOpened\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxFile::GetLastError()
   Returns the error code for the last unsuccessful operation. */
PHP_METHOD(php_wxFile, GetLastError)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFile::GetLastError\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFile* current_object;
    wxphp_object_type current_object_type;
    wxFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFile::GetLastError call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILE_TYPE){
                references = &((wxFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFile::GetLastError())\n\n");
                #endif

                RETVAL_LONG(((wxFile_php*)native_object)->GetLastError());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFile::GetLastError\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFileKind wxFile::GetKind()
   Returns the type of the file. */
PHP_METHOD(php_wxFile, GetKind)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFile::GetKind\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFile* current_object;
    wxphp_object_type current_object_type;
    wxFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFile::GetKind call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILE_TYPE){
                references = &((wxFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFile::GetKind())\n\n");
                #endif

                RETVAL_LONG(((wxFile_php*)native_object)->GetKind());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFile::GetKind\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFile::Flush()
   Flushes the file descriptor. */
PHP_METHOD(php_wxFile, Flush)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFile::Flush\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFile* current_object;
    wxphp_object_type current_object_type;
    wxFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFile::Flush call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILE_TYPE){
                references = &((wxFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFile::Flush())\n\n");
                #endif

                RETVAL_BOOL(((wxFile_php*)native_object)->Flush());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFile::Flush\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFile::Exists(string filename)
   Returns true if the given name specifies an existing regular file (not a directory or a link). */
PHP_METHOD(php_wxFile, Exists)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFile::Exists\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFile* current_object;
    wxphp_object_type current_object_type;
    wxFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFile::Exists call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILE_TYPE){
                references = &((wxFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* filename0;
    size_t filename_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&filename0, &filename_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &filename0, &filename_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxFile::Exists(wxString(filename0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(wxFile::Exists(wxString(filename0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFile::Exists\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFile::Eof()
   Returns true if the end of the file has been reached. */
PHP_METHOD(php_wxFile, Eof)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFile::Eof\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFile* current_object;
    wxphp_object_type current_object_type;
    wxFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFile::Eof call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILE_TYPE){
                references = &((wxFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFile::Eof())\n\n");
                #endif

                RETVAL_BOOL(((wxFile_php*)native_object)->Eof());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFile::Eof\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFile::Create(string filename, bool overwrite, int access)
   Creates a file for writing. */
PHP_METHOD(php_wxFile, Create)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFile::Create\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFile* current_object;
    wxphp_object_type current_object_type;
    wxFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFile::Create call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILE_TYPE){
                references = &((wxFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* filename0;
    size_t filename_len0;
    bool overwrite0;
    long access0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|bl' (&filename0, &filename_len0, &overwrite0, &access0)\n");
        #endif

        char parse_parameters_string[] = "s|bl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &filename0, &filename_len0, &overwrite0, &access0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFile::Create(wxString(filename0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxFile_php*)native_object)->Create(wxString(filename0, wxConvUTF8)));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFile::Create(wxString(filename0, wxConvUTF8), overwrite0))\n\n");
                #endif

                RETVAL_BOOL(((wxFile_php*)native_object)->Create(wxString(filename0, wxConvUTF8), overwrite0));


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFile::Create(wxString(filename0, wxConvUTF8), overwrite0, (int) access0))\n\n");
                #endif

                RETVAL_BOOL(((wxFile_php*)native_object)->Create(wxString(filename0, wxConvUTF8), overwrite0, (int) access0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFile::Create\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFile::Close()
   Closes the file. */
PHP_METHOD(php_wxFile, Close)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFile::Close\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFile* current_object;
    wxphp_object_type current_object_type;
    wxFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFile::Close call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILE_TYPE){
                references = &((wxFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFile::Close())\n\n");
                #endif

                RETVAL_BOOL(((wxFile_php*)native_object)->Close());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFile::Close\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFile::ClearLastError()
   Resets the error code. */
PHP_METHOD(php_wxFile, ClearLastError)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFile::ClearLastError\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFile* current_object;
    wxphp_object_type current_object_type;
    wxFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFile::ClearLastError call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILE_TYPE){
                references = &((wxFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFile::ClearLastError()\n\n");
                #endif

                ((wxFile_php*)native_object)->ClearLastError();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFile::ClearLastError\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFile::Attach(int fd)
   Attaches an existing file descriptor to the wxFile object. */
PHP_METHOD(php_wxFile, Attach)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFile::Attach\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFile* current_object;
    wxphp_object_type current_object_type;
    wxFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFile::Attach call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILE_TYPE){
                references = &((wxFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long fd0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&fd0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &fd0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFile::Attach((int) fd0)\n\n");
                #endif

                ((wxFile_php*)native_object)->Attach((int) fd0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFile::Attach\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxFile::Detach()
   Get back a file descriptor from wxFile object - the caller is responsible for closing the file if this descriptor is opened. */
PHP_METHOD(php_wxFile, Detach)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFile::Detach\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFile* current_object;
    wxphp_object_type current_object_type;
    wxFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFile::Detach call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILE_TYPE){
                references = &((wxFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFile::Detach())\n\n");
                #endif

                RETVAL_LONG(((wxFile_php*)native_object)->Detach());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFile::Detach\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFile::Access(string name, wxFile::OpenMode mode)
   This function verifies if we may access the given file in specified mode. */
PHP_METHOD(php_wxFile, Access)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFile::Access\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFile* current_object;
    wxphp_object_type current_object_type;
    wxFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFile::Access call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILE_TYPE){
                references = &((wxFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    long mode0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sl' (&name0, &name_len0, &mode0)\n");
        #endif

        char parse_parameters_string[] = "sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0, &mode0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxFile::Access(wxString(name0, wxConvUTF8), (wxFile::OpenMode) mode0))\n\n");
                #endif

                RETVAL_BOOL(wxFile::Access(wxString(name0, wxConvUTF8), (wxFile::OpenMode) mode0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFile::Access\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxPathList_free(void *object)
{
    zo_wxPathList* custom_object = (zo_wxPathList*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxPathList_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxPathList done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxPathList_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxPathList_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxPathList* custom_object;

    custom_object = (zo_wxPathList*) ecalloc(
        1,
        sizeof(zo_wxPathList)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxPathList_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXPATHLIST_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto bool wxPathList::Add(string path)
   Adds the given directory to the path list, if the path is not already in the list. */
PHP_METHOD(php_wxPathList, Add)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPathList::Add\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPathList* current_object;
    wxphp_object_type current_object_type;
    wxPathList_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPathList_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPathList::Add call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPATHLIST_TYPE){
                references = &((wxPathList_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* path0;
    size_t path_len0;
    bool overload0_called = false;

    //Parameters for overload 1
    zval* arr1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&path0, &path_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &path0, &path_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'a' (&arr1)\n");
        #endif

        char parse_parameters_string[] = "a";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &arr1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxPathList::Add(wxString(path0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxPathList_php*)native_object)->Add(wxString(path0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        wxArrayString strings_array1_0;
        bool strings_continue1_0 = true;

        switch(arguments_received)
        {
            case 1:
            {
                int array_index1_0 = 0;
                zval* temp_array_value1_0 = 0;
                while(strings_continue1_0)
                {
                    if((temp_array_value1_0 = zend_hash_index_find(HASH_OF(arr1), array_index1_0)) != NULL)
                    {
                        convert_to_string(temp_array_value1_0);
                        strings_array1_0.Add(wxString(Z_STRVAL_P(temp_array_value1_0), wxConvUTF8));
                        array_index1_0++;
                    }
                    else
                    {
                        strings_continue1_0 = false;
                    }
                }
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPathList::Add(strings_array1_0)\n\n");
                #endif

                ((wxPathList_php*)native_object)->Add(strings_array1_0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPathList::Add\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPathList::AddEnvList(string env_variable)
   Finds the value of the given environment variable, and adds all paths to the path list. */
PHP_METHOD(php_wxPathList, AddEnvList)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPathList::AddEnvList\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPathList* current_object;
    wxphp_object_type current_object_type;
    wxPathList_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPathList_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPathList::AddEnvList call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPATHLIST_TYPE){
                references = &((wxPathList_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* env_variable0;
    size_t env_variable_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&env_variable0, &env_variable_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &env_variable0, &env_variable_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxPathList::AddEnvList(wxString(env_variable0, wxConvUTF8))\n\n");
                #endif

                ((wxPathList_php*)native_object)->AddEnvList(wxString(env_variable0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPathList::AddEnvList\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxPathList::EnsureFileAccessible(string filename)
   Given a full filename (with path), calls Add() with the path of the file. */
PHP_METHOD(php_wxPathList, EnsureFileAccessible)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPathList::EnsureFileAccessible\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPathList* current_object;
    wxphp_object_type current_object_type;
    wxPathList_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPathList_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPathList::EnsureFileAccessible call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPATHLIST_TYPE){
                references = &((wxPathList_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* filename0;
    size_t filename_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&filename0, &filename_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &filename0, &filename_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxPathList::EnsureFileAccessible(wxString(filename0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxPathList_php*)native_object)->EnsureFileAccessible(wxString(filename0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPathList::EnsureFileAccessible\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxPathList::FindAbsoluteValidPath(string file)
   Like FindValidPath() but this function always returns an absolute path (eventually prepending the current working directory to the value returned wxPathList::FindValidPath()) or an empty string. */
PHP_METHOD(php_wxPathList, FindAbsoluteValidPath)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPathList::FindAbsoluteValidPath\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPathList* current_object;
    wxphp_object_type current_object_type;
    wxPathList_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPathList_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPathList::FindAbsoluteValidPath call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPATHLIST_TYPE){
                references = &((wxPathList_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* file0;
    size_t file_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&file0, &file_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &file0, &file_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxPathList::FindAbsoluteValidPath(wxString(file0, wxConvUTF8)).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = ((wxPathList_php*)native_object)->FindAbsoluteValidPath(wxString(file0, wxConvUTF8));
                RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPathList::FindAbsoluteValidPath\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxPathList::FindValidPath(string file)
   Searches the given file in all paths stored in this class. */
PHP_METHOD(php_wxPathList, FindValidPath)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPathList::FindValidPath\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPathList* current_object;
    wxphp_object_type current_object_type;
    wxPathList_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxPathList_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxPathList::FindValidPath call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXPATHLIST_TYPE){
                references = &((wxPathList_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* file0;
    size_t file_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&file0, &file_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &file0, &file_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxPathList::FindValidPath(wxString(file0, wxConvUTF8)).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = ((wxPathList_php*)native_object)->FindValidPath(wxString(file0, wxConvUTF8));
                RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxPathList::FindValidPath\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxPathList::wxPathList()
   Standard constructor. */
PHP_METHOD(php_wxPathList, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxPathList::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxPathList* current_object;
    wxPathList_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    zval* arr1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'a' (&arr1)\n");
        #endif

        char parse_parameters_string[] = "a";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &arr1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxPathList_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        wxArrayString strings_array1_0;
        bool strings_continue1_0 = true;

        switch(arguments_received)
        {
            case 1:
            {
                int array_index1_0 = 0;
                zval* temp_array_value1_0 = 0;
                while(strings_continue1_0)
                {
                    if((temp_array_value1_0 = zend_hash_index_find(HASH_OF(arr1), array_index1_0)) != NULL)
                    {
                        convert_to_string(temp_array_value1_0);
                        strings_array1_0.Add(wxString(Z_STRVAL_P(temp_array_value1_0), wxConvUTF8));
                        array_index1_0++;
                    }
                    else
                    {
                        strings_continue1_0 = false;
                    }
                }
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(strings_array1_0)\n");
                #endif

                native_object = new wxPathList_php(strings_array1_0);

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxPathList_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxPathList::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFileName_free(void *object)
{
    zo_wxFileName* custom_object = (zo_wxFileName*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFileName_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxFileName done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxFileName_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFileName_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* custom_object;

    custom_object = (zo_wxFileName*) ecalloc(
        1,
        sizeof(zo_wxFileName)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxFileName_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFILENAME_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto bool wxFileName::AppendDir(string dir)
   Appends a directory component to the path. */
PHP_METHOD(php_wxFileName, AppendDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::AppendDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::AppendDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* dir0;
    size_t dir_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&dir0, &dir_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &dir0, &dir_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::AppendDir(wxString(dir0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->AppendDir(wxString(dir0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::AppendDir\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::InsertDir(int before, string dir)
   Inserts a directory component before the zero-based position in the directory list. */
PHP_METHOD(php_wxFileName, InsertDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::InsertDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::InsertDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long before0;
    char* dir0;
    size_t dir_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ls' (&before0, &dir0, &dir_len0)\n");
        #endif

        char parse_parameters_string[] = "ls";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &before0, &dir0, &dir_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::InsertDir((size_t) before0, wxString(dir0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->InsertDir((size_t) before0, wxString(dir0, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::InsertDir\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileName::Assign(wxFileName filepath)
   Creates the file name from another filename object. */
PHP_METHOD(php_wxFileName, Assign)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::Assign\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::Assign call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* filepath0;
    wxFileName* object_pointer0_0 = 0;
    bool overload0_called = false;

    //Parameters for overload 1
    char* fullpath1;
    size_t fullpath_len1;
    long format1;
    bool overload1_called = false;

    //Parameters for overload 2
    char* volume2;
    size_t volume_len2;
    char* path2;
    size_t path_len2;
    char* name2;
    size_t name_len2;
    char* ext2;
    size_t ext_len2;
    bool hasExt2;
    long format2;
    bool overload2_called = false;

    //Parameters for overload 3
    char* volume3;
    size_t volume_len3;
    char* path3;
    size_t path_len3;
    char* name3;
    size_t name_len3;
    char* ext3;
    size_t ext_len3;
    long format3;
    bool overload3_called = false;

    //Parameters for overload 4
    char* path4;
    size_t path_len4;
    char* name4;
    size_t name_len4;
    long format4;
    bool overload4_called = false;

    //Parameters for overload 5
    char* path5;
    size_t path_len5;
    char* name5;
    size_t name_len5;
    char* ext5;
    size_t ext_len5;
    long format5;
    bool overload5_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&filepath0, php_wxFileName_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &filepath0, php_wxFileName_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(filepath0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxFileName_P(filepath0)->object_type;
                    argument_native_object = (void*) Z_wxFileName_P(filepath0)->native_object;
                    object_pointer0_0 = (wxFileName*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        goto overload1;
                    }
                }
                else if(Z_TYPE_P(filepath0) != IS_NULL)
                {
                    goto overload1;
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|l' (&fullpath1, &fullpath_len1, &format1)\n");
        #endif

        char parse_parameters_string[] = "s|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &fullpath1, &fullpath_len1, &format1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received >= 5  && arguments_received <= 6)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ssssb|l' (&volume2, &volume_len2, &path2, &path_len2, &name2, &name_len2, &ext2, &ext_len2, &hasExt2, &format2)\n");
        #endif

        char parse_parameters_string[] = "ssssb|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &volume2, &volume_len2, &path2, &path_len2, &name2, &name_len2, &ext2, &ext_len2, &hasExt2, &format2 ) == SUCCESS)
        {
            overload2_called = true;
            already_called = true;
        }
    }

    //Overload 3
    overload3:
    if(!already_called && arguments_received >= 4  && arguments_received <= 5)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ssss|l' (&volume3, &volume_len3, &path3, &path_len3, &name3, &name_len3, &ext3, &ext_len3, &format3)\n");
        #endif

        char parse_parameters_string[] = "ssss|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &volume3, &volume_len3, &path3, &path_len3, &name3, &name_len3, &ext3, &ext_len3, &format3 ) == SUCCESS)
        {
            overload3_called = true;
            already_called = true;
        }
    }

    //Overload 4
    overload4:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ss|l' (&path4, &path_len4, &name4, &name_len4, &format4)\n");
        #endif

        char parse_parameters_string[] = "ss|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &path4, &path_len4, &name4, &name_len4, &format4 ) == SUCCESS)
        {
            overload4_called = true;
            already_called = true;
        }
    }

    //Overload 5
    overload5:
    if(!already_called && arguments_received >= 3  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sss|l' (&path5, &path_len5, &name5, &name_len5, &ext5, &ext_len5, &format5)\n");
        #endif

        char parse_parameters_string[] = "sss|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &path5, &path_len5, &name5, &name_len5, &ext5, &ext_len5, &format5 ) == SUCCESS)
        {
            overload5_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::Assign(*(wxFileName*) object_pointer0_0)\n\n");
                #endif

                ((wxFileName_php*)native_object)->Assign(*(wxFileName*) object_pointer0_0);

                references->AddReference(filepath0, "wxFileName::Assign at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::Assign(wxString(fullpath1, wxConvUTF8))\n\n");
                #endif

                ((wxFileName_php*)native_object)->Assign(wxString(fullpath1, wxConvUTF8));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::Assign(wxString(fullpath1, wxConvUTF8), (wxPathFormat) format1)\n\n");
                #endif

                ((wxFileName_php*)native_object)->Assign(wxString(fullpath1, wxConvUTF8), (wxPathFormat) format1);


                return;
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::Assign(wxString(volume2, wxConvUTF8), wxString(path2, wxConvUTF8), wxString(name2, wxConvUTF8), wxString(ext2, wxConvUTF8), hasExt2)\n\n");
                #endif

                ((wxFileName_php*)native_object)->Assign(wxString(volume2, wxConvUTF8), wxString(path2, wxConvUTF8), wxString(name2, wxConvUTF8), wxString(ext2, wxConvUTF8), hasExt2);


                return;
                break;
            }
            case 6:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::Assign(wxString(volume2, wxConvUTF8), wxString(path2, wxConvUTF8), wxString(name2, wxConvUTF8), wxString(ext2, wxConvUTF8), hasExt2, (wxPathFormat) format2)\n\n");
                #endif

                ((wxFileName_php*)native_object)->Assign(wxString(volume2, wxConvUTF8), wxString(path2, wxConvUTF8), wxString(name2, wxConvUTF8), wxString(ext2, wxConvUTF8), hasExt2, (wxPathFormat) format2);


                return;
                break;
            }
        }
    }

    if(overload3_called)
    {
        switch(arguments_received)
        {
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::Assign(wxString(volume3, wxConvUTF8), wxString(path3, wxConvUTF8), wxString(name3, wxConvUTF8), wxString(ext3, wxConvUTF8))\n\n");
                #endif

                ((wxFileName_php*)native_object)->Assign(wxString(volume3, wxConvUTF8), wxString(path3, wxConvUTF8), wxString(name3, wxConvUTF8), wxString(ext3, wxConvUTF8));


                return;
                break;
            }
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::Assign(wxString(volume3, wxConvUTF8), wxString(path3, wxConvUTF8), wxString(name3, wxConvUTF8), wxString(ext3, wxConvUTF8), (wxPathFormat) format3)\n\n");
                #endif

                ((wxFileName_php*)native_object)->Assign(wxString(volume3, wxConvUTF8), wxString(path3, wxConvUTF8), wxString(name3, wxConvUTF8), wxString(ext3, wxConvUTF8), (wxPathFormat) format3);


                return;
                break;
            }
        }
    }

    if(overload4_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::Assign(wxString(path4, wxConvUTF8), wxString(name4, wxConvUTF8))\n\n");
                #endif

                ((wxFileName_php*)native_object)->Assign(wxString(path4, wxConvUTF8), wxString(name4, wxConvUTF8));


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::Assign(wxString(path4, wxConvUTF8), wxString(name4, wxConvUTF8), (wxPathFormat) format4)\n\n");
                #endif

                ((wxFileName_php*)native_object)->Assign(wxString(path4, wxConvUTF8), wxString(name4, wxConvUTF8), (wxPathFormat) format4);


                return;
                break;
            }
        }
    }

    if(overload5_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::Assign(wxString(path5, wxConvUTF8), wxString(name5, wxConvUTF8), wxString(ext5, wxConvUTF8))\n\n");
                #endif

                ((wxFileName_php*)native_object)->Assign(wxString(path5, wxConvUTF8), wxString(name5, wxConvUTF8), wxString(ext5, wxConvUTF8));


                return;
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::Assign(wxString(path5, wxConvUTF8), wxString(name5, wxConvUTF8), wxString(ext5, wxConvUTF8), (wxPathFormat) format5)\n\n");
                #endif

                ((wxFileName_php*)native_object)->Assign(wxString(path5, wxConvUTF8), wxString(name5, wxConvUTF8), wxString(ext5, wxConvUTF8), (wxPathFormat) format5);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::Assign\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileName::wxFileName()
   Default constructor. */
PHP_METHOD(php_wxFileName, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    zval* filename1;
    wxFileName* object_pointer1_0 = 0;
    bool overload1_called = false;

    //Parameters for overload 2
    char* fullpath2;
    size_t fullpath_len2;
    long format2;
    bool overload2_called = false;

    //Parameters for overload 3
    char* path3;
    size_t path_len3;
    char* name3;
    size_t name_len3;
    long format3;
    bool overload3_called = false;

    //Parameters for overload 4
    char* path4;
    size_t path_len4;
    char* name4;
    size_t name_len4;
    char* ext4;
    size_t ext_len4;
    long format4;
    bool overload4_called = false;

    //Parameters for overload 5
    char* volume5;
    size_t volume_len5;
    char* path5;
    size_t path_len5;
    char* name5;
    size_t name_len5;
    char* ext5;
    size_t ext_len5;
    long format5;
    bool overload5_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&filename1, php_wxFileName_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &filename1, php_wxFileName_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(filename1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxFileName_P(filename1)->object_type;
                    argument_native_object = (void*) Z_wxFileName_P(filename1)->native_object;
                    object_pointer1_0 = (wxFileName*) argument_native_object;
                    if (!object_pointer1_0 )
                    {
                        goto overload2;
                    }
                }
                else if(Z_TYPE_P(filename1) != IS_NULL)
                {
                    goto overload2;
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|l' (&fullpath2, &fullpath_len2, &format2)\n");
        #endif

        char parse_parameters_string[] = "s|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &fullpath2, &fullpath_len2, &format2 ) == SUCCESS)
        {
            overload2_called = true;
            already_called = true;
        }
    }

    //Overload 3
    overload3:
    if(!already_called && arguments_received >= 2  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ss|l' (&path3, &path_len3, &name3, &name_len3, &format3)\n");
        #endif

        char parse_parameters_string[] = "ss|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &path3, &path_len3, &name3, &name_len3, &format3 ) == SUCCESS)
        {
            overload3_called = true;
            already_called = true;
        }
    }

    //Overload 4
    overload4:
    if(!already_called && arguments_received >= 3  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sss|l' (&path4, &path_len4, &name4, &name_len4, &ext4, &ext_len4, &format4)\n");
        #endif

        char parse_parameters_string[] = "sss|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &path4, &path_len4, &name4, &name_len4, &ext4, &ext_len4, &format4 ) == SUCCESS)
        {
            overload4_called = true;
            already_called = true;
        }
    }

    //Overload 5
    overload5:
    if(!already_called && arguments_received >= 4  && arguments_received <= 5)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ssss|l' (&volume5, &volume_len5, &path5, &path_len5, &name5, &name_len5, &ext5, &ext_len5, &format5)\n");
        #endif

        char parse_parameters_string[] = "ssss|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &volume5, &volume_len5, &path5, &path_len5, &name5, &name_len5, &ext5, &ext_len5, &format5 ) == SUCCESS)
        {
            overload5_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxFileName_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(*(wxFileName*) object_pointer1_0)\n");
                #endif

                native_object = new wxFileName_php(*(wxFileName*) object_pointer1_0);

                native_object->references.Initialize();
                ((wxFileName_php*) native_object)->references.AddReference(filename1, "wxFileName::wxFileName at call 4 with 1 argument(s)");
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(fullpath2, wxConvUTF8))\n");
                #endif

                native_object = new wxFileName_php(wxString(fullpath2, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(fullpath2, wxConvUTF8), (wxPathFormat) format2)\n");
                #endif

                native_object = new wxFileName_php(wxString(fullpath2, wxConvUTF8), (wxPathFormat) format2);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload3_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(path3, wxConvUTF8), wxString(name3, wxConvUTF8))\n");
                #endif

                native_object = new wxFileName_php(wxString(path3, wxConvUTF8), wxString(name3, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(path3, wxConvUTF8), wxString(name3, wxConvUTF8), (wxPathFormat) format3)\n");
                #endif

                native_object = new wxFileName_php(wxString(path3, wxConvUTF8), wxString(name3, wxConvUTF8), (wxPathFormat) format3);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload4_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(path4, wxConvUTF8), wxString(name4, wxConvUTF8), wxString(ext4, wxConvUTF8))\n");
                #endif

                native_object = new wxFileName_php(wxString(path4, wxConvUTF8), wxString(name4, wxConvUTF8), wxString(ext4, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(path4, wxConvUTF8), wxString(name4, wxConvUTF8), wxString(ext4, wxConvUTF8), (wxPathFormat) format4)\n");
                #endif

                native_object = new wxFileName_php(wxString(path4, wxConvUTF8), wxString(name4, wxConvUTF8), wxString(ext4, wxConvUTF8), (wxPathFormat) format4);

                native_object->references.Initialize();
                break;
            }
        }
    }

    if(overload5_called)
    {
        switch(arguments_received)
        {
            case 4:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(volume5, wxConvUTF8), wxString(path5, wxConvUTF8), wxString(name5, wxConvUTF8), wxString(ext5, wxConvUTF8))\n");
                #endif

                native_object = new wxFileName_php(wxString(volume5, wxConvUTF8), wxString(path5, wxConvUTF8), wxString(name5, wxConvUTF8), wxString(ext5, wxConvUTF8));

                native_object->references.Initialize();
                break;
            }
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct(wxString(volume5, wxConvUTF8), wxString(path5, wxConvUTF8), wxString(name5, wxConvUTF8), wxString(ext5, wxConvUTF8), (wxPathFormat) format5)\n");
                #endif

                native_object = new wxFileName_php(wxString(volume5, wxConvUTF8), wxString(path5, wxConvUTF8), wxString(name5, wxConvUTF8), wxString(ext5, wxConvUTF8), (wxPathFormat) format5);

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxFileName_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxFileName::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto bool wxFileName::Touch()
   Sets the access and modification times to the current moment. */
PHP_METHOD(php_wxFileName, Touch)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::Touch\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::Touch call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::Touch())\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->Touch());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::Touch\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileName::StripExtension(string fullname)
   Strip the file extension. */
PHP_METHOD(php_wxFileName, StripExtension)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::StripExtension\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::StripExtension call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* fullname0;
    size_t fullname_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&fullname0, &fullname_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &fullname0, &fullname_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileName::StripExtension(wxString(fullname0, wxConvUTF8)).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = wxFileName::StripExtension(wxString(fullname0, wxConvUTF8));
                RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::StripExtension\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileName::SplitVolume(string fullpath, string &volume, string &path, wxPathFormat format)
   Splits the given fullpath into the volume part (which may be empty) and the pure path part, not containing any volume. */
PHP_METHOD(php_wxFileName, SplitVolume)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::SplitVolume\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::SplitVolume call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* fullpath0;
    size_t fullpath_len0;
    char* volume0;
    size_t volume_len0;
    zval volume0_ref;
    char* path0;
    size_t path_len0;
    zval path0_ref;
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 3  && arguments_received <= 4)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sss|l' (&fullpath0, &fullpath_len0, &volume0, &volume_len0, &path0, &path_len0, &format0)\n");
        #endif

        char parse_parameters_string[] = "sss|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &fullpath0, &fullpath_len0, &volume0, &volume_len0, &path0, &path_len0, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;

            char parse_references_string[] = "zzz|z";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, volume0_ref, path0_ref, dummy );
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 3:
            {
                wxString string_arg0_1 = wxString(volume0, wxConvUTF8);
                wxString string_arg0_2 = wxString(path0, wxConvUTF8);
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFileName::SplitVolume(wxString(fullpath0, wxConvUTF8), &string_arg0_1, &string_arg0_2)\n\n");
                #endif

                wxFileName::SplitVolume(wxString(fullpath0, wxConvUTF8), &string_arg0_1, &string_arg0_2);

                ZVAL_STRING(&volume0_ref, string_arg0_1.ToUTF8().data());
                ZVAL_STRING(&path0_ref, string_arg0_2.ToUTF8().data());

                return;
                break;
            }
            case 4:
            {
                wxString string_arg0_1 = wxString(volume0, wxConvUTF8);
                wxString string_arg0_2 = wxString(path0, wxConvUTF8);
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFileName::SplitVolume(wxString(fullpath0, wxConvUTF8), &string_arg0_1, &string_arg0_2, (wxPathFormat) format0)\n\n");
                #endif

                wxFileName::SplitVolume(wxString(fullpath0, wxConvUTF8), &string_arg0_1, &string_arg0_2, (wxPathFormat) format0);

                ZVAL_STRING(&volume0_ref, string_arg0_1.ToUTF8().data());
                ZVAL_STRING(&path0_ref, string_arg0_2.ToUTF8().data());

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::SplitVolume\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileName::SplitPath(string fullpath, string &volume, string &path, string &name, string &ext, bool &hasExt, wxPathFormat format)
   This function splits a full file name into components: the volume (with the first version) path (including the volume in the second version), the base name and the extension. */
PHP_METHOD(php_wxFileName, SplitPath)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::SplitPath\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::SplitPath call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* fullpath0;
    size_t fullpath_len0;
    char* volume0;
    size_t volume_len0;
    zval volume0_ref;
    char* path0;
    size_t path_len0;
    zval path0_ref;
    char* name0;
    size_t name_len0;
    zval name0_ref;
    char* ext0;
    size_t ext_len0;
    zval ext0_ref;
    bool* hasExt0;
    zval hasExt0_ref;
    long format0;
    bool overload0_called = false;

    //Parameters for overload 1
    char* fullpath1;
    size_t fullpath_len1;
    char* volume1;
    size_t volume_len1;
    zval volume1_ref;
    char* path1;
    size_t path_len1;
    zval path1_ref;
    char* name1;
    size_t name_len1;
    zval name1_ref;
    char* ext1;
    size_t ext_len1;
    zval ext1_ref;
    long format1;
    bool overload1_called = false;

    //Parameters for overload 2
    char* fullpath2;
    size_t fullpath_len2;
    char* path2;
    size_t path_len2;
    zval path2_ref;
    char* name2;
    size_t name_len2;
    zval name2_ref;
    char* ext2;
    size_t ext_len2;
    zval ext2_ref;
    long format2;
    bool overload2_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 5  && arguments_received <= 7)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sssss|bl' (&fullpath0, &fullpath_len0, &volume0, &volume_len0, &path0, &path_len0, &name0, &name_len0, &ext0, &ext_len0, hasExt0, &format0)\n");
        #endif

        char parse_parameters_string[] = "sssss|bl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &fullpath0, &fullpath_len0, &volume0, &volume_len0, &path0, &path_len0, &name0, &name_len0, &ext0, &ext_len0, hasExt0, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;

            char parse_references_string[] = "zzzzz|zz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, volume0_ref, path0_ref, name0_ref, ext0_ref, hasExt0_ref, dummy );
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 6)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sssssl' (&fullpath1, &fullpath_len1, &volume1, &volume_len1, &path1, &path_len1, &name1, &name_len1, &ext1, &ext_len1, &format1)\n");
        #endif

        char parse_parameters_string[] = "sssssl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &fullpath1, &fullpath_len1, &volume1, &volume_len1, &path1, &path_len1, &name1, &name_len1, &ext1, &ext_len1, &format1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;

            char parse_references_string[] = "zzzzzz";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, volume1_ref, path1_ref, name1_ref, ext1_ref, dummy );
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received >= 4  && arguments_received <= 5)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'ssss|l' (&fullpath2, &fullpath_len2, &path2, &path_len2, &name2, &name_len2, &ext2, &ext_len2, &format2)\n");
        #endif

        char parse_parameters_string[] = "ssss|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &fullpath2, &fullpath_len2, &path2, &path_len2, &name2, &name_len2, &ext2, &ext_len2, &format2 ) == SUCCESS)
        {
            overload2_called = true;
            already_called = true;

            char parse_references_string[] = "zzzz|z";
            zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_references_string, dummy, path2_ref, name2_ref, ext2_ref, dummy );
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 5:
            {
                wxString string_arg0_1 = wxString(volume0, wxConvUTF8);
                wxString string_arg0_2 = wxString(path0, wxConvUTF8);
                wxString string_arg0_3 = wxString(name0, wxConvUTF8);
                wxString string_arg0_4 = wxString(ext0, wxConvUTF8);
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFileName::SplitPath(wxString(fullpath0, wxConvUTF8), &string_arg0_1, &string_arg0_2, &string_arg0_3, &string_arg0_4)\n\n");
                #endif

                wxFileName::SplitPath(wxString(fullpath0, wxConvUTF8), &string_arg0_1, &string_arg0_2, &string_arg0_3, &string_arg0_4);

                ZVAL_STRING(&volume0_ref, string_arg0_1.ToUTF8().data());
                ZVAL_STRING(&path0_ref, string_arg0_2.ToUTF8().data());
                ZVAL_STRING(&name0_ref, string_arg0_3.ToUTF8().data());
                ZVAL_STRING(&ext0_ref, string_arg0_4.ToUTF8().data());

                return;
                break;
            }
            case 6:
            {
                wxString string_arg0_1 = wxString(volume0, wxConvUTF8);
                wxString string_arg0_2 = wxString(path0, wxConvUTF8);
                wxString string_arg0_3 = wxString(name0, wxConvUTF8);
                wxString string_arg0_4 = wxString(ext0, wxConvUTF8);
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFileName::SplitPath(wxString(fullpath0, wxConvUTF8), &string_arg0_1, &string_arg0_2, &string_arg0_3, &string_arg0_4, hasExt0)\n\n");
                #endif

                wxFileName::SplitPath(wxString(fullpath0, wxConvUTF8), &string_arg0_1, &string_arg0_2, &string_arg0_3, &string_arg0_4, hasExt0);

                ZVAL_STRING(&volume0_ref, string_arg0_1.ToUTF8().data());
                ZVAL_STRING(&path0_ref, string_arg0_2.ToUTF8().data());
                ZVAL_STRING(&name0_ref, string_arg0_3.ToUTF8().data());
                ZVAL_STRING(&ext0_ref, string_arg0_4.ToUTF8().data());
                size_t elements_returned0_5 = sizeof(hasExt0)/sizeof(*hasExt0);
                array_init(&hasExt0_ref);
                for(size_t i=0; i<elements_returned0_5; i++)
                {
                    add_next_index_long(&hasExt0_ref, hasExt0[i]);
                }

                return;
                break;
            }
            case 7:
            {
                wxString string_arg0_1 = wxString(volume0, wxConvUTF8);
                wxString string_arg0_2 = wxString(path0, wxConvUTF8);
                wxString string_arg0_3 = wxString(name0, wxConvUTF8);
                wxString string_arg0_4 = wxString(ext0, wxConvUTF8);
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFileName::SplitPath(wxString(fullpath0, wxConvUTF8), &string_arg0_1, &string_arg0_2, &string_arg0_3, &string_arg0_4, hasExt0, (wxPathFormat) format0)\n\n");
                #endif

                wxFileName::SplitPath(wxString(fullpath0, wxConvUTF8), &string_arg0_1, &string_arg0_2, &string_arg0_3, &string_arg0_4, hasExt0, (wxPathFormat) format0);

                ZVAL_STRING(&volume0_ref, string_arg0_1.ToUTF8().data());
                ZVAL_STRING(&path0_ref, string_arg0_2.ToUTF8().data());
                ZVAL_STRING(&name0_ref, string_arg0_3.ToUTF8().data());
                ZVAL_STRING(&ext0_ref, string_arg0_4.ToUTF8().data());
                size_t elements_returned0_5 = sizeof(hasExt0)/sizeof(*hasExt0);
                array_init(&hasExt0_ref);
                for(size_t i=0; i<elements_returned0_5; i++)
                {
                    add_next_index_long(&hasExt0_ref, hasExt0[i]);
                }

                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 6:
            {
                wxString string_arg1_1 = wxString(volume1, wxConvUTF8);
                wxString string_arg1_2 = wxString(path1, wxConvUTF8);
                wxString string_arg1_3 = wxString(name1, wxConvUTF8);
                wxString string_arg1_4 = wxString(ext1, wxConvUTF8);
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFileName::SplitPath(wxString(fullpath1, wxConvUTF8), &string_arg1_1, &string_arg1_2, &string_arg1_3, &string_arg1_4, (wxPathFormat) format1)\n\n");
                #endif

                wxFileName::SplitPath(wxString(fullpath1, wxConvUTF8), &string_arg1_1, &string_arg1_2, &string_arg1_3, &string_arg1_4, (wxPathFormat) format1);

                ZVAL_STRING(&volume1_ref, string_arg1_1.ToUTF8().data());
                ZVAL_STRING(&path1_ref, string_arg1_2.ToUTF8().data());
                ZVAL_STRING(&name1_ref, string_arg1_3.ToUTF8().data());
                ZVAL_STRING(&ext1_ref, string_arg1_4.ToUTF8().data());

                return;
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 4:
            {
                wxString string_arg2_1 = wxString(path2, wxConvUTF8);
                wxString string_arg2_2 = wxString(name2, wxConvUTF8);
                wxString string_arg2_3 = wxString(ext2, wxConvUTF8);
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFileName::SplitPath(wxString(fullpath2, wxConvUTF8), &string_arg2_1, &string_arg2_2, &string_arg2_3)\n\n");
                #endif

                wxFileName::SplitPath(wxString(fullpath2, wxConvUTF8), &string_arg2_1, &string_arg2_2, &string_arg2_3);

                ZVAL_STRING(&path2_ref, string_arg2_1.ToUTF8().data());
                ZVAL_STRING(&name2_ref, string_arg2_2.ToUTF8().data());
                ZVAL_STRING(&ext2_ref, string_arg2_3.ToUTF8().data());

                return;
                break;
            }
            case 5:
            {
                wxString string_arg2_1 = wxString(path2, wxConvUTF8);
                wxString string_arg2_2 = wxString(name2, wxConvUTF8);
                wxString string_arg2_3 = wxString(ext2, wxConvUTF8);
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFileName::SplitPath(wxString(fullpath2, wxConvUTF8), &string_arg2_1, &string_arg2_2, &string_arg2_3, (wxPathFormat) format2)\n\n");
                #endif

                wxFileName::SplitPath(wxString(fullpath2, wxConvUTF8), &string_arg2_1, &string_arg2_2, &string_arg2_3, (wxPathFormat) format2);

                ZVAL_STRING(&path2_ref, string_arg2_1.ToUTF8().data());
                ZVAL_STRING(&name2_ref, string_arg2_2.ToUTF8().data());
                ZVAL_STRING(&ext2_ref, string_arg2_3.ToUTF8().data());

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::SplitPath\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileName::SetVolume(string volume)
   Sets the volume specifier. */
PHP_METHOD(php_wxFileName, SetVolume)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::SetVolume\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::SetVolume call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* volume0;
    size_t volume_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&volume0, &volume_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &volume0, &volume_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::SetVolume(wxString(volume0, wxConvUTF8))\n\n");
                #endif

                ((wxFileName_php*)native_object)->SetVolume(wxString(volume0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::SetVolume\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::SetTimes(array dtAccess, array dtMod, array dtCreate)
   Sets the file creation and last access/modification times (any of the pointers may be NULL). */
PHP_METHOD(php_wxFileName, SetTimes)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::SetTimes\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::SetTimes call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* dtAccess0;
    zval* dtMod0;
    zval* dtCreate0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'aaa' (&dtAccess0, &dtMod0, &dtCreate0)\n");
        #endif

        char parse_parameters_string[] = "aaa";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &dtAccess0, &dtMod0, &dtCreate0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        int array_count0_0 = 1;
        HashTable* arr_hash0_0;
        if(arguments_received > 0)
        {
            arr_hash0_0 = Z_ARRVAL_P(dtAccess0);
            array_count0_0 = zend_hash_num_elements(arr_hash0_0);
        }
        wxDateTime* dates_array0_0 = new wxDateTime[array_count0_0];
        bool dates_continue0_0 = true;

        int array_count0_1 = 1;
        HashTable* arr_hash0_1;
        if(arguments_received > 1)
        {
            arr_hash0_1 = Z_ARRVAL_P(dtMod0);
            array_count0_1 = zend_hash_num_elements(arr_hash0_1);
        }
        wxDateTime* dates_array0_1 = new wxDateTime[array_count0_1];
        bool dates_continue0_1 = true;

        int array_count0_2 = 1;
        HashTable* arr_hash0_2;
        if(arguments_received > 2)
        {
            arr_hash0_2 = Z_ARRVAL_P(dtCreate0);
            array_count0_2 = zend_hash_num_elements(arr_hash0_2);
        }
        wxDateTime* dates_array0_2 = new wxDateTime[array_count0_2];
        bool dates_continue0_2 = true;

        switch(arguments_received)
        {
            case 3:
            {
                int array_index0_0 = 0;
                zval* temp_array_value0_0 = 0;
                while(dates_continue0_0)
                {
                    if((temp_array_value0_0 = zend_hash_index_find(HASH_OF(dtAccess0), array_index0_0)) != NULL)
                    {
                        convert_to_long_ex(temp_array_value0_0);
                        dates_array0_0[array_index0_0] = wxDateTime((time_t) Z_LVAL_P(temp_array_value0_0));
                        array_index0_0++;
                    }
                    else
                    {
                        dates_continue0_0 = false;
                    }
                }
                int array_index0_1 = 0;
                zval* temp_array_value0_1 = 0;
                while(dates_continue0_1)
                {
                    if((temp_array_value0_1 = zend_hash_index_find(HASH_OF(dtMod0), array_index0_1)) != NULL)
                    {
                        convert_to_long_ex(temp_array_value0_1);
                        dates_array0_1[array_index0_1] = wxDateTime((time_t) Z_LVAL_P(temp_array_value0_1));
                        array_index0_1++;
                    }
                    else
                    {
                        dates_continue0_1 = false;
                    }
                }
                int array_index0_2 = 0;
                zval* temp_array_value0_2 = 0;
                while(dates_continue0_2)
                {
                    if((temp_array_value0_2 = zend_hash_index_find(HASH_OF(dtCreate0), array_index0_2)) != NULL)
                    {
                        convert_to_long_ex(temp_array_value0_2);
                        dates_array0_2[array_index0_2] = wxDateTime((time_t) Z_LVAL_P(temp_array_value0_2));
                        array_index0_2++;
                    }
                    else
                    {
                        dates_continue0_2 = false;
                    }
                }
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::SetTimes(dates_array0_0, dates_array0_1, dates_array0_2))\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->SetTimes(dates_array0_0, dates_array0_1, dates_array0_2));

                delete[] dates_array0_0;
                delete[] dates_array0_1;
                delete[] dates_array0_2;

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::SetTimes\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileName::SetPath(string path, wxPathFormat format)
   Sets the path. */
PHP_METHOD(php_wxFileName, SetPath)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::SetPath\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::SetPath call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* path0;
    size_t path_len0;
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|l' (&path0, &path_len0, &format0)\n");
        #endif

        char parse_parameters_string[] = "s|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &path0, &path_len0, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::SetPath(wxString(path0, wxConvUTF8))\n\n");
                #endif

                ((wxFileName_php*)native_object)->SetPath(wxString(path0, wxConvUTF8));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::SetPath(wxString(path0, wxConvUTF8), (wxPathFormat) format0)\n\n");
                #endif

                ((wxFileName_php*)native_object)->SetPath(wxString(path0, wxConvUTF8), (wxPathFormat) format0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::SetPath\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileName::SetName(string name)
   Sets the name part (without extension). */
PHP_METHOD(php_wxFileName, SetName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::SetName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::SetName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* name0;
    size_t name_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::SetName(wxString(name0, wxConvUTF8))\n\n");
                #endif

                ((wxFileName_php*)native_object)->SetName(wxString(name0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::SetName\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileName::SetFullName(string fullname)
   The full name is the file name and extension (but without the path). */
PHP_METHOD(php_wxFileName, SetFullName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::SetFullName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::SetFullName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* fullname0;
    size_t fullname_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&fullname0, &fullname_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &fullname0, &fullname_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::SetFullName(wxString(fullname0, wxConvUTF8))\n\n");
                #endif

                ((wxFileName_php*)native_object)->SetFullName(wxString(fullname0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::SetFullName\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileName::SetExt(string ext)
   Sets the extension of the file name. */
PHP_METHOD(php_wxFileName, SetExt)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::SetExt\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::SetExt call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* ext0;
    size_t ext_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&ext0, &ext_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &ext0, &ext_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::SetExt(wxString(ext0, wxConvUTF8))\n\n");
                #endif

                ((wxFileName_php*)native_object)->SetExt(wxString(ext0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::SetExt\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileName::SetEmptyExt()
   Sets the extension of the file name to be an empty extension. */
PHP_METHOD(php_wxFileName, SetEmptyExt)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::SetEmptyExt\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::SetEmptyExt call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::SetEmptyExt()\n\n");
                #endif

                ((wxFileName_php*)native_object)->SetEmptyExt();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::SetEmptyExt\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::SetCwd()
   Changes the current working directory. */
PHP_METHOD(php_wxFileName, SetCwd)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::SetCwd\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::SetCwd call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    char* cwd1;
    size_t cwd_len1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&cwd1, &cwd_len1)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &cwd1, &cwd_len1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::SetCwd())\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->SetCwd());


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxFileName::SetCwd(wxString(cwd1, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(wxFileName::SetCwd(wxString(cwd1, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::SetCwd\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::SameAs(wxFileName filepath, wxPathFormat format)
   Compares the filename using the rules of this platform. */
PHP_METHOD(php_wxFileName, SameAs)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::SameAs\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::SameAs call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* filepath0;
    wxFileName* object_pointer0_0 = 0;
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O|l' (&filepath0, php_wxFileName_entry, &format0)\n");
        #endif

        char parse_parameters_string[] = "O|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &filepath0, php_wxFileName_entry, &format0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(filepath0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxFileName_P(filepath0)->object_type;
                    argument_native_object = (void*) Z_wxFileName_P(filepath0)->native_object;
                    object_pointer0_0 = (wxFileName*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'filepath' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(filepath0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'filepath' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::SameAs(*(wxFileName*) object_pointer0_0))\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->SameAs(*(wxFileName*) object_pointer0_0));

                references->AddReference(filepath0, "wxFileName::SameAs at call 3 with 1 argument(s)");

                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::SameAs(*(wxFileName*) object_pointer0_0, (wxPathFormat) format0))\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->SameAs(*(wxFileName*) object_pointer0_0, (wxPathFormat) format0));

                references->AddReference(filepath0, "wxFileName::SameAs at call 3 with 2 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::SameAs\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::Rmdir(int flags)
   Deletes the specified directory from the file system. */
PHP_METHOD(php_wxFileName, Rmdir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::Rmdir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::Rmdir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long flags0;
    bool overload0_called = false;

    //Parameters for overload 1
    char* dir1;
    size_t dir_len1;
    long flags1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&flags0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &flags0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|l' (&dir1, &dir_len1, &flags1)\n");
        #endif

        char parse_parameters_string[] = "s|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &dir1, &dir_len1, &flags1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::Rmdir())\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->Rmdir());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::Rmdir((int) flags0))\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->Rmdir((int) flags0));


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxFileName::Rmdir(wxString(dir1, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(wxFileName::Rmdir(wxString(dir1, wxConvUTF8)));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxFileName::Rmdir(wxString(dir1, wxConvUTF8), (int) flags1))\n\n");
                #endif

                RETVAL_BOOL(wxFileName::Rmdir(wxString(dir1, wxConvUTF8), (int) flags1));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::Rmdir\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::ReplaceHomeDir(wxPathFormat format)
   Replaces, if present in the path, the home directory for the given user (see wxGetHomeDir) with a tilde (~). */
PHP_METHOD(php_wxFileName, ReplaceHomeDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::ReplaceHomeDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::ReplaceHomeDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&format0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::ReplaceHomeDir())\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->ReplaceHomeDir());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::ReplaceHomeDir((wxPathFormat) format0))\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->ReplaceHomeDir((wxPathFormat) format0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::ReplaceHomeDir\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::ReplaceEnvVariable(string envname, string replacementFmtString, wxPathFormat format)
   If the path contains the value of the environment variable named envname then this function replaces it with the string obtained from wxString::Format(replacementFmtString, value_of_envname_variable). */
PHP_METHOD(php_wxFileName, ReplaceEnvVariable)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::ReplaceEnvVariable\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::ReplaceEnvVariable call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* envname0;
    size_t envname_len0;
    char* replacementFmtString0;
    size_t replacementFmtString_len0;
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|sl' (&envname0, &envname_len0, &replacementFmtString0, &replacementFmtString_len0, &format0)\n");
        #endif

        char parse_parameters_string[] = "s|sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &envname0, &envname_len0, &replacementFmtString0, &replacementFmtString_len0, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::ReplaceEnvVariable(wxString(envname0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->ReplaceEnvVariable(wxString(envname0, wxConvUTF8)));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::ReplaceEnvVariable(wxString(envname0, wxConvUTF8), wxString(replacementFmtString0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->ReplaceEnvVariable(wxString(envname0, wxConvUTF8), wxString(replacementFmtString0, wxConvUTF8)));


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::ReplaceEnvVariable(wxString(envname0, wxConvUTF8), wxString(replacementFmtString0, wxConvUTF8), (wxPathFormat) format0))\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->ReplaceEnvVariable(wxString(envname0, wxConvUTF8), wxString(replacementFmtString0, wxConvUTF8), (wxPathFormat) format0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::ReplaceEnvVariable\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileName::RemoveLastDir()
   Removes last directory component from the path. */
PHP_METHOD(php_wxFileName, RemoveLastDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::RemoveLastDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::RemoveLastDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::RemoveLastDir()\n\n");
                #endif

                ((wxFileName_php*)native_object)->RemoveLastDir();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::RemoveLastDir\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileName::RemoveDir(int pos)
   Removes the specified directory component from the path. */
PHP_METHOD(php_wxFileName, RemoveDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::RemoveDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::RemoveDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long pos0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&pos0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pos0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::RemoveDir((size_t) pos0)\n\n");
                #endif

                ((wxFileName_php*)native_object)->RemoveDir((size_t) pos0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::RemoveDir\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileName::PrependDir(string dir)
   Prepends a directory to the file path. */
PHP_METHOD(php_wxFileName, PrependDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::PrependDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::PrependDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* dir0;
    size_t dir_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&dir0, &dir_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &dir0, &dir_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::PrependDir(wxString(dir0, wxConvUTF8))\n\n");
                #endif

                ((wxFileName_php*)native_object)->PrependDir(wxString(dir0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::PrependDir\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileName::AssignCwd(string volume)
   Makes this object refer to the current working directory on the specified volume (or current volume if volume is empty). */
PHP_METHOD(php_wxFileName, AssignCwd)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::AssignCwd\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::AssignCwd call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* volume0;
    size_t volume_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|s' (&volume0, &volume_len0)\n");
        #endif

        char parse_parameters_string[] = "|s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &volume0, &volume_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::AssignCwd()\n\n");
                #endif

                ((wxFileName_php*)native_object)->AssignCwd();


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::AssignCwd(wxString(volume0, wxConvUTF8))\n\n");
                #endif

                ((wxFileName_php*)native_object)->AssignCwd(wxString(volume0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::AssignCwd\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileName::AssignDir(string dir, wxPathFormat format)
   Sets this file name object to the given directory name. */
PHP_METHOD(php_wxFileName, AssignDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::AssignDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::AssignDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* dir0;
    size_t dir_len0;
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|l' (&dir0, &dir_len0, &format0)\n");
        #endif

        char parse_parameters_string[] = "s|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &dir0, &dir_len0, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::AssignDir(wxString(dir0, wxConvUTF8))\n\n");
                #endif

                ((wxFileName_php*)native_object)->AssignDir(wxString(dir0, wxConvUTF8));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::AssignDir(wxString(dir0, wxConvUTF8), (wxPathFormat) format0)\n\n");
                #endif

                ((wxFileName_php*)native_object)->AssignDir(wxString(dir0, wxConvUTF8), (wxPathFormat) format0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::AssignDir\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileName::AssignHomeDir()
   Sets this file name object to the home directory. */
PHP_METHOD(php_wxFileName, AssignHomeDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::AssignHomeDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::AssignHomeDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::AssignHomeDir()\n\n");
                #endif

                ((wxFileName_php*)native_object)->AssignHomeDir();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::AssignHomeDir\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileName::AssignTempFileName(string prefix)
   The function calls CreateTempFileName() to create a temporary file and sets this object to the name of the file. */
PHP_METHOD(php_wxFileName, AssignTempFileName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::AssignTempFileName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::AssignTempFileName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* prefix0;
    size_t prefix_len0;
    bool overload0_called = false;

    //Parameters for overload 1
    char* prefix1;
    size_t prefix_len1;
    zval* fileTemp1;
    wxFile* object_pointer1_1 = 0;
    bool overload1_called = false;

    //Parameters for overload 2
    char* prefix2;
    size_t prefix_len2;
    zval* fileTemp2;
    wxFFile* object_pointer2_1 = 0;
    bool overload2_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&prefix0, &prefix_len0)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &prefix0, &prefix_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sz' (&prefix1, &prefix_len1, &fileTemp1)\n");
        #endif

        char parse_parameters_string[] = "sz";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &prefix1, &prefix_len1, &fileTemp1 ) == SUCCESS)
        {
            if(arguments_received >= 2){
                if(Z_TYPE_P(fileTemp1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxFile_P(fileTemp1)->object_type;
                    argument_native_object = (void*) Z_wxFile_P(fileTemp1)->native_object;
                    object_pointer1_1 = (wxFile*) argument_native_object;
                    if (!object_pointer1_1 || (argument_type != PHP_WXFILE_TYPE))
                    {
                        goto overload2;
                    }
                }
                else if(Z_TYPE_P(fileTemp1) != IS_NULL)
                {
                    goto overload2;
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    //Overload 2
    overload2:
    if(!already_called && arguments_received == 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'sz' (&prefix2, &prefix_len2, &fileTemp2)\n");
        #endif

        char parse_parameters_string[] = "sz";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &prefix2, &prefix_len2, &fileTemp2 ) == SUCCESS)
        {
            if(arguments_received >= 2){
                if(Z_TYPE_P(fileTemp2) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxFFile_P(fileTemp2)->object_type;
                    argument_native_object = (void*) Z_wxFFile_P(fileTemp2)->native_object;
                    object_pointer2_1 = (wxFFile*) argument_native_object;
                    if (!object_pointer2_1 || (argument_type != PHP_WXFFILE_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'fileTemp' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(fileTemp2) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'fileTemp' not null, could not be retreived correctly.");
                }
            }

            overload2_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::AssignTempFileName(wxString(prefix0, wxConvUTF8))\n\n");
                #endif

                ((wxFileName_php*)native_object)->AssignTempFileName(wxString(prefix0, wxConvUTF8));


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::AssignTempFileName(wxString(prefix1, wxConvUTF8), (wxFile*) object_pointer1_1)\n\n");
                #endif

                ((wxFileName_php*)native_object)->AssignTempFileName(wxString(prefix1, wxConvUTF8), (wxFile*) object_pointer1_1);

                references->AddReference(fileTemp1, "wxFileName::AssignTempFileName at call 1 with 2 argument(s)");

                return;
                break;
            }
        }
    }

    if(overload2_called)
    {
        switch(arguments_received)
        {
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::AssignTempFileName(wxString(prefix2, wxConvUTF8), (wxFFile*) object_pointer2_1)\n\n");
                #endif

                ((wxFileName_php*)native_object)->AssignTempFileName(wxString(prefix2, wxConvUTF8), (wxFFile*) object_pointer2_1);

                references->AddReference(fileTemp2, "wxFileName::AssignTempFileName at call 1 with 2 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::AssignTempFileName\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileName::Clear()
   Reset all components to default, uninitialized state. */
PHP_METHOD(php_wxFileName, Clear)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::Clear\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::Clear call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::Clear()\n\n");
                #endif

                ((wxFileName_php*)native_object)->Clear();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::Clear\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileName::ClearExt()
   Removes the extension from the file name resulting in a file name with no trailing dot. */
PHP_METHOD(php_wxFileName, ClearExt)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::ClearExt\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::ClearExt call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::ClearExt()\n\n");
                #endif

                ((wxFileName_php*)native_object)->ClearExt();


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::ClearExt\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileName::CreateTempFileName(string prefix, wxFile &fileTemp)
   Returns a temporary file name starting with the given prefix. */
PHP_METHOD(php_wxFileName, CreateTempFileName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::CreateTempFileName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::CreateTempFileName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* prefix0;
    size_t prefix_len0;
    zval* fileTemp0;
    wxFile* object_pointer0_1 = 0;
    bool overload0_called = false;

    //Parameters for overload 1
    char* prefix1;
    size_t prefix_len1;
    zval* fileTemp1;
    wxFFile* object_pointer1_1 = 0;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|z' (&prefix0, &prefix_len0, &fileTemp0)\n");
        #endif

        char parse_parameters_string[] = "s|z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &prefix0, &prefix_len0, &fileTemp0 ) == SUCCESS)
        {
            if(arguments_received >= 2){
                if(Z_TYPE_P(fileTemp0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxFile_P(fileTemp0)->object_type;
                    argument_native_object = (void*) Z_wxFile_P(fileTemp0)->native_object;
                    object_pointer0_1 = (wxFile*) argument_native_object;
                    if (!object_pointer0_1 || (argument_type != PHP_WXFILE_TYPE))
                    {
                        goto overload1;
                    }
                }
                else if(Z_TYPE_P(fileTemp0) != IS_NULL)
                {
                    goto overload1;
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|z' (&prefix1, &prefix_len1, &fileTemp1)\n");
        #endif

        char parse_parameters_string[] = "s|z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &prefix1, &prefix_len1, &fileTemp1 ) == SUCCESS)
        {
            if(arguments_received >= 2){
                if(Z_TYPE_P(fileTemp1) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxFFile_P(fileTemp1)->object_type;
                    argument_native_object = (void*) Z_wxFFile_P(fileTemp1)->native_object;
                    object_pointer1_1 = (wxFFile*) argument_native_object;
                    if (!object_pointer1_1 || (argument_type != PHP_WXFFILE_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'fileTemp' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(fileTemp1) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'fileTemp' not null, could not be retreived correctly.");
                }
            }

            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileName::CreateTempFileName(wxString(prefix0, wxConvUTF8)).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = wxFileName::CreateTempFileName(wxString(prefix0, wxConvUTF8));
                RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileName::CreateTempFileName(wxString(prefix0, wxConvUTF8), (wxFile*) object_pointer0_1).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return2;
                value_to_return2 = wxFileName::CreateTempFileName(wxString(prefix0, wxConvUTF8), (wxFile*) object_pointer0_1);
                RETVAL_STRING(value_to_return2.ToUTF8().data());


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileName::CreateTempFileName(wxString(prefix1, wxConvUTF8)).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = wxFileName::CreateTempFileName(wxString(prefix1, wxConvUTF8));
                RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileName::CreateTempFileName(wxString(prefix1, wxConvUTF8), (wxFFile*) object_pointer1_1).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return2;
                value_to_return2 = wxFileName::CreateTempFileName(wxString(prefix1, wxConvUTF8), (wxFFile*) object_pointer1_1);
                RETVAL_STRING(value_to_return2.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::CreateTempFileName\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::DirExists()
   Returns true if the directory with this name exists. */
PHP_METHOD(php_wxFileName, DirExists)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::DirExists\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::DirExists call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    char* dir1;
    size_t dir_len1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&dir1, &dir_len1)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &dir1, &dir_len1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::DirExists())\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->DirExists());


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxFileName::DirExists(wxString(dir1, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(wxFileName::DirExists(wxString(dir1, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::DirExists\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFileName wxFileName::DirName(string dir, wxPathFormat format)
   Returns the object corresponding to the directory with the given name. */
PHP_METHOD(php_wxFileName, DirName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::DirName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::DirName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* dir0;
    size_t dir_len0;
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|l' (&dir0, &dir_len0, &format0)\n");
        #endif

        char parse_parameters_string[] = "s|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &dir0, &dir_len0, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFileName::DirName(wxString(dir0, wxConvUTF8)) to return new object\n\n");
                #endif

                wxFileName value_to_return1;
                value_to_return1 = wxFileName::DirName(wxString(dir0, wxConvUTF8));
                void* ptr = safe_emalloc(1, sizeof(wxFileName_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxFileName));
                object_init_ex(return_value, php_wxFileName_entry);
                ((wxFileName_php*)ptr)->phpObj = *return_value;
                zo_wxFileName* zo1 = Z_wxFileName_P(return_value);
                zo1->native_object = (wxFileName_php*) ptr;


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFileName::DirName(wxString(dir0, wxConvUTF8), (wxPathFormat) format0) to return new object\n\n");
                #endif

                wxFileName value_to_return2;
                value_to_return2 = wxFileName::DirName(wxString(dir0, wxConvUTF8), (wxPathFormat) format0);
                void* ptr = safe_emalloc(1, sizeof(wxFileName_php), 0);
                memcpy(ptr, (void*) &value_to_return2, sizeof(wxFileName));
                object_init_ex(return_value, php_wxFileName_entry);
                ((wxFileName_php*)ptr)->phpObj = *return_value;
                zo_wxFileName* zo2 = Z_wxFileName_P(return_value);
                zo2->native_object = (wxFileName_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::DirName\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::FileExists()
   Returns true if the file with this name exists. */
PHP_METHOD(php_wxFileName, FileExists)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::FileExists\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::FileExists call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    char* file1;
    size_t file_len1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&file1, &file_len1)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &file1, &file_len1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::FileExists())\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->FileExists());


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxFileName::FileExists(wxString(file1, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(wxFileName::FileExists(wxString(file1, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::FileExists\n"
        );
    }
}
/* }}} */

/* {{{ proto wxFileName wxFileName::FileName(string file, wxPathFormat format)
   Returns the file name object corresponding to the given file. */
PHP_METHOD(php_wxFileName, FileName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::FileName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::FileName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* file0;
    size_t file_len0;
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|l' (&file0, &file_len0, &format0)\n");
        #endif

        char parse_parameters_string[] = "s|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &file0, &file_len0, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFileName::FileName(wxString(file0, wxConvUTF8)) to return new object\n\n");
                #endif

                wxFileName value_to_return1;
                value_to_return1 = wxFileName::FileName(wxString(file0, wxConvUTF8));
                void* ptr = safe_emalloc(1, sizeof(wxFileName_php), 0);
                memcpy(ptr, (void*) &value_to_return1, sizeof(wxFileName));
                object_init_ex(return_value, php_wxFileName_entry);
                ((wxFileName_php*)ptr)->phpObj = *return_value;
                zo_wxFileName* zo1 = Z_wxFileName_P(return_value);
                zo1->native_object = (wxFileName_php*) ptr;


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxFileName::FileName(wxString(file0, wxConvUTF8), (wxPathFormat) format0) to return new object\n\n");
                #endif

                wxFileName value_to_return2;
                value_to_return2 = wxFileName::FileName(wxString(file0, wxConvUTF8), (wxPathFormat) format0);
                void* ptr = safe_emalloc(1, sizeof(wxFileName_php), 0);
                memcpy(ptr, (void*) &value_to_return2, sizeof(wxFileName));
                object_init_ex(return_value, php_wxFileName_entry);
                ((wxFileName_php*)ptr)->phpObj = *return_value;
                zo_wxFileName* zo2 = Z_wxFileName_P(return_value);
                zo2->native_object = (wxFileName_php*) ptr;


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::FileName\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileName::GetCwd(string volume)
   Retrieves the value of the current working directory on the specified volume. */
PHP_METHOD(php_wxFileName, GetCwd)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::GetCwd\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::GetCwd call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* volume0;
    size_t volume_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|s' (&volume0, &volume_len0)\n");
        #endif

        char parse_parameters_string[] = "|s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &volume0, &volume_len0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileName::GetCwd().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = wxFileName::GetCwd();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileName::GetCwd(wxString(volume0, wxConvUTF8)).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = wxFileName::GetCwd(wxString(volume0, wxConvUTF8));
                RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::GetCwd\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxFileName::GetDirCount()
   Returns the number of directories in the file name. */
PHP_METHOD(php_wxFileName, GetDirCount)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::GetDirCount\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::GetDirCount call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFileName::GetDirCount())\n\n");
                #endif

                RETVAL_LONG(((wxFileName_php*)native_object)->GetDirCount());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::GetDirCount\n"
        );
    }
}
/* }}} */

/* {{{ proto array wxFileName::GetDirs()
   Returns the directories in string array form. */
PHP_METHOD(php_wxFileName, GetDirs)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::GetDirs\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::GetDirs call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::GetDirs() to return strings array\n\n");
                #endif

                wxArrayString value_to_return0;
                value_to_return0 = ((wxFileName_php*)native_object)->GetDirs();
                array_init(return_value);
                for(size_t i=0; i<value_to_return0.GetCount(); i++)
                {
                    add_next_index_string(return_value, value_to_return0[i].ToUTF8().data());
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::GetDirs\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileName::GetExt()
   Returns the file name extension. */
PHP_METHOD(php_wxFileName, GetExt)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::GetExt\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::GetExt call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileName::GetExt().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxFileName_php*)native_object)->GetExt();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::GetExt\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileName::GetForbiddenChars(wxPathFormat format)
   Returns the characters that can't be used in filenames and directory names for the specified format. */
PHP_METHOD(php_wxFileName, GetForbiddenChars)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::GetForbiddenChars\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::GetForbiddenChars call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&format0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileName::GetForbiddenChars().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = wxFileName::GetForbiddenChars();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileName::GetForbiddenChars((wxPathFormat) format0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = wxFileName::GetForbiddenChars((wxPathFormat) format0);
                RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::GetForbiddenChars\n"
        );
    }
}
/* }}} */

/* {{{ proto wxPathFormat wxFileName::GetFormat(wxPathFormat format)
   Returns the canonical path format for this platform. */
PHP_METHOD(php_wxFileName, GetFormat)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::GetFormat\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::GetFormat call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&format0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_LONG(wxFileName::GetFormat())\n\n");
                #endif

                RETVAL_LONG(wxFileName::GetFormat());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_LONG(wxFileName::GetFormat((wxPathFormat) format0))\n\n");
                #endif

                RETVAL_LONG(wxFileName::GetFormat((wxPathFormat) format0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::GetFormat\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileName::GetFullName()
   Returns the full name (including extension but excluding directories). */
PHP_METHOD(php_wxFileName, GetFullName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::GetFullName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::GetFullName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileName::GetFullName().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxFileName_php*)native_object)->GetFullName();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::GetFullName\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileName::GetFullPath(wxPathFormat format)
   Returns the full path with name and extension. */
PHP_METHOD(php_wxFileName, GetFullPath)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::GetFullPath\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::GetFullPath call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&format0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileName::GetFullPath().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxFileName_php*)native_object)->GetFullPath();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileName::GetFullPath((wxPathFormat) format0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = ((wxFileName_php*)native_object)->GetFullPath((wxPathFormat) format0);
                RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::GetFullPath\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileName::GetHomeDir()
   Returns the home directory. */
PHP_METHOD(php_wxFileName, GetHomeDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::GetHomeDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::GetHomeDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileName::GetHomeDir().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = wxFileName::GetHomeDir();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::GetHomeDir\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileName::GetHumanReadableSize(string failmsg, int precision, wxSizeConvention conv)
   Returns the representation of the file size in a human-readable form. */
PHP_METHOD(php_wxFileName, GetHumanReadableSize)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::GetHumanReadableSize\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::GetHumanReadableSize call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* failmsg0;
    size_t failmsg_len0;
    long precision0;
    long conv0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|sll' (&failmsg0, &failmsg_len0, &precision0, &conv0)\n");
        #endif

        char parse_parameters_string[] = "|sll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &failmsg0, &failmsg_len0, &precision0, &conv0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileName::GetHumanReadableSize().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxFileName_php*)native_object)->GetHumanReadableSize();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileName::GetHumanReadableSize(wxString(failmsg0, wxConvUTF8)).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = ((wxFileName_php*)native_object)->GetHumanReadableSize(wxString(failmsg0, wxConvUTF8));
                RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileName::GetHumanReadableSize(wxString(failmsg0, wxConvUTF8), (int) precision0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return2;
                value_to_return2 = ((wxFileName_php*)native_object)->GetHumanReadableSize(wxString(failmsg0, wxConvUTF8), (int) precision0);
                RETVAL_STRING(value_to_return2.ToUTF8().data());


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileName::GetHumanReadableSize(wxString(failmsg0, wxConvUTF8), (int) precision0, (wxSizeConvention) conv0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return3;
                value_to_return3 = ((wxFileName_php*)native_object)->GetHumanReadableSize(wxString(failmsg0, wxConvUTF8), (int) precision0, (wxSizeConvention) conv0);
                RETVAL_STRING(value_to_return3.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::GetHumanReadableSize\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileName::GetLongPath()
   Return the long form of the path (returns identity on non-Windows platforms). */
PHP_METHOD(php_wxFileName, GetLongPath)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::GetLongPath\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::GetLongPath call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileName::GetLongPath().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxFileName_php*)native_object)->GetLongPath();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::GetLongPath\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileName::GetName()
   Returns the name part of the filename (without extension). */
PHP_METHOD(php_wxFileName, GetName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::GetName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::GetName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileName::GetName().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxFileName_php*)native_object)->GetName();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::GetName\n"
        );
    }
}
/* }}} */

/* {{{ proto timestamp wxFileName::GetModificationTime()
   Returns the last time the file was last modified. */
PHP_METHOD(php_wxFileName, GetModificationTime)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::GetModificationTime\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::GetModificationTime call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileName::GetModificationTime() to return timestamp\n\n");
                #endif

                time_t value_to_return0;
                value_to_return0 = ((wxFileName_php*)native_object)->GetModificationTime().GetTicks();
                RETVAL_LONG(value_to_return0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::GetModificationTime\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileName::GetPath(int flags, wxPathFormat format)
   Returns the path part of the filename (without the name or extension). */
PHP_METHOD(php_wxFileName, GetPath)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::GetPath\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::GetPath call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long flags0;
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|ll' (&flags0, &format0)\n");
        #endif

        char parse_parameters_string[] = "|ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &flags0, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileName::GetPath().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxFileName_php*)native_object)->GetPath();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileName::GetPath((int) flags0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = ((wxFileName_php*)native_object)->GetPath((int) flags0);
                RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileName::GetPath((int) flags0, (wxPathFormat) format0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return2;
                value_to_return2 = ((wxFileName_php*)native_object)->GetPath((int) flags0, (wxPathFormat) format0);
                RETVAL_STRING(value_to_return2.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::GetPath\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileName::GetPathSeparators(wxPathFormat format)
   Returns the string containing all the path separators for this format. */
PHP_METHOD(php_wxFileName, GetPathSeparators)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::GetPathSeparators\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::GetPathSeparators call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&format0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileName::GetPathSeparators().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = wxFileName::GetPathSeparators();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileName::GetPathSeparators((wxPathFormat) format0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = wxFileName::GetPathSeparators((wxPathFormat) format0);
                RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::GetPathSeparators\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileName::GetPathTerminators(wxPathFormat format)
   Returns the string of characters which may terminate the path part. */
PHP_METHOD(php_wxFileName, GetPathTerminators)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::GetPathTerminators\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::GetPathTerminators call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&format0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileName::GetPathTerminators().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = wxFileName::GetPathTerminators();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileName::GetPathTerminators((wxPathFormat) format0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = wxFileName::GetPathTerminators((wxPathFormat) format0);
                RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::GetPathTerminators\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileName::GetPathWithSep(wxPathFormat format)
   Returns the path with the trailing separator, useful for appending the name to the given path. */
PHP_METHOD(php_wxFileName, GetPathWithSep)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::GetPathWithSep\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::GetPathWithSep call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&format0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileName::GetPathWithSep().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxFileName_php*)native_object)->GetPathWithSep();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileName::GetPathWithSep((wxPathFormat) format0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = ((wxFileName_php*)native_object)->GetPathWithSep((wxPathFormat) format0);
                RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::GetPathWithSep\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileName::GetShortPath()
   Return the short form of the path (returns identity on non-Windows platforms). */
PHP_METHOD(php_wxFileName, GetShortPath)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::GetShortPath\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::GetShortPath call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileName::GetShortPath().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxFileName_php*)native_object)->GetShortPath();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::GetShortPath\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileName::GetTempDir()
   Returns the directory used for temporary files, for current user. */
PHP_METHOD(php_wxFileName, GetTempDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::GetTempDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::GetTempDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileName::GetTempDir().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = wxFileName::GetTempDir();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::GetTempDir\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileName::GetVolumeSeparator(wxPathFormat format)
   Returns the string separating the volume from the path for this format. */
PHP_METHOD(php_wxFileName, GetVolumeSeparator)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::GetVolumeSeparator\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::GetVolumeSeparator call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&format0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileName::GetVolumeSeparator().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = wxFileName::GetVolumeSeparator();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_STRING(wxFileName::GetVolumeSeparator((wxPathFormat) format0).fn_str(), 1)\n\n");
                #endif

                wxString value_to_return1;
                value_to_return1 = wxFileName::GetVolumeSeparator((wxPathFormat) format0);
                RETVAL_STRING(value_to_return1.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::GetVolumeSeparator\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFileName::GetVolume()
   Returns the string containing the volume for this file name. */
PHP_METHOD(php_wxFileName, GetVolume)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::GetVolume\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::GetVolume call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFileName::GetVolume().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxFileName_php*)native_object)->GetVolume();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::GetVolume\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::HasExt()
   Returns true if an extension is present. */
PHP_METHOD(php_wxFileName, HasExt)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::HasExt\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::HasExt call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::HasExt())\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->HasExt());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::HasExt\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::HasName()
   Returns true if a name is present. */
PHP_METHOD(php_wxFileName, HasName)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::HasName\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::HasName call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::HasName())\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->HasName());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::HasName\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::HasVolume()
   Returns true if a volume specifier is present. */
PHP_METHOD(php_wxFileName, HasVolume)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::HasVolume\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::HasVolume call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::HasVolume())\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->HasVolume());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::HasVolume\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::IsAbsolute(wxPathFormat format)
   Returns true if this filename is absolute. */
PHP_METHOD(php_wxFileName, IsAbsolute)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::IsAbsolute\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::IsAbsolute call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&format0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::IsAbsolute())\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->IsAbsolute());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::IsAbsolute((wxPathFormat) format0))\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->IsAbsolute((wxPathFormat) format0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::IsAbsolute\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::IsCaseSensitive(wxPathFormat format)
   Returns true if the file names of this type are case-sensitive. */
PHP_METHOD(php_wxFileName, IsCaseSensitive)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::IsCaseSensitive\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::IsCaseSensitive call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&format0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxFileName::IsCaseSensitive())\n\n");
                #endif

                RETVAL_BOOL(wxFileName::IsCaseSensitive());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxFileName::IsCaseSensitive((wxPathFormat) format0))\n\n");
                #endif

                RETVAL_BOOL(wxFileName::IsCaseSensitive((wxPathFormat) format0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::IsCaseSensitive\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::IsDir()
   Returns true if this object represents a directory, false otherwise (i.e. */
PHP_METHOD(php_wxFileName, IsDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::IsDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::IsDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::IsDir())\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->IsDir());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::IsDir\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::IsDirReadable()
   Returns true if the directory component of this instance is an existing directory and this process has read permissions on it. */
PHP_METHOD(php_wxFileName, IsDirReadable)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::IsDirReadable\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::IsDirReadable call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    char* dir1;
    size_t dir_len1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&dir1, &dir_len1)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &dir1, &dir_len1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::IsDirReadable())\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->IsDirReadable());


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxFileName::IsDirReadable(wxString(dir1, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(wxFileName::IsDirReadable(wxString(dir1, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::IsDirReadable\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::IsDirWritable()
   Returns true if the directory component of this instance is an existing directory and this process has write permissions on it. */
PHP_METHOD(php_wxFileName, IsDirWritable)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::IsDirWritable\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::IsDirWritable call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    char* dir1;
    size_t dir_len1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&dir1, &dir_len1)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &dir1, &dir_len1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::IsDirWritable())\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->IsDirWritable());


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxFileName::IsDirWritable(wxString(dir1, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(wxFileName::IsDirWritable(wxString(dir1, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::IsDirWritable\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::IsFileExecutable()
   Returns true if a file with this name exists and if this process has execute permissions on it. */
PHP_METHOD(php_wxFileName, IsFileExecutable)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::IsFileExecutable\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::IsFileExecutable call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    char* file1;
    size_t file_len1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&file1, &file_len1)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &file1, &file_len1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::IsFileExecutable())\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->IsFileExecutable());


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxFileName::IsFileExecutable(wxString(file1, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(wxFileName::IsFileExecutable(wxString(file1, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::IsFileExecutable\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::IsFileReadable()
   Returns true if a file with this name exists and if this process has read permissions on it. */
PHP_METHOD(php_wxFileName, IsFileReadable)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::IsFileReadable\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::IsFileReadable call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    char* file1;
    size_t file_len1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&file1, &file_len1)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &file1, &file_len1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::IsFileReadable())\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->IsFileReadable());


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxFileName::IsFileReadable(wxString(file1, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(wxFileName::IsFileReadable(wxString(file1, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::IsFileReadable\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::IsFileWritable()
   Returns true if a file with this name exists and if this process has write permissions on it. */
PHP_METHOD(php_wxFileName, IsFileWritable)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::IsFileWritable\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::IsFileWritable call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    //Parameters for overload 1
    char* file1;
    size_t file_len1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's' (&file1, &file_len1)\n");
        #endif

        char parse_parameters_string[] = "s";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &file1, &file_len1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::IsFileWritable())\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->IsFileWritable());


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxFileName::IsFileWritable(wxString(file1, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(wxFileName::IsFileWritable(wxString(file1, wxConvUTF8)));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::IsFileWritable\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::IsMSWUniqueVolumeNamePath(string path, wxPathFormat format)
   Returns true if the volume part of the path is a unique volume name. */
PHP_METHOD(php_wxFileName, IsMSWUniqueVolumeNamePath)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::IsMSWUniqueVolumeNamePath\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::IsMSWUniqueVolumeNamePath call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* path0;
    size_t path_len0;
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|l' (&path0, &path_len0, &format0)\n");
        #endif

        char parse_parameters_string[] = "s|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &path0, &path_len0, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxFileName::IsMSWUniqueVolumeNamePath(wxString(path0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(wxFileName::IsMSWUniqueVolumeNamePath(wxString(path0, wxConvUTF8)));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxFileName::IsMSWUniqueVolumeNamePath(wxString(path0, wxConvUTF8), (wxPathFormat) format0))\n\n");
                #endif

                RETVAL_BOOL(wxFileName::IsMSWUniqueVolumeNamePath(wxString(path0, wxConvUTF8), (wxPathFormat) format0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::IsMSWUniqueVolumeNamePath\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::IsOk()
   Returns true if the filename is valid, false if it is not initialized yet. */
PHP_METHOD(php_wxFileName, IsOk)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::IsOk\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::IsOk call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::IsOk())\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->IsOk());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::IsOk\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::IsRelative(wxPathFormat format)
   Returns true if this filename is not absolute. */
PHP_METHOD(php_wxFileName, IsRelative)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::IsRelative\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::IsRelative call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|l' (&format0)\n");
        #endif

        char parse_parameters_string[] = "|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::IsRelative())\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->IsRelative());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::IsRelative((wxPathFormat) format0))\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->IsRelative((wxPathFormat) format0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::IsRelative\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::MakeAbsolute(string cwd, wxPathFormat format)
   Make the file name absolute. */
PHP_METHOD(php_wxFileName, MakeAbsolute)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::MakeAbsolute\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::MakeAbsolute call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* cwd0;
    size_t cwd_len0;
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|sl' (&cwd0, &cwd_len0, &format0)\n");
        #endif

        char parse_parameters_string[] = "|sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &cwd0, &cwd_len0, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::MakeAbsolute())\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->MakeAbsolute());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::MakeAbsolute(wxString(cwd0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->MakeAbsolute(wxString(cwd0, wxConvUTF8)));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::MakeAbsolute(wxString(cwd0, wxConvUTF8), (wxPathFormat) format0))\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->MakeAbsolute(wxString(cwd0, wxConvUTF8), (wxPathFormat) format0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::MakeAbsolute\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::MakeRelativeTo(string pathBase, wxPathFormat format)
   This function tries to put this file name in a form relative to pathBase. */
PHP_METHOD(php_wxFileName, MakeRelativeTo)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::MakeRelativeTo\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::MakeRelativeTo call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    char* pathBase0;
    size_t pathBase_len0;
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|sl' (&pathBase0, &pathBase_len0, &format0)\n");
        #endif

        char parse_parameters_string[] = "|sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &pathBase0, &pathBase_len0, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::MakeRelativeTo())\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->MakeRelativeTo());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::MakeRelativeTo(wxString(pathBase0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->MakeRelativeTo(wxString(pathBase0, wxConvUTF8)));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::MakeRelativeTo(wxString(pathBase0, wxConvUTF8), (wxPathFormat) format0))\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->MakeRelativeTo(wxString(pathBase0, wxConvUTF8), (wxPathFormat) format0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::MakeRelativeTo\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::Mkdir(int perm, int flags)
   Creates a directory. */
PHP_METHOD(php_wxFileName, Mkdir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::Mkdir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::Mkdir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long perm0;
    long flags0;
    bool overload0_called = false;

    //Parameters for overload 1
    char* dir1;
    size_t dir_len1;
    long perm1;
    long flags1;
    bool overload1_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 0  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '|ll' (&perm0, &flags0)\n");
        #endif

        char parse_parameters_string[] = "|ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &perm0, &flags0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    //Overload 1
    overload1:
    if(!already_called && arguments_received >= 1  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 's|ll' (&dir1, &dir_len1, &perm1, &flags1)\n");
        #endif

        char parse_parameters_string[] = "s|ll";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &dir1, &dir_len1, &perm1, &flags1 ) == SUCCESS)
        {
            overload1_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::Mkdir())\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->Mkdir());


                return;
                break;
            }
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::Mkdir((int) perm0))\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->Mkdir((int) perm0));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::Mkdir((int) perm0, (int) flags0))\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->Mkdir((int) perm0, (int) flags0));


                return;
                break;
            }
        }
    }

    if(overload1_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxFileName::Mkdir(wxString(dir1, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(wxFileName::Mkdir(wxString(dir1, wxConvUTF8)));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxFileName::Mkdir(wxString(dir1, wxConvUTF8), (int) perm1))\n\n");
                #endif

                RETVAL_BOOL(wxFileName::Mkdir(wxString(dir1, wxConvUTF8), (int) perm1));


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing RETURN_BOOL(wxFileName::Mkdir(wxString(dir1, wxConvUTF8), (int) perm1, (int) flags1))\n\n");
                #endif

                RETVAL_BOOL(wxFileName::Mkdir(wxString(dir1, wxConvUTF8), (int) perm1, (int) flags1));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::Mkdir\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileName::Normalize(int flags, string cwd, wxPathFormat format)
   Normalize the path. */
PHP_METHOD(php_wxFileName, Normalize)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileName::Normalize\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileName* current_object;
    wxphp_object_type current_object_type;
    wxFileName_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileName_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileName::Normalize call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILENAME_TYPE){
                references = &((wxFileName_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long flags0;
    char* cwd0;
    size_t cwd_len0;
    long format0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l|sl' (&flags0, &cwd0, &cwd_len0, &format0)\n");
        #endif

        char parse_parameters_string[] = "l|sl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &flags0, &cwd0, &cwd_len0, &format0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::Normalize((int) flags0))\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->Normalize((int) flags0));


                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::Normalize((int) flags0, wxString(cwd0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->Normalize((int) flags0, wxString(cwd0, wxConvUTF8)));


                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileName::Normalize((int) flags0, wxString(cwd0, wxConvUTF8), (wxPathFormat) format0))\n\n");
                #endif

                RETVAL_BOOL(((wxFileName_php*)native_object)->Normalize((int) flags0, wxString(cwd0, wxConvUTF8), (wxPathFormat) format0));


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileName::Normalize\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFSFile_free(void *object)
{
    zo_wxFSFile* custom_object = (zo_wxFSFile*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFSFile_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxFSFile done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxFSFile_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFSFile_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxFSFile* custom_object;

    custom_object = (zo_wxFSFile*) ecalloc(
        1,
        sizeof(zo_wxFSFile)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxFSFile_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFSFILE_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto  wxFSFile::wxFSFile(wxInputStream &stream, string location, string mimetype, string anchor, timestamp modif)
   Constructor. */
PHP_METHOD(php_wxFSFile, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFSFile::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFSFile* current_object;
    wxFSFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    zval* stream0;
    wxInputStream* object_pointer0_0 = 0;
    char* location0;
    size_t location_len0;
    char* mimetype0;
    size_t mimetype_len0;
    char* anchor0;
    size_t anchor_len0;
    time_t modif0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 5)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'zsssl' (&stream0, &location0, &location_len0, &mimetype0, &mimetype_len0, &anchor0, &anchor_len0, &modif0)\n");
        #endif

        char parse_parameters_string[] = "zsssl";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &stream0, &location0, &location_len0, &mimetype0, &mimetype_len0, &anchor0, &anchor_len0, &modif0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(stream0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxInputStream_P(stream0)->object_type;
                    argument_native_object = (void*) Z_wxInputStream_P(stream0)->native_object;
                    object_pointer0_0 = (wxInputStream*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'stream' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(stream0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'stream' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 5:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct((wxInputStream*) object_pointer0_0, wxString(location0, wxConvUTF8), wxString(mimetype0, wxConvUTF8), wxString(anchor0, wxConvUTF8), wxDateTime(modif0))\n");
                #endif

                native_object = new wxFSFile_php((wxInputStream*) object_pointer0_0, wxString(location0, wxConvUTF8), wxString(mimetype0, wxConvUTF8), wxString(anchor0, wxConvUTF8), wxDateTime(modif0));

                native_object->references.Initialize();
                ((wxFSFile_php*) native_object)->references.AddReference(stream0, "wxFSFile::wxFSFile at call 2 with 5 argument(s)");
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxFSFile_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxFSFile::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

/* {{{ proto wxInputStream wxFSFile::GetStream()
   Returns pointer to the stream. */
PHP_METHOD(php_wxFSFile, GetStream)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFSFile::GetStream\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFSFile* current_object;
    wxphp_object_type current_object_type;
    wxFSFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFSFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFSFile::GetStream call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFSFILE_TYPE){
                references = &((wxFSFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFSFile::GetStream() to return object pointer\n\n");
                #endif

                wxInputStream_php* value_to_return0;
                value_to_return0 = (wxInputStream_php*) ((wxFSFile_php*)native_object)->GetStream();

                if(value_to_return0 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxInputStream_entry);
                    Z_wxInputStream_P(return_value)->native_object = (wxInputStream_php*) value_to_return0;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxFSFile::GetStream at call 5 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFSFile::GetStream\n"
        );
    }
}
/* }}} */

/* {{{ proto timestamp wxFSFile::GetModificationTime()
   Returns time when this file was modified. */
PHP_METHOD(php_wxFSFile, GetModificationTime)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFSFile::GetModificationTime\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFSFile* current_object;
    wxphp_object_type current_object_type;
    wxFSFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFSFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFSFile::GetModificationTime call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFSFILE_TYPE){
                references = &((wxFSFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFSFile::GetModificationTime() to return timestamp\n\n");
                #endif

                time_t value_to_return0;
                value_to_return0 = ((wxFSFile_php*)native_object)->GetModificationTime().GetTicks();
                RETVAL_LONG(value_to_return0);


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFSFile::GetModificationTime\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFSFile::GetMimeType()
   Returns the MIME type of the content of this file. */
PHP_METHOD(php_wxFSFile, GetMimeType)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFSFile::GetMimeType\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFSFile* current_object;
    wxphp_object_type current_object_type;
    wxFSFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFSFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFSFile::GetMimeType call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFSFILE_TYPE){
                references = &((wxFSFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFSFile::GetMimeType().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxFSFile_php*)native_object)->GetMimeType();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFSFile::GetMimeType\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFSFile::GetLocation()
   Returns full location of the file, including path and protocol. */
PHP_METHOD(php_wxFSFile, GetLocation)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFSFile::GetLocation\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFSFile* current_object;
    wxphp_object_type current_object_type;
    wxFSFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFSFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFSFile::GetLocation call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFSFILE_TYPE){
                references = &((wxFSFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFSFile::GetLocation().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxFSFile_php*)native_object)->GetLocation();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFSFile::GetLocation\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxFSFile::GetAnchor()
   Returns anchor (if present). */
PHP_METHOD(php_wxFSFile, GetAnchor)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFSFile::GetAnchor\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFSFile* current_object;
    wxphp_object_type current_object_type;
    wxFSFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFSFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFSFile::GetAnchor call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFSFILE_TYPE){
                references = &((wxFSFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxFSFile::GetAnchor().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                value_to_return0 = ((wxFSFile_php*)native_object)->GetAnchor();
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFSFile::GetAnchor\n"
        );
    }
}
/* }}} */

/* {{{ proto wxInputStream wxFSFile::DetachStream()
   Detaches the stream from the wxFSFile object. */
PHP_METHOD(php_wxFSFile, DetachStream)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFSFile::DetachStream\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFSFile* current_object;
    wxphp_object_type current_object_type;
    wxFSFile_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFSFile_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFSFile::DetachStream call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFSFILE_TYPE){
                references = &((wxFSFile_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFSFile::DetachStream() to return object pointer\n\n");
                #endif

                wxInputStream_php* value_to_return0;
                value_to_return0 = (wxInputStream_php*) ((wxFSFile_php*)native_object)->DetachStream();

                if(value_to_return0 == NULL){
                    RETVAL_NULL();
                }
                else if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value, php_wxInputStream_entry);
                    Z_wxInputStream_P(return_value)->native_object = (wxInputStream_php*) value_to_return0;
                }

                if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
                    references->AddReference(return_value, "wxFSFile::DetachStream at call 5 with 0 argument(s)");
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFSFile::DetachStream\n"
        );
    }
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFileSystemWatcher_free(void *object)
{
    zo_wxFileSystemWatcher* custom_object = (zo_wxFileSystemWatcher*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFileSystemWatcher_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxFileSystemWatcher done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxFileSystemWatcher_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxFileSystemWatcher_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystemWatcher* custom_object;

    custom_object = (zo_wxFileSystemWatcher*) ecalloc(
        1,
        sizeof(zo_wxFileSystemWatcher)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxFileSystemWatcher_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFILESYSTEMWATCHER_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto bool wxFileSystemWatcher::Add(wxFileName path, int events)
   Adds path to currently watched files. */
PHP_METHOD(php_wxFileSystemWatcher, Add)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystemWatcher::Add\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystemWatcher* current_object;
    wxphp_object_type current_object_type;
    wxFileSystemWatcher_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileSystemWatcher_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileSystemWatcher::Add call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILESYSTEMWATCHER_TYPE){
                references = &((wxFileSystemWatcher_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* path0;
    wxFileName* object_pointer0_0 = 0;
    long events0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 2)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O|l' (&path0, php_wxFileName_entry, &events0)\n");
        #endif

        char parse_parameters_string[] = "O|l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &path0, php_wxFileName_entry, &events0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(path0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxFileName_P(path0)->object_type;
                    argument_native_object = (void*) Z_wxFileName_P(path0)->native_object;
                    object_pointer0_0 = (wxFileName*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'path' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(path0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'path' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileSystemWatcher::Add(*(wxFileName*) object_pointer0_0))\n\n");
                #endif

                RETVAL_BOOL(((wxFileSystemWatcher_php*)native_object)->Add(*(wxFileName*) object_pointer0_0));

                references->AddReference(path0, "wxFileSystemWatcher::Add at call 3 with 1 argument(s)");

                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileSystemWatcher::Add(*(wxFileName*) object_pointer0_0, (int) events0))\n\n");
                #endif

                RETVAL_BOOL(((wxFileSystemWatcher_php*)native_object)->Add(*(wxFileName*) object_pointer0_0, (int) events0));

                references->AddReference(path0, "wxFileSystemWatcher::Add at call 3 with 2 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileSystemWatcher::Add\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileSystemWatcher::AddTree(wxFileName path, int events, string filter)
   This is the same as Add(), but also recursively adds every file/directory in the tree rooted at path. */
PHP_METHOD(php_wxFileSystemWatcher, AddTree)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystemWatcher::AddTree\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystemWatcher* current_object;
    wxphp_object_type current_object_type;
    wxFileSystemWatcher_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileSystemWatcher_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileSystemWatcher::AddTree call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILESYSTEMWATCHER_TYPE){
                references = &((wxFileSystemWatcher_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* path0;
    wxFileName* object_pointer0_0 = 0;
    long events0;
    char* filter0;
    size_t filter_len0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received >= 1  && arguments_received <= 3)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O|ls' (&path0, php_wxFileName_entry, &events0, &filter0, &filter_len0)\n");
        #endif

        char parse_parameters_string[] = "O|ls";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &path0, php_wxFileName_entry, &events0, &filter0, &filter_len0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(path0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxFileName_P(path0)->object_type;
                    argument_native_object = (void*) Z_wxFileName_P(path0)->native_object;
                    object_pointer0_0 = (wxFileName*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'path' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(path0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'path' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileSystemWatcher::AddTree(*(wxFileName*) object_pointer0_0))\n\n");
                #endif

                RETVAL_BOOL(((wxFileSystemWatcher_php*)native_object)->AddTree(*(wxFileName*) object_pointer0_0));

                references->AddReference(path0, "wxFileSystemWatcher::AddTree at call 3 with 1 argument(s)");

                return;
                break;
            }
            case 2:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileSystemWatcher::AddTree(*(wxFileName*) object_pointer0_0, (int) events0))\n\n");
                #endif

                RETVAL_BOOL(((wxFileSystemWatcher_php*)native_object)->AddTree(*(wxFileName*) object_pointer0_0, (int) events0));

                references->AddReference(path0, "wxFileSystemWatcher::AddTree at call 3 with 2 argument(s)");

                return;
                break;
            }
            case 3:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileSystemWatcher::AddTree(*(wxFileName*) object_pointer0_0, (int) events0, wxString(filter0, wxConvUTF8)))\n\n");
                #endif

                RETVAL_BOOL(((wxFileSystemWatcher_php*)native_object)->AddTree(*(wxFileName*) object_pointer0_0, (int) events0, wxString(filter0, wxConvUTF8)));

                references->AddReference(path0, "wxFileSystemWatcher::AddTree at call 3 with 3 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileSystemWatcher::AddTree\n"
        );
    }
}
/* }}} */

/* {{{ proto int wxFileSystemWatcher::GetWatchedPathsCount()
   Returns the number of currently watched paths. */
PHP_METHOD(php_wxFileSystemWatcher, GetWatchedPathsCount)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystemWatcher::GetWatchedPathsCount\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystemWatcher* current_object;
    wxphp_object_type current_object_type;
    wxFileSystemWatcher_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileSystemWatcher_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileSystemWatcher::GetWatchedPathsCount call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILESYSTEMWATCHER_TYPE){
                references = &((wxFileSystemWatcher_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_LONG(wxFileSystemWatcher::GetWatchedPathsCount())\n\n");
                #endif

                RETVAL_LONG(((wxFileSystemWatcher_php*)native_object)->GetWatchedPathsCount());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileSystemWatcher::GetWatchedPathsCount\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileSystemWatcher::Remove(wxFileName path)
   Removes path from the list of watched paths. */
PHP_METHOD(php_wxFileSystemWatcher, Remove)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystemWatcher::Remove\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystemWatcher* current_object;
    wxphp_object_type current_object_type;
    wxFileSystemWatcher_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileSystemWatcher_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileSystemWatcher::Remove call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILESYSTEMWATCHER_TYPE){
                references = &((wxFileSystemWatcher_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* path0;
    wxFileName* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&path0, php_wxFileName_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &path0, php_wxFileName_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(path0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxFileName_P(path0)->object_type;
                    argument_native_object = (void*) Z_wxFileName_P(path0)->native_object;
                    object_pointer0_0 = (wxFileName*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'path' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(path0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'path' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileSystemWatcher::Remove(*(wxFileName*) object_pointer0_0))\n\n");
                #endif

                RETVAL_BOOL(((wxFileSystemWatcher_php*)native_object)->Remove(*(wxFileName*) object_pointer0_0));

                references->AddReference(path0, "wxFileSystemWatcher::Remove at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileSystemWatcher::Remove\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileSystemWatcher::RemoveAll()
   Clears the list of currently watched paths. */
PHP_METHOD(php_wxFileSystemWatcher, RemoveAll)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystemWatcher::RemoveAll\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystemWatcher* current_object;
    wxphp_object_type current_object_type;
    wxFileSystemWatcher_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileSystemWatcher_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileSystemWatcher::RemoveAll call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILESYSTEMWATCHER_TYPE){
                references = &((wxFileSystemWatcher_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileSystemWatcher::RemoveAll())\n\n");
                #endif

                RETVAL_BOOL(((wxFileSystemWatcher_php*)native_object)->RemoveAll());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileSystemWatcher::RemoveAll\n"
        );
    }
}
/* }}} */

/* {{{ proto bool wxFileSystemWatcher::RemoveTree(wxFileName path)
   This is the same as Remove(), but also removes every file/directory belonging to the tree rooted at path. */
PHP_METHOD(php_wxFileSystemWatcher, RemoveTree)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystemWatcher::RemoveTree\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystemWatcher* current_object;
    wxphp_object_type current_object_type;
    wxFileSystemWatcher_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileSystemWatcher_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileSystemWatcher::RemoveTree call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILESYSTEMWATCHER_TYPE){
                references = &((wxFileSystemWatcher_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* path0;
    wxFileName* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'O' (&path0, php_wxFileName_entry)\n");
        #endif

        char parse_parameters_string[] = "O";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &path0, php_wxFileName_entry ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(path0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxFileName_P(path0)->object_type;
                    argument_native_object = (void*) Z_wxFileName_P(path0)->native_object;
                    object_pointer0_0 = (wxFileName*) argument_native_object;
                    if (!object_pointer0_0 )
                    {
                        zend_error(E_ERROR, "Parameter 'path' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(path0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'path' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_BOOL(wxFileSystemWatcher::RemoveTree(*(wxFileName*) object_pointer0_0))\n\n");
                #endif

                RETVAL_BOOL(((wxFileSystemWatcher_php*)native_object)->RemoveTree(*(wxFileName*) object_pointer0_0));

                references->AddReference(path0, "wxFileSystemWatcher::RemoveTree at call 3 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileSystemWatcher::RemoveTree\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileSystemWatcher::SetOwner(wxEvtHandler &handler)
   Associates the file system watcher with the given handler object. */
PHP_METHOD(php_wxFileSystemWatcher, SetOwner)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystemWatcher::SetOwner\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystemWatcher* current_object;
    wxphp_object_type current_object_type;
    wxFileSystemWatcher_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxFileSystemWatcher_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxFileSystemWatcher::SetOwner call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXFILESYSTEMWATCHER_TYPE){
                references = &((wxFileSystemWatcher_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    zval* handler0;
    wxEvtHandler* object_pointer0_0 = 0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'z' (&handler0)\n");
        #endif

        char parse_parameters_string[] = "z";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &handler0 ) == SUCCESS)
        {
            if(arguments_received >= 1){
                if(Z_TYPE_P(handler0) == IS_OBJECT)
                {
                    wxphp_object_type argument_type = Z_wxEvtHandler_P(handler0)->object_type;
                    argument_native_object = (void*) Z_wxEvtHandler_P(handler0)->native_object;
                    object_pointer0_0 = (wxEvtHandler*) argument_native_object;
                    if (!object_pointer0_0 || (argument_type != PHP_WXEVTHANDLER_TYPE && argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE && argument_type != PHP_WXVALIDATOR_TYPE && argument_type != PHP_WXTEXTVALIDATOR_TYPE && argument_type != PHP_WXGENERICVALIDATOR_TYPE && argument_type != PHP_WXMENU_TYPE && argument_type != PHP_WXAUIMANAGER_TYPE && argument_type != PHP_WXMOUSEEVENTSMANAGER_TYPE && argument_type != PHP_WXTIMER_TYPE && argument_type != PHP_WXEVENTBLOCKER_TYPE && argument_type != PHP_WXPROCESS_TYPE && argument_type != PHP_WXFILESYSTEMWATCHER_TYPE && argument_type != PHP_WXTASKBARICON_TYPE && argument_type != PHP_WXNOTIFICATIONMESSAGE_TYPE))
                    {
                        zend_error(E_ERROR, "Parameter 'handler' could not be retreived correctly.");
                    }
                }
                else if(Z_TYPE_P(handler0) != IS_NULL)
                {
                    zend_error(E_ERROR, "Parameter 'handler' not null, could not be retreived correctly.");
                }
            }

            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxFileSystemWatcher::SetOwner((wxEvtHandler*) object_pointer0_0)\n\n");
                #endif

                ((wxFileSystemWatcher_php*)native_object)->SetOwner((wxEvtHandler*) object_pointer0_0);

                references->AddReference(handler0, "wxFileSystemWatcher::SetOwner at call 1 with 1 argument(s)");

                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxFileSystemWatcher::SetOwner\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxFileSystemWatcher::wxFileSystemWatcher()
   Default constructor. */
PHP_METHOD(php_wxFileSystemWatcher, __construct)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxFileSystemWatcher::__construct\n");
    php_printf("===========================================\n");
    #endif

    zo_wxFileSystemWatcher* current_object;
    wxFileSystemWatcher_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    int arguments_received = ZEND_NUM_ARGS();


    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing __construct()\n");
                #endif

                native_object = new wxFileSystemWatcher_php();

                native_object->references.Initialize();
                break;
            }
        }
    }

    
    if(already_called)
    {
        native_object->phpObj = *getThis();


        current_object = Z_wxFileSystemWatcher_P(getThis());

        current_object->native_object = native_object;

        current_object->is_user_initialized = 1;
    }
    else
    {
        zend_error(
            E_ERROR,
            "Abstract class or wrong type/count of parameters "
            "passed to: wxFileSystemWatcher::__construct\n"
        );
    }

    #ifdef USE_WXPHP_DEBUG
        php_printf("===========================================\n\n");
    #endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxStandardPaths_free(void *object)
{
    zo_wxStandardPaths* custom_object = (zo_wxStandardPaths*) object;

    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxStandardPaths_free on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    if(custom_object->native_object != NULL)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Pointer not null\n");
        php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
        #endif

        if(custom_object->is_user_initialized)
        {
            #ifdef USE_WXPHP_DEBUG
            php_printf("Deleting pointer with delete\n");
            #endif

            delete custom_object->native_object;
            custom_object->native_object = NULL;
        }

        #ifdef USE_WXPHP_DEBUG
        php_printf("Deletion of wxStandardPaths done\n");
        php_printf("===========================================\n\n");
        #endif
    }
    else
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Not user space initialized\n");
        #endif
    }

    zend_object_std_dtor(&custom_object->zo);
    efree(custom_object);
}

zend_object* php_wxStandardPaths_new(zend_class_entry *class_type)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf(
        "Calling php_wxStandardPaths_new on %s at line %i\n",
        zend_get_executed_filename(),
        zend_get_executed_lineno()
    );
    php_printf("===========================================\n");
    #endif

    zo_wxStandardPaths* custom_object;

    custom_object = (zo_wxStandardPaths*) ecalloc(
        1,
        sizeof(zo_wxStandardPaths)
        + zend_object_properties_size(class_type)
    );

    zend_object_std_init(&custom_object->zo, class_type);
    object_properties_init(&custom_object->zo, class_type);

    custom_object->zo.handlers = &wxphp_wxStandardPaths_object_handlers;

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXSTANDARDPATHS_TYPE;
    custom_object->is_user_initialized = 0;

    return &custom_object->zo;
}
END_EXTERN_C()

/* {{{ proto wxStandardPaths wxStandardPaths::Get()
   Returns reference to the unique global standard paths object. */
PHP_METHOD(php_wxStandardPaths, Get)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStandardPaths::Get\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStandardPaths* current_object;
    wxphp_object_type current_object_type;
    wxStandardPaths_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStandardPaths_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStandardPaths::Get call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTANDARDPATHS_TYPE){
                references = &((wxStandardPaths_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Static ");
                php_printf("Executing wxStandardPaths::Get() to return object reference\n\n");
                #endif

                wxStandardPaths_php* value_to_return0;
                value_to_return0 = (wxStandardPaths_php*) &wxStandardPaths::Get();
                if(value_to_return0->references.IsUserInitialized()){
                    if(!Z_ISNULL(value_to_return0->phpObj)){
                        ZVAL_COPY_VALUE(return_value, &value_to_return0->phpObj);
                        zval_add_ref(&value_to_return0->phpObj);
                        return_is_user_initialized = true;
                    }
                    else{
                        zend_error(E_ERROR, "Could not retreive original zval.");
                    }
                }
                else{
                    object_init_ex(return_value,php_wxStandardPaths_entry);
                    Z_wxStandardPaths_P(return_value)->native_object = (wxStandardPaths_php*) value_to_return0;
                }



                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStandardPaths::Get\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxStandardPaths::GetAppDocumentsDir()
   Return the directory for the document files used by this application. */
PHP_METHOD(php_wxStandardPaths, GetAppDocumentsDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStandardPaths::GetAppDocumentsDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStandardPaths* current_object;
    wxphp_object_type current_object_type;
    wxStandardPaths_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStandardPaths_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStandardPaths::GetAppDocumentsDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTANDARDPATHS_TYPE){
                references = &((wxStandardPaths_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxStandardPaths::GetAppDocumentsDir().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXSTANDARDPATHS_TYPE)
                {
                    value_to_return0 = ((wxStandardPaths_php*)native_object)->GetAppDocumentsDir();
                }
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStandardPaths::GetAppDocumentsDir\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxStandardPaths::GetConfigDir()
   Return the directory containing the system config files. */
PHP_METHOD(php_wxStandardPaths, GetConfigDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStandardPaths::GetConfigDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStandardPaths* current_object;
    wxphp_object_type current_object_type;
    wxStandardPaths_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStandardPaths_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStandardPaths::GetConfigDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTANDARDPATHS_TYPE){
                references = &((wxStandardPaths_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxStandardPaths::GetConfigDir().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXSTANDARDPATHS_TYPE)
                {
                    value_to_return0 = ((wxStandardPaths_php*)native_object)->GetConfigDir();
                }
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStandardPaths::GetConfigDir\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxStandardPaths::GetDataDir()
   Return the location of the applications global, i.e. not user-specific, data files. */
PHP_METHOD(php_wxStandardPaths, GetDataDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStandardPaths::GetDataDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStandardPaths* current_object;
    wxphp_object_type current_object_type;
    wxStandardPaths_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStandardPaths_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStandardPaths::GetDataDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTANDARDPATHS_TYPE){
                references = &((wxStandardPaths_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxStandardPaths::GetDataDir().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXSTANDARDPATHS_TYPE)
                {
                    value_to_return0 = ((wxStandardPaths_php*)native_object)->GetDataDir();
                }
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStandardPaths::GetDataDir\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxStandardPaths::GetDocumentsDir()
   Same as calling GetUserDir() with Dir_Documents parameter. */
PHP_METHOD(php_wxStandardPaths, GetDocumentsDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStandardPaths::GetDocumentsDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStandardPaths* current_object;
    wxphp_object_type current_object_type;
    wxStandardPaths_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStandardPaths_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStandardPaths::GetDocumentsDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTANDARDPATHS_TYPE){
                references = &((wxStandardPaths_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxStandardPaths::GetDocumentsDir().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXSTANDARDPATHS_TYPE)
                {
                    value_to_return0 = ((wxStandardPaths_php*)native_object)->GetDocumentsDir();
                }
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStandardPaths::GetDocumentsDir\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxStandardPaths::GetExecutablePath()
   Return the directory and the filename for the current executable. */
PHP_METHOD(php_wxStandardPaths, GetExecutablePath)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStandardPaths::GetExecutablePath\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStandardPaths* current_object;
    wxphp_object_type current_object_type;
    wxStandardPaths_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStandardPaths_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStandardPaths::GetExecutablePath call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTANDARDPATHS_TYPE){
                references = &((wxStandardPaths_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxStandardPaths::GetExecutablePath().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXSTANDARDPATHS_TYPE)
                {
                    value_to_return0 = ((wxStandardPaths_php*)native_object)->GetExecutablePath();
                }
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStandardPaths::GetExecutablePath\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxStandardPaths::GetLocalDataDir()
   Return the location for application data files which are host-specific and can't, or shouldn't, be shared with the other machines. */
PHP_METHOD(php_wxStandardPaths, GetLocalDataDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStandardPaths::GetLocalDataDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStandardPaths* current_object;
    wxphp_object_type current_object_type;
    wxStandardPaths_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStandardPaths_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStandardPaths::GetLocalDataDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTANDARDPATHS_TYPE){
                references = &((wxStandardPaths_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxStandardPaths::GetLocalDataDir().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXSTANDARDPATHS_TYPE)
                {
                    value_to_return0 = ((wxStandardPaths_php*)native_object)->GetLocalDataDir();
                }
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStandardPaths::GetLocalDataDir\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxStandardPaths::GetPluginsDir()
   Return the directory where the loadable modules (plugins) live. */
PHP_METHOD(php_wxStandardPaths, GetPluginsDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStandardPaths::GetPluginsDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStandardPaths* current_object;
    wxphp_object_type current_object_type;
    wxStandardPaths_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStandardPaths_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStandardPaths::GetPluginsDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTANDARDPATHS_TYPE){
                references = &((wxStandardPaths_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxStandardPaths::GetPluginsDir().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXSTANDARDPATHS_TYPE)
                {
                    value_to_return0 = ((wxStandardPaths_php*)native_object)->GetPluginsDir();
                }
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStandardPaths::GetPluginsDir\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxStandardPaths::GetResourcesDir()
   Return the directory where the application resource files are located. */
PHP_METHOD(php_wxStandardPaths, GetResourcesDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStandardPaths::GetResourcesDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStandardPaths* current_object;
    wxphp_object_type current_object_type;
    wxStandardPaths_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStandardPaths_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStandardPaths::GetResourcesDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTANDARDPATHS_TYPE){
                references = &((wxStandardPaths_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxStandardPaths::GetResourcesDir().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXSTANDARDPATHS_TYPE)
                {
                    value_to_return0 = ((wxStandardPaths_php*)native_object)->GetResourcesDir();
                }
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStandardPaths::GetResourcesDir\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxStandardPaths::GetTempDir()
   Return the directory for storing temporary files, for the current user. */
PHP_METHOD(php_wxStandardPaths, GetTempDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStandardPaths::GetTempDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStandardPaths* current_object;
    wxphp_object_type current_object_type;
    wxStandardPaths_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStandardPaths_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStandardPaths::GetTempDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTANDARDPATHS_TYPE){
                references = &((wxStandardPaths_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxStandardPaths::GetTempDir().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXSTANDARDPATHS_TYPE)
                {
                    value_to_return0 = ((wxStandardPaths_php*)native_object)->GetTempDir();
                }
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStandardPaths::GetTempDir\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxStandardPaths::GetUserConfigDir()
   Return the directory for the user config files. */
PHP_METHOD(php_wxStandardPaths, GetUserConfigDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStandardPaths::GetUserConfigDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStandardPaths* current_object;
    wxphp_object_type current_object_type;
    wxStandardPaths_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStandardPaths_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStandardPaths::GetUserConfigDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTANDARDPATHS_TYPE){
                references = &((wxStandardPaths_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxStandardPaths::GetUserConfigDir().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXSTANDARDPATHS_TYPE)
                {
                    value_to_return0 = ((wxStandardPaths_php*)native_object)->GetUserConfigDir();
                }
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStandardPaths::GetUserConfigDir\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxStandardPaths::GetUserDataDir()
   Return the directory for the user-dependent application data files: */
PHP_METHOD(php_wxStandardPaths, GetUserDataDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStandardPaths::GetUserDataDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStandardPaths* current_object;
    wxphp_object_type current_object_type;
    wxStandardPaths_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStandardPaths_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStandardPaths::GetUserDataDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTANDARDPATHS_TYPE){
                references = &((wxStandardPaths_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxStandardPaths::GetUserDataDir().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXSTANDARDPATHS_TYPE)
                {
                    value_to_return0 = ((wxStandardPaths_php*)native_object)->GetUserDataDir();
                }
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStandardPaths::GetUserDataDir\n"
        );
    }
}
/* }}} */

/* {{{ proto string wxStandardPaths::GetUserLocalDataDir()
   Return the directory for user data files which shouldn't be shared with the other machines. */
PHP_METHOD(php_wxStandardPaths, GetUserLocalDataDir)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStandardPaths::GetUserLocalDataDir\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStandardPaths* current_object;
    wxphp_object_type current_object_type;
    wxStandardPaths_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStandardPaths_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStandardPaths::GetUserLocalDataDir call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTANDARDPATHS_TYPE){
                references = &((wxStandardPaths_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 0)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with '' ()\n");
        #endif

        overload0_called = true;
        already_called = true;
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 0:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing RETURN_STRING(wxStandardPaths::GetUserLocalDataDir().fn_str(), 1)\n\n");
                #endif

                wxString value_to_return0;
                if(current_object_type == PHP_WXSTANDARDPATHS_TYPE)
                {
                    value_to_return0 = ((wxStandardPaths_php*)native_object)->GetUserLocalDataDir();
                }
                RETVAL_STRING(value_to_return0.ToUTF8().data());


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStandardPaths::GetUserLocalDataDir\n"
        );
    }
}
/* }}} */

/* {{{ proto  wxStandardPaths::UseAppInfo(int info)
   Controls what application information is used when constructing paths that should be unique to this program, such as the application data directory, the plugins directory on Unix, etc. */
PHP_METHOD(php_wxStandardPaths, UseAppInfo)
{
    #ifdef USE_WXPHP_DEBUG
    php_printf("Invoking wxStandardPaths::UseAppInfo\n");
    php_printf("===========================================\n");
    #endif

    zo_wxStandardPaths* current_object;
    wxphp_object_type current_object_type;
    wxStandardPaths_php* native_object;
    void* argument_native_object = NULL;

    //Other variables used thru the code
    zval dummy;
    ZVAL_NULL(&dummy);
    bool already_called = false;
    wxPHPObjectReferences* references;
    int arguments_received = ZEND_NUM_ARGS();
    bool return_is_user_initialized = false;

    //Get native object of the php object that called the method
    if(getThis() != NULL)
    {
        current_object = Z_wxStandardPaths_P(getThis());

        if(current_object->native_object == NULL)
        {
            zend_error(
                E_ERROR,
                "Failed to get the native object for "
                "wxStandardPaths::UseAppInfo call\n"
            );

            return;
        }
        else
        {
            native_object = current_object->native_object;
            current_object_type = current_object->object_type;

            bool reference_type_found = false;

            if(current_object_type == PHP_WXSTANDARDPATHS_TYPE){
                references = &((wxStandardPaths_php*)native_object)->references;
                reference_type_found = true;
            }
        }
    }
    #ifdef USE_WXPHP_DEBUG
    else
    {
        php_printf("Processing the method call as static\n");
    }
    #endif

    //Parameters for overload 0
    long info0;
    bool overload0_called = false;

    
    //Overload 0
    overload0:
    if(!already_called && arguments_received == 1)
    {
        #ifdef USE_WXPHP_DEBUG
        php_printf("Parameters received %d\n", arguments_received);
        php_printf("Parsing parameters with 'l' (&info0)\n");
        #endif

        char parse_parameters_string[] = "l";
        if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received, parse_parameters_string, &info0 ) == SUCCESS)
        {
            overload0_called = true;
            already_called = true;
        }
    }

    
    if(overload0_called)
    {
        switch(arguments_received)
        {
            case 1:
            {
                #ifdef USE_WXPHP_DEBUG
                php_printf("Executing wxStandardPaths::UseAppInfo((int) info0)\n\n");
                #endif

                if(current_object_type == PHP_WXSTANDARDPATHS_TYPE)
                {
                    ((wxStandardPaths_php*)native_object)->UseAppInfo((int) info0);
                }


                return;
                break;
            }
        }
    }

    
    //In case wrong type/count of parameters was passed
    if(!already_called)
    {
        zend_error(
            E_ERROR,
            "Wrong type or count of parameters passed to: "
            "wxStandardPaths::UseAppInfo\n"
        );
    }
}
/* }}} */

